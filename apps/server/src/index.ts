// export default server
import type { Server, ErrorLike } from "bun"; // Import Bun's Server type and Errorlike
import { auth } from "./rest/auth";
import createApp from "./rest/create-app";
import { registerRoutes } from "./routes";
import { PgRealtimeClientOptions, WebSocketRouter } from "./sockets";
import { chatRouter } from "./sockets/chat.wsroute";
import { heartbeatRouter } from "./sockets/heartbeat.wsroute";

export const app = createApp();
// registerRoutes(app)
interface MyWebSocketData {
  userId?: string;
  roomId?: string;
  username?: string;
}
//DATABASE_URL="prisma+postgres://accelerate.prisma-data.net/?api_key=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcGlfa2V5IjoiY2RmNGZiNWUtMDBjOC00MThiLWFjYTEtYWJlMzEzMGMyNjBmIiwidGVuYW50X2lkIjoiOTJmNjcwMzJiYjU1N2VjZDU5NWNkN2MwMDkyZTg2MGRmOTdlNTVmMGVhOWZkYzY2NzBkZDExYzVhODUyNmY4MCIsImludGVybmFsX3NlY3JldCI6ImQ3NGRmNTU5LTUxYzEtNDAxNS1iNGJkLTYyZGRiOWFiNWI0MCJ9.z_eWzb9kX0r5V4xeIrg6cOYHzrF1teNCtyBmw4OsLuY"

const pgOptions: PgRealtimeClientOptions = {
  user: "postgres",
  password: "postgres",
  host: "password",
  port: 5432,
  database: "dev",
  // minPoolConnections?: number;
  // maxPoolConnections?: number;
  // channel?: string;
  // bufferInterval?: number;
  // maxBufferSize?: number;
  onError: (error: Error) => console.log(error),
};

type AdditionalWsData = Omit<MyWebSocketData, "clientId">;
const wsRouter = new WebSocketRouter<AdditionalWsData>(pgOptions);
wsRouter.addRoutes(chatRouter);
wsRouter.addRoutes(heartbeatRouter);

const PORT = 6589;
console.log(`Attempting to start server on port ${PORT}...`);

// Pass the type for the *additional* data (excluding clientId) as the first generic argument.
// Pass an empty object type `{}` as the second generic argument to satisfy the type signature.
const server = Bun.serve<AdditionalWsData, {}>({
  // Corrected: Added second type argument {}
  port: PORT,
  hostname: "0.0.0.0", // Listen on all interfaces
  routes: {
    "/ws": async (req: Request) => {
      if (req.url.includes("token")) {
        const token = req.url.split("?")[1].split("=")[1];
        req.headers.set("Authorization", `Bearer ${token}`);
        const session = await auth.api.getSession({
          headers: req.headers,
        });
        console.log("session", session);
        if (!session?.user || !session?.user.id) {
          console.log(
            "[Bun Fetch] WebSocket upgrade denied: Missing userId query param."
          );
          return new Response(
            "userId query parameter is required for WebSocket connection",
            { status: 401 }
          );
        }
        return wsRouter.upgrade(req, {
          server,
          data: {
            userId: session?.user.id,
            roomId: session?.user.id,
            clientId: session?.user.id as string,
          },
        }); // Return the WebSocketHandler
        // // return Response.json(session);
      } else {
        const session = await auth.api.signInAnonymous();

        return wsRouter.upgrade(req, {
          server,
          data: {
            userId: session?.user.id,
            roomId: session?.user.id,
            clientId: session?.user.id as string,
          },
        }); // Retur
      }
    },
  },
  fetch(
    req: Request,
    server: Server
  ): Response | Promise<Response> | undefined {
    // const url = new URL(req.url);
    //   // Pass the server instance in the environment object for Hono context
    const honoEnv = { serverInstance: server };
    return app.fetch(req, honoEnv);
    //   // --- End HTTP Request Handling ---
  },
  /**
   * Assign the WebSocket handlers generated by our custom router instance.
   */
  websocket: wsRouter.websocket,

  /**
   * Error handling for the Bun server itself.
   * Corrected return type to satisfy Bun's expected signature.
   */
  error(error: ErrorLike): void | Response | Promise<void> | Promise<Response> {
    console.error("[Bun Server Error]", error);
    // Returning a Response:
    return Promise.resolve(
      new Response(`Server error: ${error.message || "Unknown error"}`, {
        status: 500,
      })
    );
  },
});

console.log(`ðŸš€ Server listening on http://${server.hostname}:${server.port}`);

// Optional: Graceful shutdown handling
process.on("SIGINT", () => {
  console.log("\nReceived SIGINT. Shutting down server...");
  server.stop(true); // true = close existing connections gracefully
  console.log("Server stopped.");
  process.exit(0);
});

export type CashflowServerAppType = typeof app;
