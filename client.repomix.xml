This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  assets/
    main.css
  components/
    animation/
      XPStars.vue
    common/
      DesktopSection.vue
      GlobalLoading.vue
      Logo.vue
      MobileSection.vue
      ShowToasts.vue
    home/
      BigWinsCarousel.vue
      FilterBar.vue
      GameCarousel.vue
    layout/
      LayoutAuthenticated.vue
    GoogleOneTap.vue
  composables/
    EventManager.ts
    useDisplay.ts
    useLoading.ts
    useSupabaseAuth.ts
    useZilaWebsocket.ts
  router/
    index.ts
  stores/
    appBar.ts
    auth.ts
    currency.ts
    deposit.ts
    exception.ts
    game.ts
    global.ts
    index.ts
    notifications.ts
    profile.ts
    refferal.ts
    socket.ts
    user.ts
    vip.ts
  types/
    auto/
      auto-imports.d.ts
      components.d.ts
    database.types.ts
    index.ts
  utils/
    cache-key.ts
    cookies.ts
    local-storage.ts
    Network.ts
    NetworkData.ts
  views/
    AboutView.vue
    ChatView.vue
    HomeView.vue
    LoginView.vue
  App copy.vue
  App.vue
  env.d.ts
  global.d.ts
  main.ts
  supabase.ts
database.types.ts
index.html
postcss.config.js
tailwind.config.js
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/assets/main.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
body {
</file>

<file path="src/components/animation/XPStars.vue">
<template>
  <div ref="animationContainerRef" class="animation-overlay"></div>
</template>
<script setup lang="ts">
  import { ref, watch, onMounted, onBeforeUnmount, nextTick } from 'vue'
  const useUserStore = () => {
    const store = ref({ totalXp: 0 })
    ;(window as any).increaseXp = (amount: number = 10) => {
      store.value.totalXp += amount
      console.log('Mock XP increased to:', store.value.totalXp)
    }
    console.warn(
      'Using MOCK Pinia store. Replace with your actual store. ' +
        'You can trigger animation for testing by calling `increaseXp()` in the console.',
    )
    return store.value
  }
  const userStore = useUserStore()
  interface Point {
    x: number
    y: number
  }
  const props = defineProps<{
    from: Point
    to: Point
  }>()
  const NUM_STARS = 5
  const STAR_IMAGE_URL =
    '/images/animation/slots2___shared___levelUp___xpAnim___assets___star01.png'
  const PARTICLE_IMAGE_URL =
    '/images/animation/slots2___shared___levelUp___xpAnim___assets___particle.png'
  const animationContainerRef = ref<HTMLDivElement | null>(null)
  let animationFrameId: number | null = null
  interface SpellElementData {
    domElement: HTMLDivElement
    startTime: number
    duration: number
    amplitude: number
    frequency: number
    initialOffsetX: number
    initialOffsetY: number
    type: 'star' | 'particle'
    actualWidth: number
    isBlinkingParticle: boolean
    blinkRate: number
    blinkVisibleDuration: number
    pathDX: number
    pathDY: number
    pathLength: number
    normalizedPathDX: number
    normalizedPathDY: number
    perpDX: number
    perpDY: number
  }
  const activeElements = ref<SpellElementData[]>([])
  let mainPathParams = {
    pathDX: 0,
    pathDY: 0,
    pathLength: 0,
    normalizedPathDX: 0,
    normalizedPathDY: 0,
    perpDX: 0,
    perpDY: 0,
  }
  function calculateMainPathParameters() {
    const dx = props.to.x - props.from.x
    const dy = props.to.y - props.from.y
    const length = Math.sqrt(dx * dx + dy * dy) || 1
    mainPathParams = {
      pathDX: dx,
      pathDY: dy,
      pathLength: length,
      normalizedPathDX: dx / length,
      normalizedPathDY: dy / length,
      perpDX: -dy / length,
      perpDY: dx / length,
    }
  }
  onMounted(() => {
    calculateMainPathParameters()
  })
  watch(
    () => [props.from, props.to],
    () => {
      calculateMainPathParameters()
    },
    { deep: true },
  )
  function createSpellElement(
    type: 'star' | 'particle',
    delay = 0,
    spawnOffsetX: number,
    spawnOffsetY: number,
  ) {
    if (!animationContainerRef.value) return
    const element = document.createElement('div')
    element.classList.add('spell-element')
    const imageUrl = type === 'star' ? STAR_IMAGE_URL : PARTICLE_IMAGE_URL
    const fallbackColor = type === 'star' ? 'gold' : 'yellow'
    const baseMaxWidth = type === 'star' ? 50 : 15
    const baseMaxHeight = type === 'star' ? 50 : 15
    const scale = Math.random() * 0.4 + 0.6
    const actualWidth = baseMaxWidth * scale
    const actualHeight = baseMaxHeight * scale
    const fallbackSVG =
      type === 'star'
        ? `<svg viewBox="0 0 24 24" width="${actualWidth * 0.6}" height="${actualHeight * 0.6}" fill="black" style="margin:auto;"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>`
        : `<svg viewBox="0 0 10 10" width="${actualWidth * 0.8}" height="${actualHeight * 0.8}" fill="black" style="margin:auto;"><circle cx="5" cy="5" r="4.5"/></svg>`
    element.classList.add(type === 'star' ? 'star-style' : 'particle-style')
    const img = new Image()
    img.onload = () => {
      element.style.backgroundImage = `url(${imageUrl})`
      element.innerHTML = ''
    }
    img.onerror = () => {
      console.error(`Failed to load image: ${imageUrl}. Applying SVG fallback.`)
      element.style.backgroundImage = 'none'
      element.style.backgroundColor = fallbackColor
      element.innerHTML = fallbackSVG
    }
    img.src = imageUrl
    element.style.width = `${actualWidth}px`
    element.style.height = `${actualHeight}px`
    element.style.left = `${props.from.x + spawnOffsetX}px`
    element.style.top = `${props.from.y + spawnOffsetY}px`
    element.style.opacity = '1'
    animationContainerRef.value.appendChild(element)
    const startTime = performance.now() + delay
    const baseDuration =
      type === 'star' ? 1700 + Math.random() * 600 : 1750 + Math.random() * 650
    const duration = baseDuration / 2
    const amplitude = 12 + Math.random() * 18
    const frequency = 0.0055 + Math.random() * 0.003
    let isBlinkingParticle = false
    let blinkRate = 0
    let blinkVisibleDuration = 0
    if (type === 'particle' && Math.random() < 0.4) {
      isBlinkingParticle = true
      blinkRate = 230 + Math.random() * 230
      blinkVisibleDuration = blinkRate * (0.35 + Math.random() * 0.3)
    }
    activeElements.value.push({
      domElement: element,
      startTime,
      duration,
      amplitude,
      frequency,
      initialOffsetX: spawnOffsetX,
      initialOffsetY: spawnOffsetY,
      type,
      actualWidth,
      isBlinkingParticle,
      blinkRate,
      blinkVisibleDuration,
      ...mainPathParams,
    })
  }
  function animateSpell(timestamp: number) {
    let allAnimationsComplete = true
    for (let i = activeElements.value.length - 1; i >= 0; i--) {
      const elData = activeElements.value[i]
      const {
        domElement,
        startTime,
        duration,
        amplitude,
        frequency,
        type,
        isBlinkingParticle,
        blinkRate,
        blinkVisibleDuration,
        normalizedPathDX,
        normalizedPathDY,
        pathLength,
        perpDX,
        perpDY,
      } = elData
      const elapsedTime = timestamp - startTime
      if (elapsedTime < 0) {
        allAnimationsComplete = false
        continue
      }
      const progress = Math.min(elapsedTime / duration, 1)
      const pathDisplacementX = normalizedPathDX * progress * pathLength
      const pathDisplacementY = normalizedPathDY * progress * pathLength
      const oscillation =
        amplitude *
        Math.sin(
          frequency * elapsedTime + (type === 'particle' ? Math.PI / 3.5 : 0),
        )
      const undulationOffsetX = perpDX * oscillation
      const undulationOffsetY = perpDY * oscillation
      domElement.style.transform = `translateX(${pathDisplacementX + undulationOffsetX}px) translateY(${pathDisplacementY + undulationOffsetY}px)`
      let calculatedOpacity = 1
      if (progress > 0.7) {
        calculatedOpacity = Math.max(0, 1 - (progress - 0.7) / 0.3)
      }
      if (isBlinkingParticle && progress < 0.9) {
        const timeInCycle = elapsedTime % blinkRate
        if (timeInCycle > blinkVisibleDuration) {
          calculatedOpacity = Math.min(calculatedOpacity, 0.1)
        }
      }
      domElement.style.opacity = String(calculatedOpacity)
      if (progress >= 1) {
        if (domElement.parentElement) {
          domElement.parentElement.removeChild(domElement)
        }
        activeElements.value.splice(i, 1)
      } else {
        allAnimationsComplete = false
      }
    }
    if (!allAnimationsComplete) {
      animationFrameId = requestAnimationFrame(animateSpell)
    } else {
      animationFrameId = null
      console.log('Spell animation cycle complete.')
    }
  }
  async function castSpell() {
    console.log('Casting spell animation...')
    if (!animationContainerRef.value) {
      console.warn('Animation container not ready for castSpell')
      return
    }
    calculateMainPathParameters()
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId)
      animationFrameId = null
    }
    activeElements.value.forEach((elData) => {
      if (elData.domElement.parentElement) {
        elData.domElement.parentElement.removeChild(elData.domElement)
      }
    })
    activeElements.value = []
    await nextTick()
    const STAR_CREATION_INTERVAL = 35
    const PARTICLE_DELAY_AFTER_STAR = 20
    const PARTICLE_STAGGER = 8
    for (let i = 0; i < NUM_STARS; i++) {
      const starDelay = i * STAR_CREATION_INTERVAL
      const starSpawnOffsetX = (Math.random() - 0.5) * 10
      const starSpawnOffsetY = (Math.random() - 0.5) * 10
      createSpellElement('star', starDelay, starSpawnOffsetX, starSpawnOffsetY)
      const numParticlesForThisStar = i < 2 ? 3 : 2
      for (let j = 0; j < numParticlesForThisStar; j++) {
        const particleOverallDelay =
          starDelay + PARTICLE_DELAY_AFTER_STAR + j * PARTICLE_STAGGER
        const particleSpawnOffsetX =
          starSpawnOffsetX +
          mainPathParams.normalizedPathDX * -5 +
          (Math.random() - 0.5) * 6
        const particleSpawnOffsetY =
          starSpawnOffsetY +
          mainPathParams.normalizedPathDY * -5 +
          (Math.random() - 0.5) * 6
        createSpellElement(
          'particle',
          particleOverallDelay,
          particleSpawnOffsetX,
          particleSpawnOffsetY,
        )
      }
    }
    if (activeElements.value.length > 0 && !animationFrameId) {
      console.log('Starting animation loop.')
      animationFrameId = requestAnimationFrame(animateSpell)
    }
  }
  watch(
    () => userStore.totalXp,
    (newXp, oldXp) => {
      if (
        typeof newXp === 'number' &&
        typeof oldXp === 'number' &&
        newXp > oldXp
      ) {
        console.log(
          `XP changed from ${oldXp} to ${newXp}, triggering animation.`,
        )
        castSpell()
      }
    },
  )
  onBeforeUnmount(() => {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId)
    }
    activeElements.value.forEach((elData) => {
      if (elData.domElement.parentElement) {
        elData.domElement.parentElement.removeChild(elData.domElement)
      }
    })
    activeElements.value = []
  })
</script>
<style scoped>
  .animation-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    background-color: transparent;
    overflow: hidden;
    z-index: 9999;
  }
  :global(.spell-element) {
    position: absolute;
    background-size: contain;
    background-repeat: no-repeat;
    will-change: transform, opacity;
    display: flex;
    align-items: center;
    justify-content: center;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: pixelated;
  }
  :global(.star-style) {
    z-index: 2;
  }
  :global(.particle-style) {
    z-index: 1;
  }
</style>
</file>

<file path="src/components/common/DesktopSection.vue">
<script setup>
  const { containerMaxW } = useDisplay()
</script>
<template>
  <div :class="containerMaxW">
    <slot />
  </div>
</template>
</file>

<file path="src/components/common/GlobalLoading.vue">
<template>
  <div class="container">
    <div class="loader" style="transform: translateY(-20px) scale(0.4) translateX(20px)">
      <span style="font-size: 40px; font-weight: 500" class="glow">loading</span>
      <span style="--i: 1"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 2"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 3"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 4"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 5"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 6"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 7"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 8"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 9"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 10"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 11"><i class="fa-solid fa-star"></i></span>
      <span style="--i: 12"><i class="fa-solid fa-star"></i></span>
    </div>
  </div>
</template>
<script setup lang="ts">
const showLoading = ref(false)
onMounted(() => {
  setTimeout(() => {
    showLoading.value = true
  }, 300)
})
</script>
<style scoped>
.container {
  z-index: 999;
  margin: 0;
  top: 0px;
  left: 0px;
  z-index: 999999999;
  padding: 40px;
  display: flex;
  position: fixed;
  background-color: rgba(0, 0, 0, 1);
  align-items: center;
  justify-content: center;
  background-image: url('/images/loading.png');
  background-size: 100% 100%;
  min-height: 100vh;
  height: 100vh;
  min-width: 100vw;
  width: 100vw;
}
.logo {
  z-index: 99099;
  position: absolute;
  width: 200px;
  height: 180px;
  display: flex;
  align-items: center;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  justify-content: center;
}
.loader {
  z-index: 9909;
  position: absolute;
  width: 200px;
  height: 200px;
  display: flex;
  align-items: center;
  top: 55%;
  left: 25%;
  transform: translate(-50%, -50%);
  justify-content: center;
  animation: animateColor 5.2s linear infinite;
}
@keyframes animateColor {
  0% {
    filter: hue-rotate(0deg);
  }
  100% {
    filter: hue-rotate(360deg);
  }
}
.loader span {
  position: absolute;
  transform-origin: 150px;
  transform: translateX(-150px) rotate(calc(var(--i) * 30deg));
  filter: drop-shadow(0 0 5px #3cc2ff) drop-shadow(0 0 15px #3cc2ff) drop-shadow(0 0 30px #3cc2ff);
}
.loader span i {
  position: relative;
  color: #3cc2ff;
  animation: rotate-stars 2.4s linear infinite;
  animation-delay: calc(var(--i) * -0.2s);
}
@keyframes rotate-stars {
  0% {
    transform: rotate(0deg) scale(0);
  }
  50% {
    transform: rotate(180deg) scale(3);
  }
  100% {
    transform: rotate(360deg) scale(0);
  }
}
.loader span::before {
  content: '\f005';
  position: absolute;
  font-family: fontAwesome;
  font-size: 0.75em;
  color: #131a1c;
  animation: rotate-particle 2.4s linear infinite;
  animation-delay: calc(var(--i) * -0.2s);
}
@keyframes rotate-particle {
  0% {
    scale: 1;
    opacity: 0;
    rotate: 0deg;
  }
  50% {
    scale: 1;
    opacity: 1;
    rotate: 180deg;
  }
  100% {
    scale: 0;
    opacity: 0;
    rotate: 360deg;
    filter: drop-shadow(-150px 0 #3cc2ff) drop-shadow(150px 0 #3cc2ff) drop-shadow(0 150px #3cc2ff)
      drop-shadow(0 -150px #3cc2ff);
  }
}
</style>
</file>

<file path="src/components/common/Logo.vue">
<script setup lang="ts"></script>
<template>
  <div>
    <img class="w-[100%] max-w-[480px] m-auto" src="@/assets/logo.png" />
  </div>
</template>
</file>

<file path="src/components/common/MobileSection.vue">
<script setup></script>
<template>
  <div
    class="relative flex grow-1 flex-col m-0 p-0 w-screen min-h-screen overflow-hidden"
  >
    <slot />
  </div>
</template>
</file>

<file path="src/components/common/ShowToasts.vue">
<template>
  <div class="notification-container">
    <transition-group
      name="toast-fade"
      tag="div"
      enter-active-class="animate__animated animate__lightSpeedInRight animate__delay-1s"
      leave-active-class="animate__animated animate__lightSpeedOutLeft"
    >
      <div
        v-for="notification in notifications"
        :key="notification.id"
        :class="['toast', `toast-${notification.type}`]"
      >
        <span class="toast-message">{{ notification.message }}</span>
        <button
          class="toast-close"
          aria-label="Close notification"
          @click="notificationStore.removeNotification(notification.id)"
        >
          &times;
        </button>
      </div>
    </transition-group>
  </div>
</template>
⋮----
<span class="toast-message">{{ notification.message }}</span>
⋮----
<script setup lang="ts">
import { useNotificationStore } from '@/stores/notifications'
import { computed } from 'vue'
const notificationStore = useNotificationStore()
const notifications = computed(() => notificationStore.activeNotifications)
</script>
<style scoped>
.notification-container {
  position: fixed;
  top: 4px;
  right: 20px;
  z-index: 1050;
  width: 300px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.toast {
  background-color: #333;
  color: white;
  font-family: Bungee;
  padding: 12px 15px;
  border-radius: 4px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  display: flex;
  justify-content: space-between;
  align-items: center;
  will-change: transform, opacity;
  --animate-duration: 0.3s;
}
.toast-fade-enter-active,
.toast-fade-leave-active {
  transition: all 0.4s ease;
}
.toast-fade-enter-from,
.toast-fade-leave-to {
  opacity: 0;
  transform: translateX(100%);
}
.toast-info {
  background-color: #007bff;
  color: white;
}
.toast-success {
  background-color: #28a745;
  color: white;
}
.toast-warning {
  background-color: #ffc107;
  color: #333;
}
.toast-error {
  background-color: #dc3545;
  color: white;
}
.toast-message {
  flex-grow: 1;
  margin-right: 10px;
}
.toast-close {
  background: none;
  border: none;
  color: inherit;
  opacity: 0.7;
  font-size: 1.2em;
  line-height: 1;
  cursor: pointer;
  padding: 0 5px;
}
.toast-close:hover {
  opacity: 1;
}
</style>
</file>

<file path="src/components/home/BigWinsCarousel.vue">
<script setup>
  import Autoplay from "embla-carousel-autoplay";
  import emblaCarouselVue from "embla-carousel-vue";
  import { onMounted } from "vue";
  import { useGameStore } from "@/stores/game";
  const gameStore = useGameStore();
  const highRollers = gameStore.gameBigWinItem.high_rollers;
  const luckyBets = gameStore.gameBigWinItem.lucky_bets;
  const [emblaRef, emblaApi] = emblaCarouselVue(
    { loop: false, delay: 2000, axis: "y" },
    [Autoplay()]
  );
  const loaded = ref(false);
  const TWEEN_FACTOR_BASE = 0.52;
  let tweenFactor = 0;
  let tweenNodes = [];
  const numberWithinRange = (number, min, max) =>
    Math.min(Math.max(number, min), max);
  function setTweenNodes(emblaApi) {
    if (emblaApi) {
      tweenNodes = emblaApi.slideNodes().map((slideNode) => {
        return slideNode;
      });
    }
  }
  function setTweenFactor(emblaApi) {
    if (emblaApi) {
      tweenFactor = TWEEN_FACTOR_BASE * emblaApi.scrollSnapList().length;
    }
  }
  function tweenScale(emblaApi, eventName) {
    if (emblaApi) {
      const engine = emblaApi.internalEngine();
      const scrollProgress = emblaApi.scrollProgress();
      const slidesInView = emblaApi.slidesInView();
      const isScrollEvent = eventName === "scroll";
      emblaApi.scrollSnapList().forEach((scrollSnap, snapIndex) => {
        let diffToTarget = scrollSnap - scrollProgress;
        const slidesInSnap = engine.slideRegistry[snapIndex];
        slidesInSnap.forEach((slideIndex) => {
          if (isScrollEvent && !slidesInView.includes(slideIndex)) return;
          if (engine.options.loop) {
            engine.slideLooper.loopPoints.forEach((loopItem) => {
              const target = loopItem.target();
              if (slideIndex === loopItem.index && target !== 0) {
                const sign = Math.sign(target);
                if (sign === -1) {
                  diffToTarget = scrollSnap - (1 + scrollProgress);
                }
                if (sign === 1) {
                  diffToTarget = scrollSnap + (1 - scrollProgress);
                }
              }
            });
          }
          const tweenValue = 1 - Math.abs(diffToTarget * tweenFactor);
          const scale = numberWithinRange(tweenValue, 0, 1).toString();
          const tweenNode = tweenNodes[slideIndex];
          tweenNode.style.transform = `scale(${scale})`;
        });
      });
    }
  }
  function setupTweenScale(emblaApi) {
    if (emblaApi.value) {
      setTweenNodes(emblaApi.value);
      setTweenFactor(emblaApi.value);
      tweenScale(emblaApi.value);
      emblaApi.value
        .on("reInit", setTweenNodes)
        .on("reInit", setTweenFactor)
        .on("reInit", tweenScale)
        .on("scroll", tweenScale)
        .on("slideFocus", tweenScale);
      return () => {
        tweenNodes.forEach((slide) => slide.removeAttribute("style"));
      };
    }
  }
  const duration = ref(100);
  const winList = ref([...highRollers, ...luckyBets]);
  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  function insert(win) {
    const i = 0;
    winList.value.splice(i, 0, win);
  }
  function remove(win) {
    const i = items.value.indexOf(item);
    if (i > -1) {
      items.value.splice(i, 1);
    }
  }
  const items = ref([]);
  const itemCount = ref(0);
  let timerId = null;
  const MAX_ITEMS = 5;
  const addItem = () => {
    itemCount.value++;
    const newItem = bigWins[itemCount.value];
    console.log(itemCount.value);
    winList.value.unshift(newItem);
    if (itemCount.value >= bigWins.length) {
      itemCount.value = 0;
      winList.value = winList.value.slice(1);
    }
  };
  onMounted(async () => {
  });
  onUnmounted(() => {
    if (timerId) {
      clearInterval(timerId);
    }
  });
</script>
<template>
  <div class="animate__animated animate__fadeIn" style="pointer-events: none">
    <div class="flex bg-transparent bigWins" style="z-index: 0">
      <div
        class="cara rounded-xl py-2 pl-2 w-full min-h-[100%] overflow-hidden z-0 relative"
      >
        <div class="overflow-hidden no-scrollbar">
          <div class="win-feed-group flex flex-row overflow-hidden mx-1">
            <div class="horizontal-list-container">
              <TransitionGroup name="list" tag="div" class="horizontal-list">
                <div v-for="win of winList" :key="win.name" class="list-item">
                  <a
                    href="/casino/blackjack"
                    class="flex flex-col items-center w-20 cursor-pointer hover:brightness-125 win-feed-item"
                    ><div
                      class="w-20 h-[102px] flex items-center justify-center relative animate__animated animate__fadeIn animate__faster"
                    >
                      <img
                        height="102"
                        :src="`/images/games/${win.developer}/${win}.avif`"
                        class="rounded-md h-[102px]"
                        alt="casino game"
                        fetchpriority="high"
                        loading="eager"
                      />
                    </div>
                    <div class="w-full text-2xs leading-4">
                      <div
                        class="flex items-center justify-center flex-nowrap gap-1 font-semibold"
                      >
                        <div
                          class="flex-none flex items-center text-primitives-light-blue-500"
                        >
                          <div
                            class="justify-between flex flex-row items-center align-center"
                          >
                            <div
                              class="rounded-full h-[100px]"
                              style="
                                height: 30px;
                                width: 30px;
                                z-index: -2;
                                left: 0px;
                                margin-left: -14px;
                                margin-top: 0px;
                                background-size: 100%;
                                border-radius: 999px;
                                background-position: center;
                                background-repeat: no-repeat;
                              "
                              :style="`background-image: url('/images/avatars/${win.avatar}');`"
                            />
                            <div class="flex-0" style="width: 2px"></div>
                            <span
                              class="flex-1 text-neutral-50 truncate"
                              style="font-size: 13px"
                              >{{ win.user_name }}</span
                            >
                          </div>
                        </div>
                      </div>
                      <div
                        class="w-full font-mono font-normal text-[#59D48F] text-center"
                        style="font-size: 12px"
                      >
                        {{ win.amount }} USD
                      </div>
                    </div>
                  </a>
                </div>
              </TransitionGroup>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
⋮----
>{{ win.user_name }}</span
⋮----
{{ win.amount }} USD
⋮----
<style scoped>
  @charset "UTF-8";
  .horizontal-list-container {
    position: relative;
    z-index: 0;
    width: 100%;
    margin-left: 120px;
    max-width: 100vw;
    overflow: hidden;
    padding-bottom: 5px;
    box-sizing: border-box;
  }
  .horizontal-list {
    display: flex;
    padding: 0 10px;
    flex-wrap: nowrap;
  }
  .list-item {
    position: relative;
    background-color: rgba(98, 10, 133, 0.4);
    border-width: 1px;
    border-style: solid;
    border-color: rgba(98, 10, 133, 0.6);
    flex-shrink: 0;
    padding: 2px 5px;
    color: white;
    border-radius: 5px;
    min-width: 80px;
    text-align: center;
    margin-left: 10px;
  }
  .list-move,
.list-enter-active,
.list-leave-active {
    transition: all 0.5s cubic-bezier(0.55, 0, 0.1, 1);
  }
  .list-enter-from {
    opacity: 1;
    scale: 0;
    transform: scaleY(1) translateX(-120px);
  }
  .list-leave-to {
    opacity: 1;
    transform: scaleY(0.01) translateX(120px, -120px);
  }
  .list-leave-active {
  }
  .cara {
    -webkit-text-size-adjust: 100%;
    font-feature-settings: normal;
    font-variation-settings: normal;
    tab-size: 4;
    -webkit-tap-highlight-color: transparent;
    --form-input-height: 36px;
    --form-checkbox-size: 18px;
    color-scheme: dark;
    --nav-height: 60px;
    --bottom-nav-height: 76px;
    --vertical-nav-width: 280px;
    --color-primary-50: 231 255 230;
    --color-primary-100: 203 254 201;
    --color-primary-200: 155 252 154;
    --color-primary-300: 95 247 97;
    --color-primary-400: 37 235 42;
    --color-primary-500: 16 210 24;
    --color-primary-600: 8 168 17;
    --color-primary-700: 11 128 20;
    --color-primary-800: 9 98 11;
    --color-primary-900: 18 85 25;
    --color-primary-950: 4 47 10;
    --color-primary-green: 37 235 42;
    --color-primary-orange: 252 121 32;
    --color-primary-blue-light: 79 160 255;
    --color-primary-blue: 28 132 255;
    --color-primary-blue-medium: 17 56 102;
    --color-primary-blue-darker: 22 32 44;
    --color-primary-red: 229 10 48;
    --color-primary-pink: 221 0 152;
    --color-primary-purple: 130 0 255;
    --color-primary-strong: 77 75 83;
    --color-gray-0: 245 245 245;
    --color-gray-25: 226 226 226;
    --color-gray-50: 176 172 183;
    --color-gray-75: 146 146 146;
    --color-gray-100: 87 85 94;
    --color-gray-200: 87 85 94;
    --color-gray-300: 74 73 80;
    --color-gray-400: 62 60 68;
    --color-gray-500: 52 50 57;
    --color-gray-600: 44 42 50;
    --color-gray-610: 77 75 83;
    --color-gray-700: 37 35 41;
    --color-gray-800: 29 28 31;
    --color-gray-900: 23 22 26;
    --color-gray-950: 18 17 20;
    --color-gray-975: 27 26 30;
    --color-gray-1000: 10 10 10;
    --color-primary-DEFAULT: var(--color-primary-400);
    line-height: inherit;
    font-family:
      Inter,
      system-ui,
      BlinkMacSystemFont,
      -apple-system,
      Fira Sans,
      Droid Sans,
      Helvetica Neue,
      sans-serif;
    -webkit-font-smoothing: antialiased;
    --tw-border-spacing-x: 0;
    --tw-border-spacing-y: 0;
    --tw-translate-x: 0;
    --tw-translate-y: 0;
    --tw-rotate: 0;
    --tw-skew-x: 0;
    --tw-skew-y: 0;
    --tw-scale-x: 1;
    --tw-scale-y: 1;
    --tw-pan-x: ;
    --tw-pan-y: ;
    --tw-pinch-zoom: ;
    --tw-scroll-snap-strictness: proximity;
    --tw-gradient-from-position: ;
    --tw-gradient-via-position: ;
    --tw-gradient-to-position: ;
    --tw-ordinal: ;
    --tw-slashed-zero: ;
    --tw-numeric-figure: ;
    --tw-numeric-spacing: ;
    --tw-numeric-fraction: ;
    --tw-ring-inset: ;
    --tw-ring-offset-width: 0px;
    --tw-ring-offset-color: #fff;
    --tw-ring-color: rgba(30, 148, 223, 0.5);
    --tw-ring-offset-shadow: 0 0 #0000;
    --tw-ring-shadow: 0 0 #0000;
    --tw-shadow: 0 0 #0000;
    --tw-shadow-colored: 0 0 #0000;
    --tw-blur: ;
    --tw-brightness: ;
    --tw-contrast: ;
    --tw-grayscale: ;
    --tw-hue-rotate: ;
    --tw-invert: ;
    --tw-saturate: ;
    --tw-sepia: ;
    --tw-drop-shadow: ;
    --tw-backdrop-blur: ;
    --tw-backdrop-brightness: ;
    --tw-backdrop-contrast: ;
    --tw-backdrop-grayscale: ;
    --tw-backdrop-hue-rotate: ;
    --tw-backdrop-invert: ;
    --tw-backdrop-opacity: ;
    --tw-backdrop-saturate: ;
    --tw-backdrop-sepia: ;
    --tw-contain-size: ;
    --tw-contain-layout: ;
    --tw-contain-paint: ;
    --tw-contain-style: ;
    border-color: rgb(var(--color-gray-200) / 1);
    border-style: solid;
    border-width: 0;
    box-sizing: border-box;
    position: relative;
    z-index: 2;
    min-height: 142px;
    width: 100%;
    overflow: hidden;
    border-radius: 12px;
    --tw-bg-opacity: 1;
    padding-bottom: 0.1rem;
    padding-top: 0.5rem;
    padding-left: 0.5rem;
  }
  .gradient-border-mask {
    display: block;
    position: relative;
    padding: 2px;
    max-width: 600px;
  }
  .gradient-border-mask::before {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: 45px;
    border: 5px solid transparent;
    background: linear-gradient(to right, red, orange) border-box;
    -webkit-mask:
      linear-gradient(#fff 0 0) padding-box,
      linear-gradient(#fff 0 0);
    mask:
      linear-gradient(#fff 0 0) padding-box,
      linear-gradient(#fff 0 0);
    -webkit-mask-composite: destination-out;
    mask-composite: exclude;
  }
  .bigwin {
    -webkit-text-size-adjust: 100%;
    tab-size: 4;
    max-width: 22em;
    pointer-events: none;
    font-family:
      Roboto,
      ui-sans-serif,
      system-ui,
      sans-serif,
      Apple Color Emoji,
      Segoe UI Emoji,
      Segoe UI Symbol,
      Noto Color Emoji;
    font-feature-settings: normal;
    margin-bottom: 3px;
    font-variation-settings: normal;
    border-width: 0;
    border-style: solid;
    border-image-slice: 7 12 14 5;
    border-color: rgba(var(--gray-200));
    box-sizing: border-box;
    scrollbar-width: thin;
    scrollbar-color: rgb(var(--gray-700) / 0.3) transparent;
    background-image: linear-gradient(
      68deg,
      #da0000,
      #fe5000 22%,
      #fe8c00 84%,
      #fff800
    );
    height: 50px;
    border-radius: 9999px;
    padding: 0.125rem;
    .rounded-full {
      border-radius: 9999px;
    }
    .h-\[30px\] {
      height: 30px;
    }
    .bg-gradient-orange-red {
      background-image: linear-gradient(68.3deg, #f5b161 0.4%, #ec366e 100.2%);
    }
    * {
      scrollbar-width: thin;
      scrollbar-color: rgb(var(--gray-700) / 0.3) transparent;
    }
    * {
      box-sizing: border-box;
    }
    *,
    :after,
    :before {
      box-sizing: border-box;
      border-width: 0;
      border-style: solid;
      border-color: rgba(var(--gray-200));
    }
  }
  @font-face {
    font-family: knight;
    src:
      local("Pixel"),
      url("/Kanit-ExtraBold.ttf") format("truetype");
  }
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  .knight {
    font-family: "knight", serif;
  }
  .bigWins {
    display: flex;
    justify-content: end;
    align-items: center;
    overflow: hidden;
  }
  .embla {
    overflow: hidden;
  }
  .embla__container {
    display: flex;
  }
  .embla__slide {
    flex: 0 0 100%;
    min-width: 0;
  }
</style>
</file>

<file path="src/components/home/FilterBar.vue">
<script lang="ts" setup>
  const display = ref(true);
  const shakeIt = ref(false);
</script>
<template>
  <div
    class="flex flex-row justify-center mt-3"
    style="max-width: fit-content; margin-inline: auto"
  >
    <div
      v-show="display"
      class="basis-1/2 animate__animated animate__slideInUp flex"
      style="
        background-color: white !important;
        z-index: 21;
        background-repeat: no-repeat;
        background-color: transparent;
        justify-content: center;
        max-height: 50px;
        align-items: center;
      "
    >
      <img
        src="/images/side-arrow-prev.avif "
        class="mr-2 flex"
        style="text-align: center"
      />
      <div
        class="animate__animated animate__slideInUp bottomDropper ml-2 flex p-0"
      >
        <AllIcon :shake="shakeIt" />
      </div>
      <div class="animate__animated animate__slideInUp bottomDropper flex">
        <FishIcon :shake="shakeIt" />
      </div>
      <div
        class="animate__animated animate__slideInUp bottomDropper flex"
        @click=""
      >
        <SlotsIcon :shake="shakeIt" />
      </div>
      <div
        class="animate__animated animate__slideInUp bottomDropper flex justify-center align-middle"
        @click=""
      />
      <img
        src="/images/side-arrow.avif"
        class="ml-2 flex"
        style="text-align: center"
      />
    </div>
  </div>
</template>
<style scoped>
  .bottomDropper {
    --animate-duration: 0.3s;
  }
  .div --active {
    background-color: transparent;
  }
  .div --active {
    background-color: transparent;
    margin-top: 5px;
  }
  .van-tabbar {
    height: 42px;
    font-family: "bungeecolor";
  }
</style>
</file>

<file path="src/components/home/GameCarousel.vue">
<script setup lang="ts">
import { useGameStore } from '@/stores/game'
import { ref, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import FlameEffectOverlay from './animation/FlameEffectOverlay.vue'
interface Game {
  id: number
  title: string
  developer: string
  name: string
  temperature: 'hot' | 'cold' | 'none'
  featured?: boolean
}
const router = useRouter()
const gameStore = useGameStore()
const games = ref<Game[]>(gameStore.gameSearchList.list)
async function loadGame(game: any) {
  const token = localStorage.getItem('access_token')
  if (!token) {
    console.error('No access token found. Cannot load game.')
    return
  }
  if (game.developer === 'netgame') {
    await router.push(`/games/netgame/?gameName=${game.name}&token=${token}`)
  } else if (game.developer === 'netent') {
    await router.push(`/games/netent/?gameName=${game.name}&token=${token}`)
  } else if (game.developer === 'nolimit') {
    await router.push(`/games/nolimit/?gameName=${game.name}&token=${token}`)
  } else if (game.developer === 'redtiger') {
    await router.push(`/games/redtiger/?gameName=${game.name}&token=${token}`)
  } else {
    console.warn(`Unsupported developer: ${game.developer}`)
  }
}
onMounted(() => {
  games.value = gameStore.gameSearchList.list
})
const onImageError = (event: Event) => {
  const target = event.target as HTMLImageElement
  target.src = 'https://placehold.co/300x400/64748b/ffffff?text=Image+Error'
  target.style.objectFit = 'contain'
}
const isFeatured = (game: Game) => game.featured === true
</script>
<template>
  <div class="carousel-container bungee relative">
    <div class="carousel-scroll-area">
      <div class="carousel-track">
        <div
          v-for="game in games"
          :key="game.id"
          class="game-card"
          :class="{
            'theme-cold': game.temperature === 'cold',
            'theme-hot': game.temperature === 'hot',
          }"
        >
          <div class="gradient-border"></div>
          <div
            class="card-content relative flex flex-col pt-5"
            :class="{ 'feat flex-col mt-3 align-bottom': isFeatured(game) }"
            @click="loadGame(game)"
            :style="{
              backgroundImage: `url(${
                !isFeatured(game) ? '/images/games/tall-field.avif' : '/images/games/featured.webp'
              })`,
            }"
            style="background-size: 100% 100%; background-repeat: no-repeat"
          >
            <div :class="isFeatured(game) ? 'card__banner_feat' : 'card__banner'">
              <img
                v-if="game.temperature === 'cold'"
                src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/49240/hand-banner-blue.png"
                alt=""
                class="card__banner-img"
              />
              <img
                v-else-if="game.temperature === 'hot'"
                src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/49240/hand-banner-gold.png"
                alt=""
                class="card__banner-img"
              />
              <img
                v-else
                src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/49240/hand-banner-black.png"
                alt=""
                class="card__banner-img"
              />
              <div class="card__banner__text bungee pt-.5" style="line-height: 1.7">
                <span :style="game.name.length > 12 ? 'font-size: .8rem; ' : 'font-size: 1rem'">
                  {{ game.name }}
                </span>
              </div>
            </div>
            <div
              :class="isFeatured(game) ? 'card-image-container feat box' : 'card-image-container'"
              class="absolute top-0"
              style="z-index: 1"
            >
              <img
                :src="`https://images.cashflowcasino.com/${game.developer}/${game.name.toLowerCase()}.avif`"
                :alt="game.title"
                class="game-image absolute top-0"
                style="z-index: 0"
                @error="onImageError"
              />
                <SnowEffectOverlay
                class="absolute bottom-20"
                style="z-index: 2;  width: 30px; bottom: -30px; opacity: .8; height: 20%; "
                v-if="game.temperature === 'cold'"
              />
              <FlameEffectOverlay
                class="absolute bottom-20"
                style="z-index: 2;  width: 40px; bottom: -30px; opacity: .8; height: 30%; "
                v-if="game.temperature === 'hot'"
              />
              <img
                src="/images/games/speedRTP_1.gif"
                height="40px"
                width="40px"
                style="position: absolute; bottom: 0; left: 0;"
                v-if="game.temperature === 'cold'"
              />
              <img
                src="/images/games/speedRTP_5.gif"
                height="40px"
                width="40px"
                v-if="game.temperature === 'hot'"
                style="position: absolute; bottom: 0; left: 0"
              >
              </img>
            <div class="bottom-banner">
              {{ game.developer }}
            </div>
          </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
⋮----
{{ game.name }}
⋮----
{{ game.developer }}
⋮----
<style scoped>
.card-image-container {
  height: 100%;
  flex-grow: 1;
  overflow: hidden;
  position: relative;
  border-radius: inherit;
  top: 0;
  z-index: 1;
}
.game-image {
  z-index: 0;
  display: block;
  width: 92%;
  height: 83%;
  margin-top: 10%;
  margin-left: 8px;
  margin-right: 5px;
  top: 0;
  border-radius: 15px;
  border-top-left-radius: 30px;
  border-top-right-radius: 30px;
  border-color: white;
  border-width: 1.5px;
  border-left-style: solid;
  border-right-style: solid;
  border-bottom-style: solid;
  border-top-style: none;
  object-fit: cover;
  transition: transform 0.3s ease;
  position: absolute;
}
.box {
  height: 40vh;
  min-height: 300px;
  max-height: 450px;
  display: grid;
  place-content: center;
  color: white;
  text-shadow: 0 1px 0 #000;
  --border-angle: 0turn;
  --main-bg: conic-gradient(from var(--border-angle), #213, #112 5%, #112 60%, #213 95%);
  border: solid 2px transparent;
  border-top: 0px;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0px;
  border-top-left-radius: 0;
  border-top-right-radius: 0px;
  --gradient-border: conic-gradient(
    from var(--border-angle),
    transparent 25%,
    #08f,
    #f03 99%,
    transparent
  );
  background:
    var(--main-bg) padding-box,
    var(--gradient-border) border-box,
    var(--main-bg) border-box;
  background-position: center center;
  -webkit-animation: bg-spin 2.5s linear infinite;
  animation: bg-spin 2s linear infinite;
}
@-webkit-keyframes bg-spin {
  to {
    --border-angle: 1turn;
  }
}
@keyframes bg-spin {
  to {
    --border-angle: 1turn;
  }
}
.box:hover {
  -webkit-animation-play-state: paused;
  animation-play-state: paused;
}
@property --border-angle {
  syntax: '<angle>';
  inherits: true;
  initial-value: 0turn;
}
.carousel-container {
  height: 40vh;
  min-height: 300px;
  max-height: 450px;
  width: 100%;
  overflow-x: auto;
  max-width: 600px;
  margin: 0 auto;
  margin-top: 0px;
  overflow: hidden;
  position: relative;
  padding: 0 10px;
  box-sizing: border-box;
  margin-bottom: 20px;
}
.carousel-scroll-area {
  display: flex;
  overflow-x: auto;
  overflow-y: hidden;
  height: 100%;
  max-width: 600px;
  scrollbar-width: none;
  &::-webkit-scrollbar {
    height: 8px;
  }
  &::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
  }
  &::-webkit-scrollbar-thumb {
    background: linear-gradient(to right, #a855f7, #ec4899);
    border-radius: 4px;
    border: 1px solid rgba(0, 0, 0, 0.3);
  }
  &::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(to right, #9333ea, #f472b6);
  }
}
.carousel-track {
  display: inline-flex;
  gap: 15px;
  padding: 0px 15px;
  height: 100%;
  box-sizing: border-box;
}
.game-card {
  flex-shrink: 0;
  min-width: 200px;
  max-width: 280px;
  width: calc(100vw - 220px);
  margin-left: 10px;
  height: 100%;
  border-radius: 15px;
  position: relative;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.2s ease-out;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
}
.card__banner {
  width: 100%;
  position: absolute;
  top: 5%;
  left: 51%;
  transform: translateX(-51.5%) scaleY(1.1);
  background: url('https://s3-us-west-2.amazonaws.com/s.cdpn.io/49240/hand-banner-gold.png') 0 0
    no-repeat;
  background-size: 100% 110%;
  z-index: 4;
}
.card__banner_feat {
  width: 100%;
  position: absolute;
  top: 9%;
  left: 51%;
  transform: translateX(-51.5%);
  background: url('https://s3-us-west-2.amazonaws.com/s.cdpn.io/49240/hand-banner-gold.png') 0 0
    no-repeat;
  background-size: 100% auto;
  z-index: 4;
}
.card__banner-img {
  display: block;
  width: 100%;
  height: auto;
}
.card__banner__text {
  width: 90%;
  position: absolute;
  flex-wrap: nowrap;
  top: -2px;
  font-weight: 800;
  left: 50%;
  padding-left: 7px;
  padding-right: 7px;
  transform: translate(-51%, 10%);
  z-index: 5;
  text-align: center;
  font-size: 16px;
  font-weight: 600;
  color: #ffffff;
  text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.7);
}
.gradient-border {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  padding: 4px;
  z-index: 1;
  background-clip: content-box, border-box;
  background-origin: border-box;
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
}
.theme-cold .gradient-border {
  background-image: linear-gradient(135deg, #a855f7, #ec4899);
}
.theme-hot .gradient-border {
  background-image: linear-gradient(135deg, #f97316, #eab308);
}
.card-content {
  z-index: 2;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  border-radius: inherit;
  top: 0;
}
.card-content.feat {
  z-index: 2;
  width: 100%;
  height: 95%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  border-radius: inherit;
  top: 0;
}
.card-image-container.feat {
  margin-top: 25px;
}
.card-image-container.feat.span {
  margin-left: 5px;
  margin-right: 5px;
}
.bottom-banner {
  position: absolute;
  left: 0;
  width: 100%;
  background-color: transparent;
  color: white;
  text-align: center;
  font-size: 0.9rem;
  font-weight: bold;
  padding: 8px 8px;
  text-transform: uppercase;
  z-index: 3;
  box-sizing: border-box;
  bottom: 0;
  border-bottom-left-radius: inherit;
  border-bottom-right-radius: inherit;
}
@media (max-width: 768px) {
  .game-card {
    min-width: 150px;
  }
  .top-banner {
    font-size: 0.7rem;
  }
  .bottom-banner {
    font-size: 0.8rem;
    padding: 6px;
  }
}
@media (max-width: 480px) {
  .game-card {
    min-width: 130px;
  }
  .carousel-track {
    gap: 10px;
  }
  .carousel-container {
    padding: 0 5px;
  }
}
</style>
</file>

<file path="src/components/layout/LayoutAuthenticated.vue">
<script setup lang="ts">
import { useCashflowSocket } from '@/composables/useZilaWebsocket'
import { eventBus } from '@/composables/eventBus'
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { useAppBarStore } from '@/stores/appBar'
import { useAuthStore } from '@/stores/auth'
import { useDepositStore } from '@/stores/deposit'
import { useSocketStore } from '@/stores/socket'
import { WSStatus } from 'zilaws-client'
const shopOpen = ref(false)
const appBarStore = useAppBarStore()
const authStore = useAuthStore()
const depositStore = useDepositStore()
const socketStore = useSocketStore()
const { connectionStatus } = useCashflowSocket()
const router = useRouter()
const settingsModal = ref(false)
const isAsideMobileExpanded = ref(false)
const isAsideLgActive = ref(false)
const isConnected = computed(() => connectionStatus.value === WSStatus.OPEN)
const orientation = useScreenOrientation()
const overlayScrimBackground = ref<string>('rgb(var(--v-theme-on-surface))')
watch(orientation, async (newOrienation) => {
  console.log(newOrienation)
})
router.beforeEach(() => {
  isAsideMobileExpanded.value = false
  isAsideLgActive.value = false
})
eventBus.on('settingsModal', (val) => {
  settingsModal.value = val
})
watch(
  connectionStatus,
  (newValue) => {
    console.log(newValue)
  },
  { deep: true },
)
const overlayScrimShow = computed(() => {
  const { getOverlayScrimShow } = storeToRefs(appBarStore)
  return getOverlayScrimShow.value
})
watch(overlayScrimShow, (newValue) => {
  if (newValue) {
    overlayScrimBackground.value = 'transparent'
  } else {
    overlayScrimBackground.value = 'rgb(var(--v-theme-on-surface))'
  }
  document.documentElement.style.setProperty('--background-color', overlayScrimBackground.value)
})
function runTest() {
}
const token = computed(() => {
  const { getToken } = storeToRefs(authStore)
  return getToken.value
})
onMounted(async () => {
  if (token.value != undefined) {
    await socketStore.dispatchSocketConnect()
  }
})
</script>
<template>
  <div
    v-if="isConnected"
    style="z-index: 999999; position: absolute; top: -2px; right: -6px; width: 25px"
  >
    <img src="/images/connection-high.png" h="10" w="15" @click="runTest" />
  </div>
  <div v-else style="z-index: 999999; position: absolute; top: -2px; right: -6px; width: 25px">
    <img src="/images/connection-off.png" h="10" w="15" />
  </div>
  <LobbyBackground />
  <div style="position: fixed">
    <div class="flex flex-col gap-3 h-screen">
      <div class="flex flex-col mt-12 w-screen">
        <slot />
      </div>
      <SettingsView :has-cancel="false" :model-value="settingsModal" />
      <ShopView v-if="depositStore.shopOpen" />
    </div>
  </div>
</template>
<style scoped></style>
</file>

<file path="src/components/GoogleOneTap.vue">

</file>

<file path="src/composables/EventManager.ts">
export interface eventobject {
  call: Function;
  target: any;
}
⋮----
export function useEventManager()
⋮----
const on = (eventName: string, callback: Function, target: any) =>
const emit = (eventName: string, ...args: any[]) =>
const off = (eventName: string, target: any) =>
const removeAllEvent = (remove?: string | any) =>
</file>

<file path="src/composables/useDisplay.ts">
import { ref, onMounted, onUnmounted } from 'vue'
export function useDisplay(maxWidth = 768)
⋮----
const handleResize = () =>
</file>

<file path="src/composables/useLoading.ts">
import { ref } from 'vue';
export function useLoading()
⋮----
const startLoading = () =>
const stopLoading = () =>
const withLoading = async (promise) =>
</file>

<file path="src/composables/useSupabaseAuth.ts">
import { ref, onMounted, onUnmounted, computed } from 'vue'
import { supabase } from '../supabase'
import { useAuthStore } from '../stores/auth'
import { useUserStore, type UserData } from '../stores/user'
import { useProfileStore, type ProfileData } from '../stores/profile'
import type {
  AuthChangeEvent,
  Session,
  SignInWithPasswordCredentials,
  SignUpWithPasswordCredentials,
  Subscription,
  User,
  AuthError as SupabaseAuthError,
} from '@supabase/supabase-js'
import type { Database } from '../types/database.types'
import { uuid } from '@electric-sql/pglite'
import { ProfileStatsUpdateData, UserStatsUpdateData } from '@cashflow/types'
⋮----
export function useSupabaseAuth()
⋮----
async function _createPublicUserAndProfile(
    authUser: User,
    providedUsername?: string,
    providedAvatarUrl?: string,
): Promise<
async function fetchPublicUserData(userId: string): Promise<UserData | null>
async function fetchUserProfile(
    userId: string,
    activeProfileId?: string | null,
): Promise<ProfileData | null>
const handleAuthStateChange = async (
    event: AuthChangeEvent,
    session: Session | null,
) =>
async function signInWithPassword(
    credentials: SignInWithPasswordCredentials,
)
async function signUpNewUser(credentials: SignUpWithPasswordCredentials)
async function signInWithGoogleIdToken(idToken: string)
async function signOut()
async function subscribeGlobalAuth()
</file>

<file path="src/composables/useZilaWebsocket.ts">
import { connectTo, WSStatus, ZilaConnection } from '@/services/wsClient'
import { useNotificationStore } from '@/stores/notifications'
import { useUserStore } from '@/stores/user'
import type {
  ProfileStatsUpdateData,
  StatsUpdate,
  UserStatsUpdateData,
} from '@cashflow/types'
import { useQueryClient } from '@tanstack/vue-query'
import { readonly, ref, shallowRef } from 'vue'
interface WebSocketNotificationMessage {
  type: 'server_notification'
  payload: {
    message: string
    level?: 'info' | 'success' | 'warning' | 'error'
    displayDuration?: number
  }
}
interface WebSocketStatUpdateMessage {
  type: 'profiles_change'
  data: any
}
interface MessageToServer {
  type: string
  data: any
}
const defaultIsNotificationMessage = (
  data: any,
): data is WebSocketNotificationMessage
const defaultIsStatsUpdateMessage = (
  data: any,
): data is WebSocketStatUpdateMessage
⋮----
async function _setupConnection(
  route: string,
  userId: string,
  _isNotificationMessage: (data: any) => boolean,
  _isStatsUpdateMessage: (data: any) => boolean,
)
⋮----
export async function initializeWebSocket(
  url: string,
  userId: string,
  isNotificationMessage: (data: any) => boolean = defaultIsNotificationMessage,
  isStatsUpdateMessage: (data: any) => boolean = defaultIsStatsUpdateMessage,
): Promise<void>
export function useCashflowSocket()
</file>

<file path="src/router/index.ts">
import type {
  RouteLocationNormalizedGeneric,
  RouteRecordNameGeneric,
  RouteRecordRaw,
} from 'vue-router'
import { createRouter, createWebHistory } from 'vue-router'
import { useGlobalStore } from '@/stores/global'
⋮----
export function isWhiteList(to: RouteLocationNormalizedGeneric)
</file>

<file path="src/stores/appBar.ts">
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
⋮----
// Getters converted to computed properties
⋮----
// Actions converted to regular functions
const setSuccess = (isSuccess: boolean) =>
const setErrorMessage = (message: string) =>
const setRightBarToggle = (toggle: boolean) =>
const setNavBarToggle = (toggle: boolean) =>
const setDepositDialogToggle = (toggle: boolean) =>
const setWithdrawDialogToggle = (toggle: boolean) =>
const setCashDialogToggle = (toggle: boolean) =>
const setUserNavBarToggle = (toggle: boolean) =>
const setMainBlurEffectShow = (show: boolean) =>
const setOverlayScrimShow = (show: boolean) =>
const setAccountDialogShow = (show: boolean) =>
const setDepositBlurEffectShow = (show: boolean) =>
const setFixPositionEnable = (enable: boolean) =>
const setHeaderBlurEffectShow = (show: boolean) =>
const setMenuBlurEffectShow = (show: boolean) =>
const setDepositHeaderBlurEffectShow = (show: boolean) =>
const setDepositWithdrawToggle = (toggle: boolean) =>
const setBonusDashboardDialogVisible = (visible: boolean) =>
const setActiveAccountIndex = (index: number) =>
</file>

<file path="src/stores/auth.ts">
import { defineStore } from 'pinia'
import type { Session, AuthError } from '@supabase/supabase-js'
import { ref, computed } from 'vue'
import { NETWORK_CONFIG, User } from '@cashflow/types'
⋮----
import type {
  GetUserAmountResponseData,
  GetUserInfoResponseData,
  User as IUser,
  UpdateEmail,
  UpdatePassword,
  UpdateSuspendUser,
} from '@cashflow/types'
import { handleException } from './exception'
import { router } from '@/router'
import { NetworkData } from '@/utils/NetworkData'
import { Network } from '@/utils/Network'
⋮----
// Actions
function setSession(newSession: Session | null)
function setLoading(isLoading: boolean)
function setError(authError: AuthError | null)
function setInitialAuthCheckComplete(isComplete: boolean)
// const userInfo = ref<IUser>({
//   id: '',
//   name: '',
//   email: '',
//   emailVerified: false,
//   image: '',
//   createdAt: undefined,
//   updatedAt: undefined,
//   lastDailySpin: undefined,
//   twoFactorEnabled: false,
//   role: '',
//   banned: false,
//   banReason: '',
//   banExpires: undefined,
//   username: '',
//   passwordHash: '',
//   totalXp: 0,
//   balance: 0,
//   isVerified: false,
//   active: false,
//   lastLogin: undefined,
//   verificationToken: '',
//   avatar: '',
//   activeProfileId: '',
//   gender: 'BOY',
⋮----
const setAuthModalType = (type: string) =>
const setSuccess = (isSuccess: boolean) =>
const setErrorMessage = (message: string) =>
const setIsAuthenticated = (b: boolean) =>
const setToken = (newToken: string) =>
const removeToken = () =>
⋮----
// operator: null,
// userProfileUseridtouser: null,
⋮----
const setUserInfo = (info: Partial<IUser>) =>
const setUserAmount = (amount: SignIn.GetUserAmount) =>
const setDialogCheckbox = (checked: boolean) =>
const setAuthDialogVisible = (visible: boolean) =>
const setSignUpForm = (isSignUp: boolean) =>
const setNickNameDialogVisible = (visible: boolean) =>
const dispatchSignIn = async (msg: SignIn.SigninRequestData) =>
⋮----
const next = (response: SignIn.GetSigninResponseData) =>
⋮----
const dispatchSignUp = async (
      msg: SignUp.SignupRequestData,
): Promise<Boolean> =>
const dispatchUserProfile = async () =>
const dispatchUserAmount = async () =>
const dispatchUpdateUserInfo = async (data: any) =>
const dispatchUpdateEmail = async (data: UpdateEmail) =>
const dispatchUpdatePassword = async (data: UpdatePassword) =>
const dispatchSuspendUser = async (data: UpdateSuspendUser) =>
const dispatchSignout = () =>
</file>

<file path="src/stores/currency.ts">
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { NETWORK_CONFIG } from '@cashflow/types'
⋮----
import { handleException } from './exception'
import { Network } from '@/utils/Network'
⋮----
const dispatchCurrencyList = async () =>
⋮----
const next = (response: Currency.GetCurrencyBalanceListResponse) =>
</file>

<file path="src/stores/deposit.ts">
import { defineStore } from "pinia";
import { ref, computed } from "vue";
import { handleException } from "./exception";
import {
  DepositHistoryResponse,
  DepositItem,
  GetDepositHistoryResponse,
  GetDepositResponse,
  GetOperatorDataResponse,
  GetPixInfo,
  GetProductsResponse,
  NETWORK_CONFIG,
  OperatorData,
  Product,
  SubmitDepositResponse,
} from "@cashflow/types";
import { Network } from "@/utils/Network";
⋮----
// Keeping 'any' type as in original
⋮----
const depositSubmit = ref<any>({}); // Keeping 'any' type as in original
const pixInfo = ref<GetPixInfo>({} as GetPixInfo); // Keeping type assertion as in original
⋮----
const setSuccess = (isSuccess: boolean) =>
const toggleShopOpen = () =>
const setSelectedPaymentMethod = (method: string) =>
const setSelectedProduct = (product: Product) =>
const setErrorMessage = (message: string) =>
const setDepositCfg = (config: any) =>
const setDepositSubmit = (submit: any) =>
const setPixInfo = (info: GetPixInfo) =>
const setPixInfoToggle = (toggle: boolean) =>
const setDepositHistoryItem = (item: DepositHistoryResponse) =>
const setProducts = (item: Product[]) =>
const setOperatorData = (item: OperatorData) =>
const dispatchProducts = async () =>
⋮----
const next = (response: GetProductsResponse) =>
⋮----
const dispatchOperatorData = async () =>
const dispatchUserDepositCfg = async () =>
const dispatchUserDepositSubmit = async (data: DepositItem) =>
const dispatchUserDepositHistory = async (data: any) =>
</file>

<file path="src/stores/exception.ts">
export const handleException = (code: number) =>
</file>

<file path="src/stores/game.ts">
import { defineStore } from 'pinia'
import { NETWORK_CONFIG } from '@cashflow/types'
import { handleException } from './exception'
import { useAuthStore } from '@/stores/auth'
import { useAppBarStore } from '@/stores/appBar'
import { Network } from '@/utils/Network'
type dialogType = 'login' | 'signup'
⋮----
export type Category = any
export type GameSearchResponse = {
    list: any[]
    total: number
  }
export type GameEnterResponse = {
    method: string
    parames: string
    developer: string
    reserve: string
    weburl: string
  }
export type Search = any
export type GameHistoryResponse = {
    total_pages: number
    record: any[]
  }
export type GameBigWinData = {
    high_rollers: any[]
    lucky_bets: any[]
  }
export type GetGameCategoriesResponse = {
    code: number
    data: Category[]
  }
export type GetGameSearchResponse = {
    code: number
    data: GameSearchResponse
  }
export type GameUserBody = any
export type GetGameEnterResponse = {
    code: number
    data: GameEnterResponse
  }
export type GetGameHistoryResponse = {
    code: number
    data: GameHistoryResponse
  }
export type GetGameBigWinResponse = {
    code: number
    data: GameBigWinData
  }
export type GetGameFavoriteListResponse = {
    code: number
    data: (number | string)[]
  }
export type GameEnterBody = {
    id: string | string[]
    demo: boolean
  }
⋮----
/**
     * @state gameCategories - An array of game categories.
     */
⋮----
/**
     * @state gamedevelopers - An array of game developers.
     */
⋮----
/**
     * @state gameSearchList - Contains the list of searched games and the total count.
     */
⋮----
/**
     * @state enterGameItem - Contains data required to enter a game.
     */
⋮----
/**
     * @state searchGameDialogShow - Controls the visibility of the search game dialog.
     */
⋮----
/**
     * @state mobileMenuShow - Controls the visibility of the mobile menu.
     */
⋮----
/**
     * @state searchTextList - An array of search terms.
     */
⋮----
/**
     * @state gameFilterText - The current text used for filtering games.
     */
⋮----
/**
     * @state originalGames - An array to store the original list of games.
     */
⋮----
/**
     * @state gameHistoryItem - Contains the game history.
     */
⋮----
/**
     * @state userSpinPage - Contains data about the user's spin page.
     */
⋮----
// const target = 'bettech'
⋮----
function setSuccess(_success: boolean)
function setErrorMessage(message: string)
function setGameCategories(_gameCategories: Array<Game.Category>)
function setGamedevelopers(_gamedevelopers: Array<Game.Category>)
function setGameSearchList(_gameSearchList: Game.GameSearchResponse)
function setGameEnterItem(_enterGameItem: Game.GameEnterResponse)
function setSearchGameDialogShow(_searchGameDialogShow: boolean)
function setSearchTextList(searchText: string)
function removeSearchTextList(index: number)
function removeAllSearchTextList()
function setGameFilterText(_gameFilterText: string)
function setOriginalGames(_originalGames: Array<Game.Search>)
function setMobileMenuShow(_mobileMenuShow: boolean)
function setGameHistoryItem(_gameHistoryItem: Game.GameHistoryResponse)
function setUserSpinPage(_userSpinPage: any)
function setUserSpin(userSpin: any)
function setLanguage(lang: string)
function setFavoriteGameList(_favoriteGameList: Array<number | string>)
function openDialog(type: dialogType)
function closeKill()
function setGameBigWinItem(_gameBigWinItem: Game.GameBigWinData)
function inject(_gameBigWinItem: Game.GameBigWinData)
async function getGameBetbyInit()
async function dispatchGameCategories(sub_api: string)
⋮----
const next = (response: Game.GetGameCategoriesResponse) =>
⋮----
async function dispatchGameSearch(sub_api: string)
async function dispatchUserGame(data: Game.GameUserBody)
async function dispatchFavoriteGame(data: any)
async function dispatchGameEnter(data: Game.GameEnterBody)
async function dispatchGameHistory(data: any)
async function dispatchUserSpinPage(data: any)
async function dispatchUserSpin()
async function dispatchGameBigWin()
async function dispatchGameFavoriteList()
</file>

<file path="src/stores/global.ts">
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
⋮----
const startLoading = () =>
const finishLoading = () =>
</file>

<file path="src/stores/index.ts">
import { createPinia } from 'pinia'
import type { Pinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'
⋮----
export async function setupStore(app: any)
export function resetAllStores()
export async function hydrateStores(): Promise<boolean>
export async function startSubscriptions(): Promise<boolean>
</file>

<file path="src/stores/notifications.ts">
import { defineStore } from 'pinia'
import { computed, ref } from 'vue'
export interface Notification {
  id: number
  message: string
  type: 'info' | 'success' | 'warning' | 'error'
  duration: number
}
⋮----
function addNotification(
    message: string,
    type: Notification['type'] = 'info',
    duration: number = 5000,
)
function removeNotification(id: number)
</file>

<file path="src/stores/profile.ts">
import { defineStore } from 'pinia'
import { ref } from 'vue'
import type { Database } from '../types/database.types'
export type ProfileData = Database['public']['Tables']['profiles']['Row'] | null
⋮----
function setProfile(profileData: ProfileData)
function clearProfile()
</file>

<file path="src/stores/refferal.ts">
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
⋮----
const setRefferalAppBarShow = (show: boolean) =>
const setRefferalDialogShow = (visible: boolean) =>
</file>

<file path="src/stores/socket.ts">
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { NETWORK_CONFIG } from '@cashflow/types'
import { useAuthStore } from './auth'
import { useUserStore } from './user'
import { WSStatus } from '@/services/wsClient'
import {
  initializeWebSocket,
  useCashflowSocket,
} from '@/composables/useZilaWebsocket'
export interface GetUserBalance {
  bal: string | number
  cur: string
  mt: number
}
⋮----
// Getters
⋮----
// Actions
function setSuccess(newSuccess: boolean)
function setErrorMessage(newMessage: string)
function setSocketBalance(newSocketBalance: GetUserBalance)
// async function connected(x: any) {
//   console.log('connected ', x)
// }
// socket connect check
async function dispatchSocketConnect()
function handleOpen()
function handleMessage(event: MessageEvent)
function handleError(event: Event)
function handleClose(event: CloseEvent)
</file>

<file path="src/stores/user.ts">
import { store } from '@/stores'
import { setToken as _setToken, getToken, removeToken } from '@/utils/cookies'
import { handleException } from './exception'
import { NETWORK_CONFIG } from '@cashflow/types'
import type {
  ProfileStatsUpdateData,
  User,
  UserStatsUpdateData,
} from '@cashflow/types'
import type {
  GetUserBalance,
  GetUserBalanceResponseData,
} from '@cashflow/types'
import { Network } from '@/utils/Network'
import type { Database } from '../types/database.types'
export type UserData = Database['public']['Tables']['user']['Row'] | null
⋮----
// const currentUser = ref<Partial<User>>()
⋮----
// Actions
function setUser(userData: UserData)
function clearUser()
⋮----
// if (currentUser.value === undefined) return 0
// const nextXpLevel = expScale[currentUser.value.vipRankLevel as number]
// console.log(nextXpLevel)
// console.log(currentUser.value.vipPoints / nextXpLevel)
// return (15 / nextXpLevel) * 100
⋮----
const setUserBalance = (_userBalance: GetUserBalance) =>
const updateCurrentUserProfile = (
      _profileUpdate: ProfileStatsUpdateData,
) =>
const updateCurrentUser = (_userUpdate: UserStatsUpdateData) =>
⋮----
const getUserBalance = () =>
const setToken = (value: string) =>
const setSuccess = (value: boolean) =>
const setCurrentUser = (_user: Partial<User>) =>
const setErrorMessage = (value: string) =>
const updateCurrentUserBalance = (balanceUpdate: any | number) =>
const setUserInfo = (userInfo: User) =>
const setUserGameStat = (stat: string, value: number) =>
const changeRoles = (role: string) =>
const resetToken = () =>
// const register = async (username: string, password: string): Promise<boolean> => {
//   console.log(username)
//   const avatar = '11'
const dispatchSetUserCurrency = async (currency: string) =>
⋮----
const next = (response: any) =>
⋮----
const dispatchUserBalance = async () =>
const dispatchUserCashtag = async (cashtag: string) =>
const dispatchSignout = async (): Promise<void> =>
⋮----
export function useUserStoreOutside()
</file>

<file path="src/stores/vip.ts">
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
⋮----
import { NETWORK_CONFIG } from '@cashflow/types'
import { handleException } from './exception'
import { Network } from '@/utils/Network'
⋮----
const vipInfo = ref<Vip.VipInfo>({} as Vip.VipInfo) // Keeping type assertion as in original
⋮----
) // Keeping type assertion as in original
⋮----
) // Keeping type assertion as in original
const vipNavBarToggle = ref(localStorage.getItem('vipBar') || '') // Initialize from localStorage
⋮----
) // Keeping type assertion as in original
⋮----
) // Keeping type assertion as in original
⋮----
) // Keeping type assertion as in original
// Getters converted to computed properties
⋮----
// const { t } = useI18n()
// Actions converted to regular functions
const setSuccess = (isSuccess: boolean) =>
const setErrorMessage = (message: string) =>
const setVipInfo = (info: Vip.VipInfo) =>
const setVipLevels = (levels: Array<Vip.VipLevel>) =>
const setVipTasks = (tasks: Array<Vip.VipTaskItem>) =>
const setVipRebateHistory = (history: Vip.VipRebateHistoryData) =>
const setVipLevelRewardHistory = (
      history: Vip.VipLevelRewardHistoryData,
) =>
const setVipTimesHistory = (history: Vip.VipTimesHistoryData) =>
const setVipSignIn = (signInData: Vip.VipSignInData) =>
const setLevelUpDialogVisible = (visible: boolean) =>
const setVipLevelUpList = (list: Vip.VipLevelUpListData) =>
const setVipLevelUpReceive = (receiveData: Vip.VipLevelUpReceiveData) =>
const setVipNavBarToggle = (toggle: string) =>
const setVipCycleawardList = (list: Vip.VipCycleawardListData) =>
const setVipLevelAward = (awardData: Vip.VipLevelAwardData) =>
const setVipBetawardList = (list: Vip.vipBetawardListData) =>
const alertMessage = (
      successMessage: Vip.SuccessMessageParams,
      message?: string,
) =>
async function dispatchVipSignIn()
⋮----
const next = (response: Vip.GetVipSignInResponse) =>
⋮----
async function dispatchVipSigninawardReceive()
async function dispatchVipSignInReward()
async function dispatchVipInfo()
async function dispatchVipLevels()
async function dispatchVipTasks()
async function dispatchVipRebateAward(data: any)
async function dispatchVipRebateHistory(data: Vip.VipRebateHistoryRequest)
async function dispatchVipLevelRewardHistory(
      data: Vip.VipLevelRewardHistoryRequest,
)
async function dispatchVipTimesHistory(data: Vip.VipTimesHistoryRequest)
async function dispatchVipLevelUpList()
async function dispatchVipLevelUpReceive()
async function dispatchVipCycleawardList()
async function dispatchVipCycleawardReceive(
      data: Vip.VipCycleawardReceiveRequest,
)
/**
     * Get level-related rewards  获取等级相关奖励
     */
async function dispatchVipLevelAward()
⋮----
// Note: response type is Vip.GetVipLevelAwardResponse in original, check if correct
⋮----
/**
     * Receive level-related rewards  领取等级相关奖励
     * @param data Reward type 5: Upgrade reward 6: Upgrade reward
     * @param data 领取奖励类型 5: 升级奖励 6: 升段奖励
     */
async function dispatchVipLevelAwardReceive(
      data: Vip.VipLevelAwardReceiveRequest,
)
⋮----
// Note: response type is Vip.GetVipLevelAwardResponse in original, check if correct
⋮----
/**
     * Get coding rebates  获取打码返利
     */
async function dispatchVipBetawardList()
⋮----
// Note: response type is Vip.GetVipLevelAwardResponse in original, check if correct
⋮----
/**
     * Get coding rebates  领取打码返利
     * @param data Reward type 7: Coding rewards
     * @param data 领取奖励类型 7: 打码奖励
     */
async function dispatchVipBetawardReceive(
      data: Vip.VipBetawardReceiveRequest,
)
⋮----
// Note: response type is Vip.GetVipLevelAwardResponse in original, check if correct
</file>

<file path="src/types/auto/auto-imports.d.ts">

</file>

<file path="src/types/auto/components.d.ts">
export interface GlobalComponents {
    BigWinsCarousel: typeof import('./../../components/home/BigWinsCarousel.vue')['default']
    copy: typeof import('./../../components/common/Logo copy.vue')['default']
    DesktopSection: typeof import('./../../components/common/DesktopSection.vue')['default']
    FilterBar: typeof import('./../../components/home/FilterBar.vue')['default']
    GameCarousel: typeof import('./../../components/home/GameCarousel.vue')['default']
    GlobalLoading: typeof import('./../../components/common/GlobalLoading.vue')['default']
    GoogleOneTap: typeof import('./../../components/GoogleOneTap.vue')['default']
    LayoutAuthenticated: typeof import('./../../components/layout/LayoutAuthenticated.vue')['default']
    Logo: typeof import('./../../components/common/Logo.vue')['default']
    MobileSection: typeof import('./../../components/common/MobileSection.vue')['default']
    RouterLink: typeof import('vue-router')['RouterLink']
    RouterView: typeof import('vue-router')['RouterView']
    ShowToasts: typeof import('./../../components/common/ShowToasts.vue')['default']
    XPStars: typeof import('./../../components/animation/XPStars.vue')['default']
  }
</file>

<file path="src/types/database.types.ts">
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]
export type Database = {
  public: {
    Tables: {
      account: {
        Row: {
          accessToken: string | null
          accessTokenExpiresAt: string | null
          accountId: string
          createdAt: string
          id: string
          idToken: string | null
          password: string | null
          providerId: string
          refreshToken: string | null
          refreshTokenExpiresAt: string | null
          scope: string | null
          updatedAt: string | null
          userId: string
        }
        Insert: {
          accessToken?: string | null
          accessTokenExpiresAt?: string | null
          accountId: string
          createdAt?: string
          id: string
          idToken?: string | null
          password?: string | null
          providerId: string
          refreshToken?: string | null
          refreshTokenExpiresAt?: string | null
          scope?: string | null
          updatedAt?: string | null
          userId: string
        }
        Update: {
          accessToken?: string | null
          accessTokenExpiresAt?: string | null
          accountId?: string
          createdAt?: string
          id?: string
          idToken?: string | null
          password?: string | null
          providerId?: string
          refreshToken?: string | null
          refreshTokenExpiresAt?: string | null
          scope?: string | null
          updatedAt?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'account_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      achievement: {
        Row: {
          createdAt: string
          description: string
          id: string
          isActive: boolean
          name: string
          reward: number | null
          targetXp: number
          updatedAt: string | null
        }
        Insert: {
          createdAt?: string
          description: string
          id: string
          isActive?: boolean
          name: string
          reward?: number | null
          targetXp: number
          updatedAt?: string | null
        }
        Update: {
          createdAt?: string
          description?: string
          id?: string
          isActive?: boolean
          name?: string
          reward?: number | null
          targetXp?: number
          updatedAt?: string | null
        }
        Relationships: []
      }
      chatmessages: {
        Row: {
          channel: Database['public']['Enums']['ChatChannel']
          content: string
          createdAt: string
          id: string
          metadata: Json | null
          roomId: string | null
          userId: string
        }
        Insert: {
          channel: Database['public']['Enums']['ChatChannel']
          content: string
          createdAt?: string
          id: string
          metadata?: Json | null
          roomId?: string | null
          userId: string
        }
        Update: {
          channel?: Database['public']['Enums']['ChatChannel']
          content?: string
          createdAt?: string
          id?: string
          metadata?: Json | null
          roomId?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'chatmessages_roomId_fkey'
            columns: ['roomId']
            isOneToOne: false
            referencedRelation: 'chatrooms'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'chatmessages_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      chatrooms: {
        Row: {
          createdAt: string
          gameSessionId: string | null
          id: string
          isGameRoom: boolean
          name: string
        }
        Insert: {
          createdAt?: string
          gameSessionId?: string | null
          id: string
          isGameRoom?: boolean
          name: string
        }
        Update: {
          createdAt?: string
          gameSessionId?: string | null
          id?: string
          isGameRoom?: boolean
          name?: string
        }
        Relationships: [
          {
            foreignKeyName: 'chatrooms_gameSessionId_fkey'
            columns: ['gameSessionId']
            isOneToOne: false
            referencedRelation: 'gamesessions'
            referencedColumns: ['id']
          },
        ]
      }
      event_logs: {
        Row: {
          created_at: string | null
          id: number
          operation: string
          payload: Json | null
          row_id: string | null
          table_name: string
        }
        Insert: {
          created_at?: string | null
          id?: number
          operation: string
          payload?: Json | null
          row_id?: string | null
          table_name: string
        }
        Update: {
          created_at?: string | null
          id?: number
          operation?: string
          payload?: Json | null
          row_id?: string | null
          table_name?: string
        }
        Relationships: []
      }
      friendships: {
        Row: {
          createdAt: string
          friendId: string
          id: string
          status: Database['public']['Enums']['FriendshipStatus']
          updatedAt: string | null
          userId: string
        }
        Insert: {
          createdAt?: string
          friendId: string
          id: string
          status?: Database['public']['Enums']['FriendshipStatus']
          updatedAt?: string | null
          userId: string
        }
        Update: {
          createdAt?: string
          friendId?: string
          id?: string
          status?: Database['public']['Enums']['FriendshipStatus']
          updatedAt?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'friendships_friendId_fkey'
            columns: ['friendId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'friendships_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      games: {
        Row: {
          active: boolean
          advanced: string | null
          bet: number | null
          bids: number | null
          cask: number | null
          category: Database['public']['Enums']['GameCategory']
          categoryId: string | null
          categoryTemp: number | null
          chanceFirepot1: number | null
          chanceFirepot2: number | null
          chanceFirepot3: number | null
          createdAt: string
          currentRtp: number | null
          denomination: number | null
          developer: string | null
          device: number | null
          featured: boolean | null
          fireCount1: number | null
          fireCount2: number | null
          fireCount3: number | null
          gamebank: string | null
          id: string
          isActive: boolean | null
          jackpotGroupId: string | null
          linesPercentConfigBonus: string | null
          linesPercentConfigBonusBonus: string | null
          linesPercentConfigSpin: string | null
          linesPercentConfigSpinBonus: string | null
          name: string
          operatorId: string | null
          originalId: number | null
          password: string | null
          popularity: number | null
          providerId: string | null
          rezerv: number | null
          rtpStatIn: number | null
          rtpStatOut: number | null
          scaleMode: string
          slotViewState: string
          standardRtp: number | null
          statIn: number | null
          statOut: number | null
          temperature: string | null
          title: string
          updatedAt: string | null
          view: number | null
          vipLevel: number | null
        }
        Insert: {
          active?: boolean
          advanced?: string | null
          bet?: number | null
          bids?: number | null
          cask?: number | null
          category?: Database['public']['Enums']['GameCategory']
          categoryId?: string | null
          categoryTemp?: number | null
          chanceFirepot1?: number | null
          chanceFirepot2?: number | null
          chanceFirepot3?: number | null
          createdAt?: string
          currentRtp?: number | null
          denomination?: number | null
          developer?: string | null
          device?: number | null
          featured?: boolean | null
          fireCount1?: number | null
          fireCount2?: number | null
          fireCount3?: number | null
          gamebank?: string | null
          id: string
          isActive?: boolean | null
          jackpotGroupId?: string | null
          linesPercentConfigBonus?: string | null
          linesPercentConfigBonusBonus?: string | null
          linesPercentConfigSpin?: string | null
          linesPercentConfigSpinBonus?: string | null
          name: string
          operatorId?: string | null
          originalId?: number | null
          password?: string | null
          popularity?: number | null
          providerId?: string | null
          rezerv?: number | null
          rtpStatIn?: number | null
          rtpStatOut?: number | null
          scaleMode?: string
          slotViewState?: string
          standardRtp?: number | null
          statIn?: number | null
          statOut?: number | null
          temperature?: string | null
          title: string
          updatedAt?: string | null
          view?: number | null
          vipLevel?: number | null
        }
        Update: {
          active?: boolean
          advanced?: string | null
          bet?: number | null
          bids?: number | null
          cask?: number | null
          category?: Database['public']['Enums']['GameCategory']
          categoryId?: string | null
          categoryTemp?: number | null
          chanceFirepot1?: number | null
          chanceFirepot2?: number | null
          chanceFirepot3?: number | null
          createdAt?: string
          currentRtp?: number | null
          denomination?: number | null
          developer?: string | null
          device?: number | null
          featured?: boolean | null
          fireCount1?: number | null
          fireCount2?: number | null
          fireCount3?: number | null
          gamebank?: string | null
          id?: string
          isActive?: boolean | null
          jackpotGroupId?: string | null
          linesPercentConfigBonus?: string | null
          linesPercentConfigBonusBonus?: string | null
          linesPercentConfigSpin?: string | null
          linesPercentConfigSpinBonus?: string | null
          name?: string
          operatorId?: string | null
          originalId?: number | null
          password?: string | null
          popularity?: number | null
          providerId?: string | null
          rezerv?: number | null
          rtpStatIn?: number | null
          rtpStatOut?: number | null
          scaleMode?: string
          slotViewState?: string
          standardRtp?: number | null
          statIn?: number | null
          statOut?: number | null
          temperature?: string | null
          title?: string
          updatedAt?: string | null
          view?: number | null
          vipLevel?: number | null
        }
        Relationships: [
          {
            foreignKeyName: 'games_operatorId_fkey'
            columns: ['operatorId']
            isOneToOne: false
            referencedRelation: 'operators'
            referencedColumns: ['id']
          },
        ]
      }
      gamesessions: {
        Row: {
          active: boolean
          betAmount: number | null
          endTime: string | null
          gameId: string
          id: string
          metadata: Json | null
          profileId: string
          startTime: string
          tournamentId: string | null
          vipInfoId: string | null
          winAmount: number | null
          xpEarned: number
        }
        Insert: {
          active?: boolean
          betAmount?: number | null
          endTime?: string | null
          gameId: string
          id: string
          metadata?: Json | null
          profileId: string
          startTime?: string
          tournamentId?: string | null
          vipInfoId?: string | null
          winAmount?: number | null
          xpEarned?: number
        }
        Update: {
          active?: boolean
          betAmount?: number | null
          endTime?: string | null
          gameId?: string
          id?: string
          metadata?: Json | null
          profileId?: string
          startTime?: string
          tournamentId?: string | null
          vipInfoId?: string | null
          winAmount?: number | null
          xpEarned?: number
        }
        Relationships: [
          {
            foreignKeyName: 'gamesessions_gameId_fkey'
            columns: ['gameId']
            isOneToOne: false
            referencedRelation: 'games'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'gamesessions_profileId_fkey'
            columns: ['profileId']
            isOneToOne: false
            referencedRelation: 'profiles'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'gamesessions_tournamentId_fkey'
            columns: ['tournamentId']
            isOneToOne: false
            referencedRelation: 'tournaments'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'gamesessions_vipInfoId_fkey'
            columns: ['vipInfoId']
            isOneToOne: false
            referencedRelation: 'vip_infos'
            referencedColumns: ['id']
          },
        ]
      }
      invitations: {
        Row: {
          email: string
          expiresAt: string
          id: string
          inviterId: string
          organizationId: string
          role: string | null
          status: string
        }
        Insert: {
          email: string
          expiresAt: string
          id: string
          inviterId: string
          organizationId: string
          role?: string | null
          status: string
        }
        Update: {
          email?: string
          expiresAt?: string
          id?: string
          inviterId?: string
          organizationId?: string
          role?: string | null
          status?: string
        }
        Relationships: [
          {
            foreignKeyName: 'invitations_inviterId_fkey'
            columns: ['inviterId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'invitations_organizationId_fkey'
            columns: ['organizationId']
            isOneToOne: false
            referencedRelation: 'organizations'
            referencedColumns: ['id']
          },
        ]
      }
      members: {
        Row: {
          createdAt: string
          id: string
          organizationId: string
          role: string
          userId: string
        }
        Insert: {
          createdAt?: string
          id: string
          organizationId: string
          role: string
          userId: string
        }
        Update: {
          createdAt?: string
          id?: string
          organizationId?: string
          role?: string
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'members_organizationId_fkey'
            columns: ['organizationId']
            isOneToOne: false
            referencedRelation: 'organizations'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'members_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      messages: {
        Row: {
          authorId: string | null
          content: string | null
          createdAt: string
          id: string
          updatedAt: string | null
        }
        Insert: {
          authorId?: string | null
          content?: string | null
          createdAt?: string
          id: string
          updatedAt?: string | null
        }
        Update: {
          authorId?: string | null
          content?: string | null
          createdAt?: string
          id?: string
          updatedAt?: string | null
        }
        Relationships: []
      }
      notifications: {
        Row: {
          createdAt: string
          id: string
          isRead: boolean
          message: string
          metadata: Json | null
          readAt: string | null
          title: string
          type: Database['public']['Enums']['NotificationType']
          userId: string
        }
        Insert: {
          createdAt?: string
          id: string
          isRead?: boolean
          message: string
          metadata?: Json | null
          readAt?: string | null
          title: string
          type: Database['public']['Enums']['NotificationType']
          userId: string
        }
        Update: {
          createdAt?: string
          id?: string
          isRead?: boolean
          message?: string
          metadata?: Json | null
          readAt?: string | null
          title?: string
          type?: Database['public']['Enums']['NotificationType']
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'notifications_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      operatorgames: {
        Row: {
          createdAt: string
          description: string | null
          id: string
          isActive: boolean
          isPromoted: boolean
          maxBet: number | null
          minBet: number | null
          name: string
          operatorId: string
          slug: string
          thumbnail: string | null
          updatedAt: string | null
          xpMultiplier: number
        }
        Insert: {
          createdAt?: string
          description?: string | null
          id: string
          isActive?: boolean
          isPromoted?: boolean
          maxBet?: number | null
          minBet?: number | null
          name: string
          operatorId: string
          slug: string
          thumbnail?: string | null
          updatedAt?: string | null
          xpMultiplier?: number
        }
        Update: {
          createdAt?: string
          description?: string | null
          id?: string
          isActive?: boolean
          isPromoted?: boolean
          maxBet?: number | null
          minBet?: number | null
          name?: string
          operatorId?: string
          slug?: string
          thumbnail?: string | null
          updatedAt?: string | null
          xpMultiplier?: number
        }
        Relationships: []
      }
      operators: {
        Row: {
          acceptedPayments: string[] | null
          balance: number
          createdAt: string
          description: string | null
          id: string
          isActive: boolean
          logo: string | null
          name: string
          ownerId: string
          slug: string
          updatedAt: string | null
        }
        Insert: {
          acceptedPayments?: string[] | null
          balance?: number
          createdAt?: string
          description?: string | null
          id: string
          isActive?: boolean
          logo?: string | null
          name: string
          ownerId: string
          slug: string
          updatedAt?: string | null
        }
        Update: {
          acceptedPayments?: string[] | null
          balance?: number
          createdAt?: string
          description?: string | null
          id?: string
          isActive?: boolean
          logo?: string | null
          name?: string
          ownerId?: string
          slug?: string
          updatedAt?: string | null
        }
        Relationships: [
          {
            foreignKeyName: 'operators_ownerId_fkey'
            columns: ['ownerId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      organizations: {
        Row: {
          createdAt: string
          id: string
          logo: string | null
          metadata: string | null
          name: string
          slug: string | null
        }
        Insert: {
          createdAt?: string
          id: string
          logo?: string | null
          metadata?: string | null
          name: string
          slug?: string | null
        }
        Update: {
          createdAt?: string
          id?: string
          logo?: string | null
          metadata?: string | null
          name?: string
          slug?: string | null
        }
        Relationships: []
      }
      platform_sessions: {
        Row: {
          active: boolean
          activeGameId: string | null
          createdAt: string
          expiresAt: string
          id: string
          ipAddress: string | null
          refreshToken: string | null
          token: string
          updatedAt: string | null
          userAgent: string | null
          userId: string
        }
        Insert: {
          active?: boolean
          activeGameId?: string | null
          createdAt?: string
          expiresAt: string
          id: string
          ipAddress?: string | null
          refreshToken?: string | null
          token: string
          updatedAt?: string | null
          userAgent?: string | null
          userId: string
        }
        Update: {
          active?: boolean
          activeGameId?: string | null
          createdAt?: string
          expiresAt?: string
          id?: string
          ipAddress?: string | null
          refreshToken?: string | null
          token?: string
          updatedAt?: string | null
          userAgent?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'platform_sessions_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      products: {
        Row: {
          amountToReceiveInCredits: number
          bestValue: number
          bonusCode: string | null
          bonusSpins: number
          bonusTotalInCredits: number
          createdAt: string
          description: string
          discountInCents: number
          id: string
          isPromo: boolean | null
          priceInCents: number
          shopId: string | null
          title: string
          totalDiscountInCents: number
          type: string
          updatedAt: string | null
          url: string
        }
        Insert: {
          amountToReceiveInCredits?: number
          bestValue?: number
          bonusCode?: string | null
          bonusSpins?: number
          bonusTotalInCredits?: number
          createdAt?: string
          description?: string
          discountInCents?: number
          id: string
          isPromo?: boolean | null
          priceInCents?: number
          shopId?: string | null
          title?: string
          totalDiscountInCents?: number
          type?: string
          updatedAt?: string | null
          url?: string
        }
        Update: {
          amountToReceiveInCredits?: number
          bestValue?: number
          bonusCode?: string | null
          bonusSpins?: number
          bonusTotalInCredits?: number
          createdAt?: string
          description?: string
          discountInCents?: number
          id?: string
          isPromo?: boolean | null
          priceInCents?: number
          shopId?: string | null
          title?: string
          totalDiscountInCents?: number
          type?: string
          updatedAt?: string | null
          url?: string
        }
        Relationships: [
          {
            foreignKeyName: 'products_shopId_fkey'
            columns: ['shopId']
            isOneToOne: false
            referencedRelation: 'operators'
            referencedColumns: ['id']
          },
        ]
      }
      profiles: {
        Row: {
          balance: number
          createdAt: string
          currency: string
          id: string
          isActive: boolean
          lastPlayed: string | null
          phpId: number | null
          shopId: string
          updatedAt: string | null
          userId: string
          xpEarned: number
        }
        Insert: {
          balance?: number
          createdAt?: string
          currency?: string
          id: string
          isActive?: boolean
          lastPlayed?: string | null
          phpId?: number | null
          shopId: string
          updatedAt?: string | null
          userId: string
          xpEarned?: number
        }
        Update: {
          balance?: number
          createdAt?: string
          currency?: string
          id?: string
          isActive?: boolean
          lastPlayed?: string | null
          phpId?: number | null
          shopId?: string
          updatedAt?: string | null
          userId?: string
          xpEarned?: number
        }
        Relationships: [
          {
            foreignKeyName: 'profiles_shopId_fkey'
            columns: ['shopId']
            isOneToOne: false
            referencedRelation: 'operators'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'profiles_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      rainbets: {
        Row: {
          betAmount: number
          id: string
          odds: number
          outcome: string | null
          rainHistoryId: string
          settledAt: string | null
          userId: string
        }
        Insert: {
          betAmount: number
          id: string
          odds: number
          outcome?: string | null
          rainHistoryId: string
          settledAt?: string | null
          userId: string
        }
        Update: {
          betAmount?: number
          id?: string
          odds?: number
          outcome?: string | null
          rainHistoryId?: string
          settledAt?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'rainbets_rainHistoryId_fkey'
            columns: ['rainHistoryId']
            isOneToOne: false
            referencedRelation: 'rainhistories'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'rainbets_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      rainhistories: {
        Row: {
          amount: number
          createdAt: string
          id: string
          rainType: string
          userId: string
        }
        Insert: {
          amount: number
          createdAt?: string
          id: string
          rainType: string
          userId: string
        }
        Update: {
          amount?: number
          createdAt?: string
          id?: string
          rainType?: string
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'rainhistories_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      raintips: {
        Row: {
          id: string
          rainHistoryId: string
          tipAmount: number
          tippedAt: string
          userId: string
        }
        Insert: {
          id: string
          rainHistoryId: string
          tipAmount: number
          tippedAt?: string
          userId: string
        }
        Update: {
          id?: string
          rainHistoryId?: string
          tipAmount?: number
          tippedAt?: string
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'raintips_rainHistoryId_fkey'
            columns: ['rainHistoryId']
            isOneToOne: false
            referencedRelation: 'rainhistories'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'raintips_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      rainwinners: {
        Row: {
          id: string
          rainHistoryId: string
          userId: string
          wonAmount: number
          wonAt: string
        }
        Insert: {
          id: string
          rainHistoryId: string
          userId: string
          wonAmount: number
          wonAt?: string
        }
        Update: {
          id?: string
          rainHistoryId?: string
          userId?: string
          wonAmount?: number
          wonAt?: string
        }
        Relationships: [
          {
            foreignKeyName: 'rainwinners_rainHistoryId_fkey'
            columns: ['rainHistoryId']
            isOneToOne: false
            referencedRelation: 'rainhistories'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'rainwinners_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      tournamententries: {
        Row: {
          id: string
          joinedAt: string
          profileId: string
          score: number
          tournamentId: string
          userId: string
          wagered: number
          won: number
        }
        Insert: {
          id: string
          joinedAt?: string
          profileId: string
          score?: number
          tournamentId: string
          userId: string
          wagered?: number
          won?: number
        }
        Update: {
          id?: string
          joinedAt?: string
          profileId?: string
          score?: number
          tournamentId?: string
          userId?: string
          wagered?: number
          won?: number
        }
        Relationships: [
          {
            foreignKeyName: 'tournamententries_profileId_fkey'
            columns: ['profileId']
            isOneToOne: false
            referencedRelation: 'profiles'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'tournamententries_tournamentId_fkey'
            columns: ['tournamentId']
            isOneToOne: false
            referencedRelation: 'tournaments'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'tournamententries_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      tournamentgames: {
        Row: {
          gameId: string
          id: string
          multiplier: number
          tournamentId: string
        }
        Insert: {
          gameId: string
          id: string
          multiplier?: number
          tournamentId: string
        }
        Update: {
          gameId?: string
          id?: string
          multiplier?: number
          tournamentId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'tournamentgames_gameId_fkey'
            columns: ['gameId']
            isOneToOne: false
            referencedRelation: 'games'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'tournamentgames_tournamentId_fkey'
            columns: ['tournamentId']
            isOneToOne: false
            referencedRelation: 'tournaments'
            referencedColumns: ['id']
          },
        ]
      }
      tournaments: {
        Row: {
          createdAt: string
          description: string | null
          endTime: string
          entryFee: number | null
          id: string
          isActive: boolean
          leaderboard: Json | null
          name: string
          operatorId: string
          prizePool: number
          startTime: string
          updatedAt: string | null
        }
        Insert: {
          createdAt?: string
          description?: string | null
          endTime: string
          entryFee?: number | null
          id: string
          isActive?: boolean
          leaderboard?: Json | null
          name: string
          operatorId: string
          prizePool?: number
          startTime: string
          updatedAt?: string | null
        }
        Update: {
          createdAt?: string
          description?: string | null
          endTime?: string
          entryFee?: number | null
          id?: string
          isActive?: boolean
          leaderboard?: Json | null
          name?: string
          operatorId?: string
          prizePool?: number
          startTime?: string
          updatedAt?: string | null
        }
        Relationships: [
          {
            foreignKeyName: 'tournaments_operatorId_fkey'
            columns: ['operatorId']
            isOneToOne: false
            referencedRelation: 'operators'
            referencedColumns: ['id']
          },
        ]
      }
      transactions: {
        Row: {
          amount: number
          amountCredits: number
          buyerCashtag: string | null
          buyerUserId: string | null
          cashierAvatar: string | null
          cashierId: string | null
          cashiername: string | null
          cashtag: string | null
          createdAt: string
          gameSessionId: string | null
          id: string
          isRealMoney: boolean
          metadata: Json | null
          paymentDetails: Json | null
          paymentMethod: string | null
          processedAt: string | null
          productid: string | null
          profileId: string | null
          reference: string | null
          status: Database['public']['Enums']['TransactionStatus']
          type: Database['public']['Enums']['TransactionType']
          username: string | null
          vipInfoId: string | null
        }
        Insert: {
          amount?: number
          amountCredits?: number
          buyerCashtag?: string | null
          buyerUserId?: string | null
          cashierAvatar?: string | null
          cashierId?: string | null
          cashiername?: string | null
          cashtag?: string | null
          createdAt?: string
          gameSessionId?: string | null
          id: string
          isRealMoney?: boolean
          metadata?: Json | null
          paymentDetails?: Json | null
          paymentMethod?: string | null
          processedAt?: string | null
          productid?: string | null
          profileId?: string | null
          reference?: string | null
          status?: Database['public']['Enums']['TransactionStatus']
          type?: Database['public']['Enums']['TransactionType']
          username?: string | null
          vipInfoId?: string | null
        }
        Update: {
          amount?: number
          amountCredits?: number
          buyerCashtag?: string | null
          buyerUserId?: string | null
          cashierAvatar?: string | null
          cashierId?: string | null
          cashiername?: string | null
          cashtag?: string | null
          createdAt?: string
          gameSessionId?: string | null
          id?: string
          isRealMoney?: boolean
          metadata?: Json | null
          paymentDetails?: Json | null
          paymentMethod?: string | null
          processedAt?: string | null
          productid?: string | null
          profileId?: string | null
          reference?: string | null
          status?: Database['public']['Enums']['TransactionStatus']
          type?: Database['public']['Enums']['TransactionType']
          username?: string | null
          vipInfoId?: string | null
        }
        Relationships: [
          {
            foreignKeyName: 'transactions_gameSessionId_fkey'
            columns: ['gameSessionId']
            isOneToOne: false
            referencedRelation: 'gamesessions'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'transactions_productid_fkey'
            columns: ['productid']
            isOneToOne: false
            referencedRelation: 'products'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'transactions_profileId_fkey'
            columns: ['profileId']
            isOneToOne: false
            referencedRelation: 'profiles'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'transactions_vipInfoId_fkey'
            columns: ['vipInfoId']
            isOneToOne: false
            referencedRelation: 'vip_infos'
            referencedColumns: ['id']
          },
        ]
      }
      twoFactors: {
        Row: {
          backupCodes: string
          id: string
          secret: string
          userId: string
        }
        Insert: {
          backupCodes: string
          id: string
          secret: string
          userId: string
        }
        Update: {
          backupCodes?: string
          id?: string
          secret?: string
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'twoFactors_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      user: {
        Row: {
          accessToken: string | null
          active: boolean
          activeProfileId: string | null
          avatar: string | null
          balance: number
          banExpires: string | null
          banned: boolean | null
          banReason: string | null
          cashtag: string | null
          createdAt: string
          displayUsername: string
          email: string
          emailVerified: boolean | null
          gender: Database['public']['Enums']['Gender'] | null
          id: string
          image: string | null
          isOnline: boolean | null
          isVerified: boolean
          lastDailySpin: string | null
          lastLogin: string | null
          name: string | null
          passwordHash: string | null
          phpId: number | null
          role: string | null
          sbId: string | null
          status: Database['public']['Enums']['UserStatus'] | null
          totalXp: number
          twoFactorEnabled: boolean | null
          updatedAt: string | null
          username: string
          verificationToken: string | null
          vipInfoId: string | null
        }
        Insert: {
          accessToken?: string | null
          active?: boolean
          activeProfileId?: string | null
          avatar?: string | null
          balance?: number
          banExpires?: string | null
          banned?: boolean | null
          banReason?: string | null
          cashtag?: string | null
          createdAt?: string
          displayUsername?: string
          email: string
          emailVerified?: boolean | null
          gender?: Database['public']['Enums']['Gender'] | null
          id: string
          image?: string | null
          isOnline?: boolean | null
          isVerified?: boolean
          lastDailySpin?: string | null
          lastLogin?: string | null
          name?: string | null
          passwordHash?: string | null
          phpId?: number | null
          role?: string | null
          sbId?: string | null
          status?: Database['public']['Enums']['UserStatus'] | null
          totalXp?: number
          twoFactorEnabled?: boolean | null
          updatedAt?: string | null
          username: string
          verificationToken?: string | null
          vipInfoId?: string | null
        }
        Update: {
          accessToken?: string | null
          active?: boolean
          activeProfileId?: string | null
          avatar?: string | null
          balance?: number
          banExpires?: string | null
          banned?: boolean | null
          banReason?: string | null
          cashtag?: string | null
          createdAt?: string
          displayUsername?: string
          email?: string
          emailVerified?: boolean | null
          gender?: Database['public']['Enums']['Gender'] | null
          id?: string
          image?: string | null
          isOnline?: boolean | null
          isVerified?: boolean
          lastDailySpin?: string | null
          lastLogin?: string | null
          name?: string | null
          passwordHash?: string | null
          phpId?: number | null
          role?: string | null
          sbId?: string | null
          status?: Database['public']['Enums']['UserStatus'] | null
          totalXp?: number
          twoFactorEnabled?: boolean | null
          updatedAt?: string | null
          username?: string
          verificationToken?: string | null
          vipInfoId?: string | null
        }
        Relationships: []
      }
      userachievements: {
        Row: {
          achievementId: string
          createdAt: string
          id: string
          isUnlocked: boolean
          progress: number
          unlockedAt: string | null
          updatedAt: string | null
          userId: string
        }
        Insert: {
          achievementId: string
          createdAt?: string
          id: string
          isUnlocked?: boolean
          progress?: number
          unlockedAt?: string | null
          updatedAt?: string | null
          userId: string
        }
        Update: {
          achievementId?: string
          createdAt?: string
          id?: string
          isUnlocked?: boolean
          progress?: number
          unlockedAt?: string | null
          updatedAt?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: 'userachievements_achievementId_fkey'
            columns: ['achievementId']
            isOneToOne: false
            referencedRelation: 'achievement'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'userachievements_userId_fkey'
            columns: ['userId']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
      verifications: {
        Row: {
          createdAt: string | null
          expiresAt: string
          id: string
          identifier: string
          updatedAt: string | null
          value: string
        }
        Insert: {
          createdAt?: string | null
          expiresAt: string
          id: string
          identifier: string
          updatedAt?: string | null
          value: string
        }
        Update: {
          createdAt?: string | null
          expiresAt?: string
          id?: string
          identifier?: string
          updatedAt?: string | null
          value?: string
        }
        Relationships: []
      }
      vip_infos: {
        Row: {
          bet_award_switch: boolean
          bet_exp: number
          can_receive_bet_award: boolean
          can_receive_day_award: boolean
          can_receive_level_award: boolean
          can_receive_month_award: boolean
          can_receive_rank_award: boolean
          can_receive_signin_award: boolean
          can_receive_week_award: boolean
          can_receive_withdrawal_award: boolean
          cycle_award_switch: boolean
          deposit_exp: number
          exp_switch_type: number | null
          free_spin_times: number | null
          history_cash_back: number | null
          icon: string | null
          id: string
          is_protection: boolean
          level: number
          level_award_switch: boolean
          level_bet_exp: string | null
          level_deposit_exp: string | null
          main_currency: string | null
          month_gift: number | null
          now_bet_exp: string | null
          now_cash_back: number | null
          now_deposit_exp: string | null
          operatorId: string | null
          protection_bet_amount: string | null
          protection_bet_exp: string | null
          protection_days: number | null
          protection_deposit_amount: string | null
          protection_deposit_exp: string | null
          protection_switch: number | null
          rank_bet_exp: number
          rank_deposit_exp: number
          rank_name: string | null
          signin_award_switch: boolean
          telegram: string | null
          unprotection_bet_amount: string | null
          unprotection_bet_exp: string | null
          unprotection_days: number | null
          unprotection_deposit_amount: string | null
          unprotection_deposit_exp: string | null
          unprotection_switch: number | null
          upgrade_gift: number | null
          userid: string | null
          week_gift: number | null
          withdrawal_award_switch: boolean
          yesterday_cash_back: number | null
        }
        Insert: {
          bet_award_switch?: boolean
          bet_exp?: number
          can_receive_bet_award?: boolean
          can_receive_day_award?: boolean
          can_receive_level_award?: boolean
          can_receive_month_award?: boolean
          can_receive_rank_award?: boolean
          can_receive_signin_award?: boolean
          can_receive_week_award?: boolean
          can_receive_withdrawal_award?: boolean
          cycle_award_switch?: boolean
          deposit_exp?: number
          exp_switch_type?: number | null
          free_spin_times?: number | null
          history_cash_back?: number | null
          icon?: string | null
          id: string
          is_protection?: boolean
          level?: number
          level_award_switch?: boolean
          level_bet_exp?: string | null
          level_deposit_exp?: string | null
          main_currency?: string | null
          month_gift?: number | null
          now_bet_exp?: string | null
          now_cash_back?: number | null
          now_deposit_exp?: string | null
          operatorId?: string | null
          protection_bet_amount?: string | null
          protection_bet_exp?: string | null
          protection_days?: number | null
          protection_deposit_amount?: string | null
          protection_deposit_exp?: string | null
          protection_switch?: number | null
          rank_bet_exp?: number
          rank_deposit_exp?: number
          rank_name?: string | null
          signin_award_switch?: boolean
          telegram?: string | null
          unprotection_bet_amount?: string | null
          unprotection_bet_exp?: string | null
          unprotection_days?: number | null
          unprotection_deposit_amount?: string | null
          unprotection_deposit_exp?: string | null
          unprotection_switch?: number | null
          upgrade_gift?: number | null
          userid?: string | null
          week_gift?: number | null
          withdrawal_award_switch?: boolean
          yesterday_cash_back?: number | null
        }
        Update: {
          bet_award_switch?: boolean
          bet_exp?: number
          can_receive_bet_award?: boolean
          can_receive_day_award?: boolean
          can_receive_level_award?: boolean
          can_receive_month_award?: boolean
          can_receive_rank_award?: boolean
          can_receive_signin_award?: boolean
          can_receive_week_award?: boolean
          can_receive_withdrawal_award?: boolean
          cycle_award_switch?: boolean
          deposit_exp?: number
          exp_switch_type?: number | null
          free_spin_times?: number | null
          history_cash_back?: number | null
          icon?: string | null
          id?: string
          is_protection?: boolean
          level?: number
          level_award_switch?: boolean
          level_bet_exp?: string | null
          level_deposit_exp?: string | null
          main_currency?: string | null
          month_gift?: number | null
          now_bet_exp?: string | null
          now_cash_back?: number | null
          now_deposit_exp?: string | null
          operatorId?: string | null
          protection_bet_amount?: string | null
          protection_bet_exp?: string | null
          protection_days?: number | null
          protection_deposit_amount?: string | null
          protection_deposit_exp?: string | null
          protection_switch?: number | null
          rank_bet_exp?: number
          rank_deposit_exp?: number
          rank_name?: string | null
          signin_award_switch?: boolean
          telegram?: string | null
          unprotection_bet_amount?: string | null
          unprotection_bet_exp?: string | null
          unprotection_days?: number | null
          unprotection_deposit_amount?: string | null
          unprotection_deposit_exp?: string | null
          unprotection_switch?: number | null
          upgrade_gift?: number | null
          userid?: string | null
          week_gift?: number | null
          withdrawal_award_switch?: boolean
          yesterday_cash_back?: number | null
        }
        Relationships: [
          {
            foreignKeyName: 'vip_infos_operatorId_fkey'
            columns: ['operatorId']
            isOneToOne: false
            referencedRelation: 'operators'
            referencedColumns: ['id']
          },
          {
            foreignKeyName: 'vip_infos_userid_fkey'
            columns: ['userid']
            isOneToOne: false
            referencedRelation: 'user'
            referencedColumns: ['id']
          },
        ]
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      arcade_increment_crystals: {
        Args: { row_id: number; val: number }
        Returns: undefined
      }
      check_min_rights: {
        Args:
          | {
              min_right: Database['public']['Enums']['user_min_right']
              org_id: string
              app_id: string
              channel_id: number
            }
          | {
              min_right: Database['public']['Enums']['user_min_right']
              user_id: string
              org_id: string
              app_id: string
              channel_id: number
            }
        Returns: boolean
      }
      convert_bytes_to_gb: {
        Args: { byt: number }
        Returns: number
      }
      convert_bytes_to_mb: {
        Args: { byt: number }
        Returns: number
      }
      convert_gb_to_bytes: {
        Args: { gb: number }
        Returns: number
      }
      convert_mb_to_bytes: {
        Args: { gb: number }
        Returns: number
      }
      convert_number_to_percent: {
        Args: { val: number; max_val: number }
        Returns: number
      }
      count_all_apps: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      count_all_need_upgrade: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      count_all_onboarded: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      count_all_paying: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      count_all_plans: {
        Args: Record<PropertyKey, never>
        Returns: {
          product_id: string
          count: number
        }[]
      }
      count_all_trial: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      count_all_updates: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      ddlx_get_dependants: {
        Args: { '': unknown }
        Returns: Record<string, unknown>[]
      }
      delete_user: {
        Args: Record<PropertyKey, never>
        Returns: undefined
      }
      exist_app_v2: {
        Args: { appid: string }
        Returns: boolean
      }
      exist_app_versions: {
        Args: { appid: string; name_version: string; apikey: string }
        Returns: boolean
      }
      exist_user: {
        Args: { e_mail: string }
        Returns: string
      }
      find_best_plan_v3: {
        Args: { mau: number; bandwidth: number; storage: number }
        Returns: string
      }
      find_fit_plan_v3: {
        Args: { mau: number; bandwidth: number; storage: number }
        Returns: {
          name: string
        }[]
      }
      generate_inbox: {
        Args: { size: number }
        Returns: string
      }
      get_apikey: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      get_app_versions: {
        Args: { appid: string; name_version: string; apikey: string }
        Returns: number
      }
      get_current_plan_max: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: string
      }
      get_current_plan_name: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: string
      }
      get_cycle_info: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: {
          subscription_anchor_start: string
          subscription_anchor_end: string
        }[]
      }
      get_db_url: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      get_devices_version: {
        Args: { app_id: string; version_id: number }
        Returns: number
      }
      get_external_function_url: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      get_max_plan: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: {
          mau: number
          storage: number
          bandwidth: number
        }[]
      }
      get_metered_usage: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: number
      }
      get_plan_usage_percent: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: number
      }
      get_total_app_storage_size: {
        Args: { app_id: string } | { userid: string; app_id: string }
        Returns: number
      }
      get_total_stats_v2: {
        Args: { dateid: string } | { userid: string; dateid: string }
        Returns: {
          mau: number
          bandwidth: number
          storage: number
        }[]
      }
      get_total_stats_v3: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: {
          mau: number
          bandwidth: number
          storage: number
        }[]
      }
      get_total_storage_size: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: number
      }
      get_total_storage_size_org: {
        Args: { org_id: string }
        Returns: number
      }
      get_usage_mode_and_last_saved: {
        Args: Record<PropertyKey, never>
        Returns: {
          usage_mode: Database['public']['Enums']['usage_mode']
          last_saved: string
        }[]
      }
      get_user_id: {
        Args: { apikey: string }
        Returns: string
      }
      get_weekly_stats: {
        Args: { app_id: string }
        Returns: {
          all_updates: number
          failed_updates: number
          open_app: number
        }[]
      }
      handle_wheel_of_fortune_spin: {
        Args: { row_id: string; crystals_to_add: number }
        Returns: undefined
      }
      has_min_right: {
        Args: {
          _userid: string
          _orgid: string
          _right: Database['public']['Enums']['user_min_right']
          _appid?: string
          _channelid?: number
        }
        Returns: boolean
      }
      http_post_helper: {
        Args: { function_name: string; function_type: string; body: Json }
        Returns: undefined
      }
      increment_coins: {
        Args: { row_id: string; val: number }
        Returns: undefined
      }
      increment_coins_from_arcade: {
        Args: { row_id: number; val: number }
        Returns: undefined
      }
      increment_crystals: {
        Args: { row_id: number; val: number }
        Returns: undefined
      }
      increment_crystals_from_arcade: {
        Args: { row_id: number; val: number }
        Returns: undefined
      }
      increment_store: {
        Args: { app_id: string; updates: number }
        Returns: undefined
      }
      is_admin: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_allowed_action: {
        Args: { apikey: string } | { apikey: string; appid: string }
        Returns: boolean
      }
      is_allowed_action_user: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_allowed_capgkey: {
        Args:
          | {
              apikey: string
              keymode: Database['public']['Enums']['key_mode'][]
            }
          | {
              apikey: string
              keymode: Database['public']['Enums']['key_mode'][]
              app_id: string
            }
        Returns: boolean
      }
      is_app_owner: {
        Args:
          | { apikey: string; appid: string }
          | { appid: string }
          | { userid: string; appid: string }
        Returns: boolean
      }
      is_app_shared: {
        Args: { appid: string } | { userid: string; appid: string }
        Returns: boolean
      }
      is_canceled: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_free_usage: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_good_plan_v3: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_good_plan_v4: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_in_channel: {
        Args: { userid: string } | { userid: string; ownerid: string }
        Returns: boolean
      }
      is_not_deleted: {
        Args: { email_check: string }
        Returns: boolean
      }
      is_onboarded: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_onboarding_needed: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_paying: {
        Args: Record<PropertyKey, never>
        Returns: boolean
      }
      is_trial: {
        Args: { userid: string }
        Returns: number
      }
      is_version_shared: {
        Args: { userid: string; versionid: number }
        Returns: boolean
      }
      nolimit_decrement_crystals: {
        Args: { row_id: string; val: number }
        Returns: Json
      }
      nolimit_increment_coins: {
        Args: { row_id: string; val: number }
        Returns: Json
      }
      one_month_ahead: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      remove_enum_value: {
        Args: { enum_type: unknown; enum_value: string }
        Returns: undefined
      }
    }
    Enums: {
      ChatChannel: 'LOBBY' | 'GAME' | 'TOURNAMENT' | 'PRIVATE'
      FriendshipStatus: 'PENDING' | 'ACCEPTED' | 'BLOCKED'
      GameCategory: 'TABLE' | 'FISH' | 'POKER' | 'SLOTS' | 'OTHER'
      Gender: 'BOY' | 'GIRL' | 'ALIEN' | 'UNSURE' | 'ROBOT' | 'COMPLICATED'
      key_mode: 'read' | 'write' | 'all' | 'upload'
      message_state: 'read' | 'unread' | 'group'
      NotificationType:
        | 'SYSTEM'
        | 'FRIEND_REQUEST'
        | 'ACHIEVEMENT'
        | 'BALANCE_UPDATE'
        | 'PROMOTIONAL'
        | 'TOURNAMENT'
      platform_os: 'ios' | 'android'
      product_cost: 'D500' | 'D1000' | 'D2000' | 'D5000' | 'D10000'
      request_status: 'PENDING' | 'SUCCESS' | 'ERROR'
      stripe_status:
        | 'created'
        | 'succeeded'
        | 'updated'
        | 'failed'
        | 'deleted'
        | 'canceled'
      transaction_status: 'PENDING' | 'COMPLETED' | 'DENIED'
      TransactionStatus:
        | 'PENDING'
        | 'COMPLETED'
        | 'FAILED'
        | 'CANCELLED'
        | 'REFUNDED'
        | 'EXPIRED'
        | 'REJECTED'
      TransactionType:
        | 'DEPOSIT'
        | 'WITHDRAWAL'
        | 'BET'
        | 'WIN'
        | 'BONUS'
        | 'DONATION'
        | 'ADJUSTMENT'
        | 'TOURNAMENT_BUYIN'
        | 'TOURNAMENT_PRIZE'
      usage_mode: 'last_saved' | 'min5' | '"day"' | '"cycle"'
      user_min_right: 'read' | 'upload' | 'write' | 'admin'
      user_role: 'read' | 'upload' | 'write' | 'admin'
      user_status: 'ONLINE' | 'OFFLINE' | 'BUSY' | 'AWAY'
      UserStatus: 'ACTIVE' | 'INACTIVE' | 'ONLINE' | 'OFFLINE'
      volatility: 'HIGH' | 'MEDIUM' | 'LOW'
    }
    CompositeTypes: {
      stats_table: {
        mau: number | null
        bandwidth: number | null
        storage: number | null
      }
    }
  }
}
type DefaultSchema = Database[Extract<keyof Database, 'public'>]
export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema['Tables'] & DefaultSchema['Views'])
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof (Database[DefaultSchemaTableNameOrOptions['schema']]['Tables'] &
        Database[DefaultSchemaTableNameOrOptions['schema']]['Views'])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? (Database[DefaultSchemaTableNameOrOptions['schema']]['Tables'] &
      Database[DefaultSchemaTableNameOrOptions['schema']]['Views'])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema['Tables'] &
        DefaultSchema['Views'])
    ? (DefaultSchema['Tables'] &
        DefaultSchema['Views'])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never
export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema['Tables']
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions['schema']]['Tables']
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions['schema']]['Tables'][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema['Tables']
    ? DefaultSchema['Tables'][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never
export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema['Tables']
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions['schema']]['Tables']
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions['schema']]['Tables'][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema['Tables']
    ? DefaultSchema['Tables'][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never
export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema['Enums']
    | { schema: keyof Database },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaEnumNameOrOptions['schema']]['Enums']
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaEnumNameOrOptions['schema']]['Enums'][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema['Enums']
    ? DefaultSchema['Enums'][DefaultSchemaEnumNameOrOptions]
    : never
export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema['CompositeTypes']
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes']
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes'][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema['CompositeTypes']
    ? DefaultSchema['CompositeTypes'][PublicCompositeTypeNameOrOptions]
    : never
</file>

<file path="src/types/index.ts">

</file>

<file path="src/utils/cache-key.ts">
export class CacheKey
</file>

<file path="src/utils/cookies.ts">
import { CacheKey } from '@/utils/cache-key'
import Cookies from 'js-cookie'
export function getToken()
export function setToken(token: string)
export function removeToken()
</file>

<file path="src/utils/local-storage.ts">
import { CacheKey } from '@@/constants/cache-key'
export function getIsDark()
export function setIsDark(isDark: boolean)
</file>

<file path="src/utils/Network.ts">
import { EXITTYPE, NetworkData, SENDTYPE } from './NetworkData'
import axios, { type AxiosInstance, type AxiosRequestConfig } from 'axios'
import { get } from 'lodash-es'
export interface netdata {
  key: string
  call: Function
  target: any
}
export class Network
⋮----
constructor()
public static getInstance()
public async sendMsg(
    route: string,
    msg: any,
    next: Function,
    type: SENDTYPE = SENDTYPE.SOCKET,
    requestType: SENDTYPE = SENDTYPE.POST,
)
private async POST(route: string, data: any, next: Function)
private GET(route: string, data: any, next: Function)
public socketReq(route: string, msg: any, callBack?: Function)
public connect(route: string)
private handleOpen()
private handleMessage(event: MessageEvent)
private handleError(event: Event)
private handleClose(event: CloseEvent)
private connectConnector(event_type: string, event: MessageEvent | CloseEvent | Event | any)
private kicked()
private onUnsolicited()
public disconnect()
public getState()
/**
   * Clear all contracting agreements
   *
   */
public destroy()
/**
   * Data Collation
   * @param msg
   * @param type
   * @param version
   */
private msgParsing(route: string, msg: any, type: SENDTYPE)
/**
   * 处理网络延迟
   * @param route
   * @param blOpen
   * @param type
   * @returns
   */
public wait(route: string, blOpen: boolean, type: SENDTYPE = SENDTYPE.SOCKET)
⋮----
// TODO
⋮----
/**
   * 清理网络延迟
   */
private netWorkClose()
public allClearNetwork()
/**
   * create request instance
   */
private createService()
⋮----
// request interception
⋮----
// Failed to send
⋮----
// Response interception (can be adjusted according to specific business)
⋮----
// apiData is the data returned by the API
⋮----
// This Code is the business Code agreed with the backend
⋮----
// console.log(apiData)
// If there is no Code, it means that this is not an API developed by the project backend
⋮----
private createRequestFunction(
    service: AxiosInstance,
    timeout: number = this.netCfg.getTimeout(),
    token: string | undefined = this.netCfg.getToken(),
)
</file>

<file path="src/utils/NetworkData.ts">
import { CacheKey } from "@/utils/cache-key"
import Cookies from "js-cookie"
export enum SENDTYPE {
  NONE,
  HTTP,
  SOCKET,
  UNSOLICITED,
  GET,
  POST
}
export enum EXITTYPE {
  NONE,
  USER_EXIT,
  TOKEN_ERROR,
  MAINTAIN,
  ACC_REPEAT
}
export class NetworkData
⋮----
private timeout: number = 10000 //Normal packet sending delay of 10000 milliseconds
// Check for ignorable error codes
⋮----
constructor()
⋮----
// this.resetData()
⋮----
public static getInstance(): NetworkData
/**
   * Reset data
   */
public resetData()
/**
   * Set value token
   * @param token
   */
public setToken(token: string): void
/** Get current token */
public getToken(): string | undefined
/**
   * Set the value of http outgoing packet address
   * @param ip
   * @param host
   * @param path
   */
public setWebHost(ip: string, host?: number, path?: string): void
public getWebHost(): string
public setWebSocker(host: string, port?: number, path?: string): void
public getWebSocker()
public getTimeout(): number
public getTempNoLog()
public checkNeglectCode(code: number)
</file>

<file path="src/views/AboutView.vue">
<template>
  <div class="about">
    <h1>About</h1>
    <p>About page</p>
  </div>
</template>
</file>

<file path="src/views/ChatView.vue">
<template>
  <div class="about">
    <h1>About</h1>
    <p>About page</p>
  </div>
</template>
</file>

<file path="src/views/HomeView.vue">
<template>
  <div class="home">
    <h1>Home</h1>
    <p>Home page</p>
  </div>
</template>
</file>

<file path="src/views/LoginView.vue">
<script lang="ts" setup>
  import { useLoading } from '@/composables/useLoading'
  import { useSupabaseAuth } from '@/composables/useSupabaseAuth'
  import { useAppBarStore } from '@/stores/appBar'
  import { useAuthStore } from '@/stores/auth'
  import { useCurrencyStore } from '@/stores/currency'
  import { useGameStore } from '@/stores/game'
  import { useNotificationStore } from '@/stores/notifications'
  import { useRefferalStore } from '@/stores/refferal'
  import { useSocketStore } from '@/stores/socket'
  import { useUserStore } from '@/stores/user'
  import { useVipStore } from '@/stores/vip'
  import { supabase } from '@/supabase'
  import { loadingFadeOut } from 'virtual:app-loading'
  const signInForm = ref({ email: '', password: '' })
  const signUpForm = ref({ email: '', password: '', username: '' })
  const {
    // isAuthenticated,
    isLoading,
    authError,
    currentUser,
    currentProfile,
    signInWithPassword,
    signUpNewUser,
    signOut,
    initialAuthCheckComplete,
  } = useSupabaseAuth()
  const handleSignIn = async () => {
    await signInWithPassword({
      email: formData.email,
      password: formData.password,
    })
    if (!authError.value) {
      signInForm.value = { email: '', password: '' }
    }
  }
  const handleSignUp = async () => {
    await signUpNewUser({
      email: formData.email,
      password: formData.password,
      options: {
        data: {
          username: signUpForm.value.username,
        },
      },
    })
    if (!authError.value) {
      signUpForm.value = { email: '', password: '', username: '' }
    }
  }
  const handleSignOut = async () => {
    await signOut()
  }
  const { withLoading, stopLoading } = useLoading()
  let x = 0
  // posthog.capture('Login Page Viewed', { page: window.location.pathname })
  const authStore = useAuthStore()
  async function handleSignInWithGoogle(response) {
    const { data, error } = await supabase.auth.signInWithIdToken({
      provider: 'google',
      token: response.credential,
    })
  }
  const {
    dispatchSignIn,
    dispatchSignUp,
    setNickNameDialogVisible,
    dispatchUserProfile,
    setAuthModalType,
    setAuthDialogVisible,
    getSuccess,
    isAuthenticated,
  } = authStore
  const userStore = useUserStore()
  const notificationStore = useNotificationStore()
  const appBarStore = useAppBarStore()
  const refferalStore = useRefferalStore()
  const socketStore = useSocketStore()
  const currencyStore = useCurrencyStore()
  const vipStore = useVipStore()
  const gameStore = useGameStore()
  const { dispatchUserBalance } = userStore
  const { dispatchVipInfo, dispatchVipLevels, dispatchVipLevelAward } = vipStore
  const { setOverlayScrimShow } = appBarStore
  const { setRefferalDialogShow } = refferalStore
  const { dispatchSocketConnect } = socketStore
  const { dispatchGameSearch, dispatchGameBigWin } = gameStore
  const { dispatchCurrencyList } = currencyStore
  const success = computed(() => getSuccess)
  const formData = reactive({
    username: 'ash',
    email: 'ash@ash.com',
    password: 'asdfasdf',
    confirm: 'asdfasdf',
    faceIndex: 0,
    loginErr: '',
    passwErr: '',
    agentCode: '',
    promoCode: '',
  })
  const errMessage = ref()
  const currentPage = ref()
  const handleSignupFormSubmit = async () => {
    // isLoading.value = true
    const r = await withLoading(
      dispatchSignUp({
        username: formData.username,
        password: formData.password,
        referral_code: formData.promoCode,
        browser: '',
        device: '',
        model: '',
        brand: '',
        imei: '',
      }),
    )
    console.log(authStore.getSuccess)
    if (authStore.getSuccess) {
      await withLoading(dispatchUserProfile())
      await withLoading(dispatchUserBalance())
      await withLoading(dispatchSocketConnect())
      await withLoading(dispatchCurrencyList())
      await withLoading(dispatchGameSearch(''))
      setAuthDialogVisible(false)
      setNickNameDialogVisible(true)
      // const toast = useToast();
      notificationStore.addNotification('success', 'success')
      console.log(process.env.NODE_ENV)
      console.log(process.env.NODE_ENV)
      setTimeout(() => {
        console.log('asdfasdf')
      }, 3000)
    } else {
      console.log('wtf error')
      if (
        errMessage.value ==
        'The account you entered has been used by someone else, please input again'
      ) {
        currentPage.value = 'already regged'
      } else {
        notificationStore.addNotification('error', 'error')
      }
    }
  }
  const handleLoginFormSubmit = async () => {
    const r = await withLoading(
      dispatchSignIn({
        username: formData.username,
        password: formData.password,
      }),
    )
    console.log(r)
    console.log(success.value)
    console.log(r)
    if (r == true) {
      await withLoading(dispatchUserProfile())
      await withLoading(dispatchUserBalance())
      await withLoading(dispatchCurrencyList())
      await withLoading(dispatchVipInfo())
      await withLoading(dispatchVipLevels())
      await withLoading(dispatchVipLevelAward())
      await withLoading(dispatchGameSearch('?limit=200'))
      await withLoading(dispatchGameBigWin())
      setOverlayScrimShow(false)
      setRefferalDialogShow(true)
      if (authStore.userInfo == undefined) {
        throw new Error('User not found')
      }
      userStore.setCurrentUser(authStore.userInfo!)
      authStore.setIsAuthenticated(true)
      userStore.isAuthenticated = true
      setTimeout(() => {
        setAuthModalType('')
        setAuthDialogVisible(false)
      }, 100)
      // await dispatchSocketConnect()
      setTimeout(() => {
        // isLoading.value = false
        notificationStore.addNotification('success', 'success')
      }, 100)
    } else {
      notificationStore.addNotification('error', 'error')
    }
  }
  const { signInWithGoogleIdToken } = useSupabaseAuth()
  onMounted(() => {
    const script = document.createElement('script')
    script.src = 'https://accounts.google.com/gsi/client'
    script.onload = () => {
      console.log('External script loaded')
    }
    script.onerror = () => {
      console.error('Failed to load the script.')
    }
    document.head.appendChild(script)
    window.handleSignInWithGoogle = async (response: any) => {
      console.log('handleSignInWithGoogle called')
      handleSignInWithGoogle(response)
    }
    stopLoading()
    loadingFadeOut()
  })
</script>
<template>
  <div
    class="max-w-[520px] w-[100vw] mt-0 flex flex-col justify-center items-center"
    style="
      height: 100vh;
      width: 100vw;
      max-width: 520px;
      justify-content: center;
      /* background-image: url('/src/assets/login-bg.jpg'); */
      background-size: contain;
      background-repeat: no-repeat;
      background-color: #021130;
    "
  >
    <div
      class="wrapper color-white flex-col justify-center w-full mx-0 px-0"
      style="height: 100vh; width: 80vw; max-width: 520px; margin-auto"
    >
      <Logo class="mt-8" />
      <div
        id="g_id_onload"
        data-client_id="740187878164-qoahkvecq5tu5d8os02pomr7nifcgh8s.apps.googleusercontent.com"
        data-context="signin"
        data-ux_mode="popup"
        data-callback="handleSignInWithGoogle"
        data-auto_prompt="false"
      ></div>
      <div
        class="g_id_signin"
        data-type="standard"
        data-shape="rectangular"
        data-theme="outline"
        data-text="signin_with"
        data-size="large"
        data-logo_alignment="left"
      ></div>
      <div class="mt-52 flex" style="margin-top: 200px">
        <label class="switch">
          <input class="toggle" type="checkbox" />
          <span class="slider" />
          <span class="card-side" />
          <div class="flip-card__inner">
            <div class="flip-card__front">
              <div class="title">Log in</div>
              <div class="flip-card__form">
                <button class="flip-card__btn" @click="handleSignIn">
                  Lets go!
                </button>
              </div>
            </div>
            <div class="flip-card__back">
              <div class="title">Sign up</div>
              <div action="" class="flip-card__form">
                <form>
                  <input
                    v-model="formData.username"
                    type="name"
                    placeholder="Name"
                    class="flip-card__input"
                  />
                  <input
                    v-model="formData.password"
                    type="password"
                    placeholder="Password"
                    autocomplete="new-password"
                    name="password"
                    class="flip-card__input"
                  />
                  <input
                    v-model="formData.confirm"
                    type="password"
                    placeholder="Confirm"
                    autocomplete="new-password"
                    name="confirm"
                    class="flip-card__input"
                  />
                  <button class="flip-card__btn" @click="handleSignUp">
                    Confirm!
                  </button>
                </form>
              </div>
            </div>
          </div>
        </label>
      </div>
    </div>
  </div>
</template>
<style scoped>
  .g_id_signin {
    color: white;
  }
  .wrapper {
    position: relative;
    --input-focus: #2d8cf0;
    --font-color: #fefefe;
    --font-color-sub: #7e7e7e;
    --bg-color: #111;
    --bg-color-alt: #7e7e7e;
    --main-color: #b954f3;
    display: flex;
    flex-direction: column;
    justify-content: start;
    align-items: center;
  }
  .wrapper2 {
    position: relative;
    --input-focus: #2d8cf0;
    --font-color: #fefefe;
    --font-color-sub: #7e7e7e;
    --bg-color: #111;
    --bg-color-alt: #7e7e7e;
    --main-color: #b954f3;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .switch {
    transform: translateY(-200px);
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 30px;
    width: 50px;
    height: 20px;
  }
  .card-side::before {
    position: absolute;
    content: 'Log in';
    left: -70px;
    top: 0;
    width: 100px;
    text-decoration: underline;
    color: var(--font-color);
    font-weight: 600;
  }
  .card-side::after {
    position: absolute;
    content: 'Sign up';
    left: 70px;
    top: 0;
    width: 100px;
    text-decoration: none;
    color: var(--font-color);
    font-weight: 600;
  }
  .toggle {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .slider {
    box-sizing: border-box;
    border-radius: 5px;
    border: 2px solid var(--main-color);
    box-shadow: 4px 4px var(--main-color);
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--bg-color);
    transition: 0.3s;
  }
  .slider:before {
    box-sizing: border-box;
    position: absolute;
    content: '';
    height: 20px;
    width: 20px;
    border: 2px solid var(--main-color);
    border-radius: 5px;
    left: -2px;
    bottom: 2px;
    background-color: var(--bg-color);
    box-shadow: 0 3px 0 var(--main-color);
    transition: 0.3s;
  }
  .toggle:checked + .slider {
    background-color: var(--input-focus);
  }
  .toggle:checked + .slider:before {
    transform: translateX(30px);
  }
  .toggle:checked ~ .card-side:before {
    text-decoration: none;
  }
  .toggle:checked ~ .card-side:after {
    text-decoration: underline;
  }
  .flip-card__inner {
    width: 80vw;
    max-width: 420px;
    height: 350px;
    position: relative;
    background-color: transparent;
    perspective: 1000px;
    text-align: center;
    transition: transform 0.8s;
    transform-style: preserve-3d;
    margin-top: 16px;
  }
  .toggle:checked ~ .flip-card__inner {
    transform: rotateY(180deg);
  }
  .toggle:checked ~ .flip-card__front {
    box-shadow: none;
  }
  .flip-card__front,
  .flip-card__back {
    width: 80vw;
    max-width: 420px;
    padding-left: 10px;
    padding-right: 10px;
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: center;
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    background: var(--bg-color);
    gap: 20px;
    border-radius: 5px;
    border: 2px solid var(--main-color);
    box-shadow: 4px 4px var(--main-color);
  }
  .flip-card__back {
    width: 80vw;
    transform: rotateY(180deg);
  }
  .flip-card__form {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
  }
  .title {
    margin: 10px 0 10px 0;
    font-size: 25px;
    font-weight: 900;
    text-align: center;
    color: white;
  }
  .flip-card__input {
    width: 200px;
    height: 40px;
    border-radius: 5px;
    border: 2px solid var(--main-color);
    background-color: var(--bg-color);
    box-shadow: 4px 4px var(--main-color);
    font-size: 15px;
    font-weight: 600;
    color: var(--font-color);
    padding: 5px 10px;
    outline: none;
  }
  .flip-card__input::placeholder {
    color: var(--font-color-sub);
    opacity: 0.8;
  }
  .flip-card__input:focus {
    border: 2px solid var(--input-focus);
  }
  .flip-card__btn:active,
  .button-confirm:active {
    box-shadow: 0px 0px var(--main-color);
    transform: translate(3px, 3px);
  }
  .flip-card__btn {
    margin: 20px 0 20px 0;
    width: 120px;
    height: 40px;
    border-radius: 5px;
    border: 2px solid var(--main-color);
    background-color: var(--bg-color);
    box-shadow: 4px 4px var(--main-color);
    font-size: 17px;
    font-weight: 600;
    color: var(--font-color);
    cursor: pointer;
  }
</style>
</file>

<file path="src/App copy.vue">
<script setup lang="ts">
  import { onMounted } from 'vue'
  import LoginView from '@/views/LoginView.vue'
  import { useAuthStore } from './stores/auth'
  import { loadingFadeOut } from 'virtual:app-loading'
  import { useGlobalStore } from './stores/global'
  import { supabase } from './supabase'
  const globalStore = useGlobalStore()
  const { isLoading, stopLoading } = useLoading()
  const { isMobile } = useDisplay()
  const authStore = useAuthStore()
  console.log(authStore.userInfo)
  if (authStore.userInfo !== undefined) {
    watch(authStore.userInfo, (user) => {
      console.log('user', user)
      if (!user) return
    })
  }
  const appReady = ref(false)
  const user = supabase.auth.user()
  if (!user) {
    appReady.value = true
  }
  supabase.auth.onAuthStateChange((_, session: Session) => {
    authStore.setUserInfo(session.user)
    appReady.value = true
  })
  onMounted(async () => {
    var myHeaders = new Headers()
    const token = authStore.token
    if (token !== undefined) {
      myHeaders.append('Content-Type', 'application/json')
      myHeaders.append('Authorization', `Bearer ${token}`)
      var requestOptions = {
        headers: myHeaders,
      }
      const user = await fetch('/api/auth/me', requestOptions)
      const _code = await user.json()
      if (_code.code != 200) authStore.isAuthenticated = false
      stopLoading()
      console.log(isLoading.value)
      loadingFadeOut()
    }
  })
</script>
<template>
  <div class="onacona">
    <template v-if="authStore.isAuthenticated">
      <DesktopSection v-if="!isMobile">
        <RouterView />
      </DesktopSection>
      <MobileSection v-if="isMobile">
        <GlobalLoading v-if="globalStore.isLoading"></GlobalLoading>
        <RouterView v-else />
      </MobileSection>
    </template>
    <template v-else-if="!authStore.isAuthenticated">
      <LoginView />
    </template>
    <ShowToasts />
  </div>
</template>
⋮----
<template v-if="authStore.isAuthenticated">
      <DesktopSection v-if="!isMobile">
        <RouterView />
      </DesktopSection>
      <MobileSection v-if="isMobile">
        <GlobalLoading v-if="globalStore.isLoading"></GlobalLoading>
        <RouterView v-else />
      </MobileSection>
    </template>
<template v-else-if="!authStore.isAuthenticated">
      <LoginView />
    </template>
⋮----
<style scoped>
</style>
<template>
  <div id="app">
    <h1>Supabase Auth with Pinia</h1>
    <div v-if="!initialAuthCheckComplete && isLoading" class="loading-spinner">
      <p>Loading authentication status...</p>
      <div class="spinner"></div>
    </div>
    <div v-if="initialAuthCheckComplete">
      <div v-if="isAuthenticated && currentUser">
        <h2>Welcome, {{ currentUser.username || currentUser.email }}!</h2>
        <p>User ID: {{ currentUser.id }}</p>
        <p>Email: {{ currentUser.email }}</p>
        <div v-if="currentProfile">
          <h3>Profile:</h3>
          <p>
            Balance: {{ currentProfile.balance }} {{ currentProfile.currency }}
          </p>
          <p>XP: {{ currentProfile.xpEarned }}</p>
        </div>
        <div v-else-if="!isLoading">
          <p>No profile data found or still loading profile.</p>
        </div>
        <button @click="handleSignOut">Sign Out</button>
      </div>
      <div v-else-if="!isLoading">
        <h2>Login or Sign Up</h2>
        <form @submit.prevent="handleSignIn">
          <h3>Sign In</h3>
          <div>
            <label for="email-signin">Email:</label>
            <input
              id="email-signin"
              type="email"
              v-model="signInForm.email"
              required
            />
          </div>
          <div>
            <label for="password-signin">Password:</label>
            <input
              id="password-signin"
              type="password"
              v-model="signInForm.password"
              required
            />
          </div>
          <button type="submit" :disabled="isLoading">
            {{ isLoading ? 'Signing In...' : 'Sign In' }}
          </button>
        </form>
        <hr />
        <form @submit.prevent="handleSignUp">
          <h3>Sign Up</h3>
          <div>
            <label for="email-signup">Email:</label>
            <input
              id="email-signup"
              type="email"
              v-model="signUpForm.email"
              required
            />
          </div>
          <div>
            <label for="username-signup">Username:</label>
            <input
              id="username-signup"
              type="text"
              v-model="signUpForm.username"
              required
            />
          </div>
          <div>
            <label for="password-signup">Password:</label>
            <input
              id="password-signup"
              type="password"
              v-model="signUpForm.password"
              required
            />
          </div>
          <button type="submit" :disabled="isLoading">
            {{ isLoading ? 'Signing Up...' : 'Sign Up' }}
          </button>
        </form>
      </div>
      <div v-if="authError" class="error-message">
        <p>Error: {{ authError.message }}</p>
      </div>
      <div
        v-if="isLoading && !initialAuthCheckComplete"
        class="loading-message"
      >
        <p>Processing...</p>
      </div>
    </div>
  </div>
</template>
⋮----
<h2>Welcome, {{ currentUser.username || currentUser.email }}!</h2>
<p>User ID: {{ currentUser.id }}</p>
<p>Email: {{ currentUser.email }}</p>
⋮----
Balance: {{ currentProfile.balance }} {{ currentProfile.currency }}
⋮----
<p>XP: {{ currentProfile.xpEarned }}</p>
⋮----
{{ isLoading ? 'Signing In...' : 'Sign In' }}
⋮----
{{ isLoading ? 'Signing Up...' : 'Sign Up' }}
⋮----
<p>Error: {{ authError.message }}</p>
⋮----
<script setup lang="ts">
  import { ref, onMounted } from 'vue'
  import { useSupabaseAuth } from './composables/useSupabaseAuth'
  const {
    isAuthenticated,
    isLoading,
    authError,
    currentUser,
    currentProfile,
    signInWithPassword,
    signUpNewUser,
    signOut,
    initialAuthCheckComplete,
  } = useSupabaseAuth()
  const signInForm = ref({ email: '', password: '' })
  const signUpForm = ref({ email: '', password: '', username: '' })
  const handleSignIn = async () => {
    await signInWithPassword({
      email: signInForm.value.email,
      password: signInForm.value.password,
    })
    if (!authError.value) {
      signInForm.value = { email: '', password: '' }
    }
  }
  const handleSignUp = async () => {
    await signUpNewUser({
      email: signUpForm.value.email,
      password: signUpForm.value.password,
      options: {
        data: {
          username: signUpForm.value.username,
        },
      },
    })
    if (!authError.value) {
      signUpForm.value = { email: '', password: '', username: '' }
    }
  }
  const handleSignOut = async () => {
    await signOut()
  }
  onMounted(() => {
    console.log('App.vue mounted, useSupabaseAuth is active.')
  })
</script>
<style>
  #app {
    font-family: Avenir, Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-align: center;
    color: #2c3e50;
    margin-top: 60px;
    max-width: 500px;
    margin-left: auto;
    margin-right: auto;
    padding: 20px;
    border: 1px solid #ccc;
    border-radius: 8px;
  }
  form div {
    margin-bottom: 10px;
    text-align: left;
  }
  label {
    display: block;
    margin-bottom: 5px;
  }
  input[type='email'],
  input[type='password'],
  input[type='text'] {
    width: calc(100% - 22px);
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  button {
    background-color: #42b983;
    color: white;
    padding: 10px 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    margin-top: 10px;
  }
  button:disabled {
    background-color: #aaa;
  }
  button:hover:not(:disabled) {
    background-color: #36a476;
  }
  hr {
    margin: 20px 0;
  }
  .error-message {
    color: red;
    margin-top: 15px;
    padding: 10px;
    border: 1px solid red;
    border-radius: 4px;
    background-color: #ffe0e0;
  }
  .loading-message,
  .loading-spinner {
    margin-top: 20px;
    color: #555;
  }
  .spinner {
    border: 4px solid rgba(0, 0, 0, 0.1);
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border-left-color: #42b983;
    margin: 20px auto;
    animation: spin 1s ease infinite;
  }
  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
</style>
</file>

<file path="src/App.vue">
<template>
  <div id="app">
    <div v-if="!initialAuthCheckComplete && globalStore.isLoading">
      <GlobalLoading />
    </div>
    <div v-if="initialAuthCheckComplete">
      <div v-if="isAuthenticated && currentUser">
        <DesktopSection v-if="!isMobile">
          <RouterView />
        </DesktopSection>
        <MobileSection v-if="isMobile">
          <GlobalLoading v-if="globalStore.isLoading"></GlobalLoading>
          <RouterView v-else />
        </MobileSection>
      </div>
      <div v-else-if="!globalStore.isLoading">
        <LoginView />
      </div>
      <div v-if="authError" class="error-message">
        <p>Error: {{ authError.message }}</p>
      </div>
      <div
        v-if="globalStore.isLoading && !initialAuthCheckComplete"
        class="loading-message"
      >
        <p>Processing...</p>
      </div>
    </div>
  </div>
</template>
⋮----
<p>Error: {{ authError.message }}</p>
⋮----
<script setup lang="ts">
  import { ref, onMounted } from 'vue'
  import { useSupabaseAuth } from './composables/useSupabaseAuth'
  import { useGlobalStore } from './stores/global'
  import LoginView from './views/LoginView.vue'
  import { loadingFadeOut } from 'virtual:app-loading'
  const globalStore = useGlobalStore()
  const {
    isAuthenticated,
    authError,
    currentUser,
    subscribeGlobalAuth,
    initialAuthCheckComplete,
  } = useSupabaseAuth()
  const { isMobile } = useDisplay()
  const signInForm = ref({ email: '', password: '' })
  onMounted(() => {
    subscribeGlobalAuth()
    console.log('App.vue mounted, useSupabaseAuth is active.')
    loadingFadeOut()
  })
</script>
<style></style>
</file>

<file path="src/env.d.ts">
import type { DefineComponent } from 'vue'
</file>

<file path="src/global.d.ts">

</file>

<file path="src/main.ts">
import { createApp } from 'vue'
import App from './App.vue'
import { router } from './router/index'
⋮----
import type { User } from '@cashflow/types'
⋮----
import { resetAllStores, setupStore } from './stores'
</file>

<file path="src/supabase.ts">
import { createClient } from '@supabase/supabase-js'
import type { Database } from './types/database.types'
</file>

<file path="database.types.ts">
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]
export type Database = {
  public: {
    Tables: {
      account: {
        Row: {
          accessToken: string | null
          accessTokenExpiresAt: string | null
          accountId: string
          createdAt: string
          id: string
          idToken: string | null
          password: string | null
          providerId: string
          refreshToken: string | null
          refreshTokenExpiresAt: string | null
          scope: string | null
          updatedAt: string | null
          userId: string
        }
        Insert: {
          accessToken?: string | null
          accessTokenExpiresAt?: string | null
          accountId: string
          createdAt?: string
          id: string
          idToken?: string | null
          password?: string | null
          providerId: string
          refreshToken?: string | null
          refreshTokenExpiresAt?: string | null
          scope?: string | null
          updatedAt?: string | null
          userId: string
        }
        Update: {
          accessToken?: string | null
          accessTokenExpiresAt?: string | null
          accountId?: string
          createdAt?: string
          id?: string
          idToken?: string | null
          password?: string | null
          providerId?: string
          refreshToken?: string | null
          refreshTokenExpiresAt?: string | null
          scope?: string | null
          updatedAt?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "account_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      achievement: {
        Row: {
          createdAt: string
          description: string
          id: string
          isActive: boolean
          name: string
          reward: number | null
          targetXp: number
          updatedAt: string | null
        }
        Insert: {
          createdAt?: string
          description: string
          id: string
          isActive?: boolean
          name: string
          reward?: number | null
          targetXp: number
          updatedAt?: string | null
        }
        Update: {
          createdAt?: string
          description?: string
          id?: string
          isActive?: boolean
          name?: string
          reward?: number | null
          targetXp?: number
          updatedAt?: string | null
        }
        Relationships: []
      }
      chatmessages: {
        Row: {
          channel: Database["public"]["Enums"]["ChatChannel"]
          content: string
          createdAt: string
          id: string
          metadata: Json | null
          roomId: string | null
          userId: string
        }
        Insert: {
          channel: Database["public"]["Enums"]["ChatChannel"]
          content: string
          createdAt?: string
          id: string
          metadata?: Json | null
          roomId?: string | null
          userId: string
        }
        Update: {
          channel?: Database["public"]["Enums"]["ChatChannel"]
          content?: string
          createdAt?: string
          id?: string
          metadata?: Json | null
          roomId?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "chatmessages_roomId_fkey"
            columns: ["roomId"]
            isOneToOne: false
            referencedRelation: "chatrooms"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "chatmessages_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      chatrooms: {
        Row: {
          createdAt: string
          gameSessionId: string | null
          id: string
          isGameRoom: boolean
          name: string
        }
        Insert: {
          createdAt?: string
          gameSessionId?: string | null
          id: string
          isGameRoom?: boolean
          name: string
        }
        Update: {
          createdAt?: string
          gameSessionId?: string | null
          id?: string
          isGameRoom?: boolean
          name?: string
        }
        Relationships: [
          {
            foreignKeyName: "chatrooms_gameSessionId_fkey"
            columns: ["gameSessionId"]
            isOneToOne: false
            referencedRelation: "gamesessions"
            referencedColumns: ["id"]
          },
        ]
      }
      event_logs: {
        Row: {
          created_at: string | null
          id: number
          operation: string
          payload: Json | null
          row_id: string | null
          table_name: string
        }
        Insert: {
          created_at?: string | null
          id?: number
          operation: string
          payload?: Json | null
          row_id?: string | null
          table_name: string
        }
        Update: {
          created_at?: string | null
          id?: number
          operation?: string
          payload?: Json | null
          row_id?: string | null
          table_name?: string
        }
        Relationships: []
      }
      friendships: {
        Row: {
          createdAt: string
          friendId: string
          id: string
          status: Database["public"]["Enums"]["FriendshipStatus"]
          updatedAt: string | null
          userId: string
        }
        Insert: {
          createdAt?: string
          friendId: string
          id: string
          status?: Database["public"]["Enums"]["FriendshipStatus"]
          updatedAt?: string | null
          userId: string
        }
        Update: {
          createdAt?: string
          friendId?: string
          id?: string
          status?: Database["public"]["Enums"]["FriendshipStatus"]
          updatedAt?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "friendships_friendId_fkey"
            columns: ["friendId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "friendships_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      games: {
        Row: {
          active: boolean
          advanced: string | null
          bet: number | null
          bids: number | null
          cask: number | null
          category: Database["public"]["Enums"]["GameCategory"]
          categoryId: string | null
          categoryTemp: number | null
          chanceFirepot1: number | null
          chanceFirepot2: number | null
          chanceFirepot3: number | null
          createdAt: string
          currentRtp: number | null
          denomination: number | null
          developer: string | null
          device: number | null
          featured: boolean | null
          fireCount1: number | null
          fireCount2: number | null
          fireCount3: number | null
          gamebank: string | null
          id: string
          isActive: boolean | null
          jackpotGroupId: string | null
          linesPercentConfigBonus: string | null
          linesPercentConfigBonusBonus: string | null
          linesPercentConfigSpin: string | null
          linesPercentConfigSpinBonus: string | null
          name: string
          operatorId: string | null
          originalId: number | null
          password: string | null
          popularity: number | null
          providerId: string | null
          rezerv: number | null
          rtpStatIn: number | null
          rtpStatOut: number | null
          scaleMode: string
          slotViewState: string
          standardRtp: number | null
          statIn: number | null
          statOut: number | null
          temperature: string | null
          title: string
          updatedAt: string | null
          view: number | null
          vipLevel: number | null
        }
        Insert: {
          active?: boolean
          advanced?: string | null
          bet?: number | null
          bids?: number | null
          cask?: number | null
          category?: Database["public"]["Enums"]["GameCategory"]
          categoryId?: string | null
          categoryTemp?: number | null
          chanceFirepot1?: number | null
          chanceFirepot2?: number | null
          chanceFirepot3?: number | null
          createdAt?: string
          currentRtp?: number | null
          denomination?: number | null
          developer?: string | null
          device?: number | null
          featured?: boolean | null
          fireCount1?: number | null
          fireCount2?: number | null
          fireCount3?: number | null
          gamebank?: string | null
          id: string
          isActive?: boolean | null
          jackpotGroupId?: string | null
          linesPercentConfigBonus?: string | null
          linesPercentConfigBonusBonus?: string | null
          linesPercentConfigSpin?: string | null
          linesPercentConfigSpinBonus?: string | null
          name: string
          operatorId?: string | null
          originalId?: number | null
          password?: string | null
          popularity?: number | null
          providerId?: string | null
          rezerv?: number | null
          rtpStatIn?: number | null
          rtpStatOut?: number | null
          scaleMode?: string
          slotViewState?: string
          standardRtp?: number | null
          statIn?: number | null
          statOut?: number | null
          temperature?: string | null
          title: string
          updatedAt?: string | null
          view?: number | null
          vipLevel?: number | null
        }
        Update: {
          active?: boolean
          advanced?: string | null
          bet?: number | null
          bids?: number | null
          cask?: number | null
          category?: Database["public"]["Enums"]["GameCategory"]
          categoryId?: string | null
          categoryTemp?: number | null
          chanceFirepot1?: number | null
          chanceFirepot2?: number | null
          chanceFirepot3?: number | null
          createdAt?: string
          currentRtp?: number | null
          denomination?: number | null
          developer?: string | null
          device?: number | null
          featured?: boolean | null
          fireCount1?: number | null
          fireCount2?: number | null
          fireCount3?: number | null
          gamebank?: string | null
          id?: string
          isActive?: boolean | null
          jackpotGroupId?: string | null
          linesPercentConfigBonus?: string | null
          linesPercentConfigBonusBonus?: string | null
          linesPercentConfigSpin?: string | null
          linesPercentConfigSpinBonus?: string | null
          name?: string
          operatorId?: string | null
          originalId?: number | null
          password?: string | null
          popularity?: number | null
          providerId?: string | null
          rezerv?: number | null
          rtpStatIn?: number | null
          rtpStatOut?: number | null
          scaleMode?: string
          slotViewState?: string
          standardRtp?: number | null
          statIn?: number | null
          statOut?: number | null
          temperature?: string | null
          title?: string
          updatedAt?: string | null
          view?: number | null
          vipLevel?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "games_operatorId_fkey"
            columns: ["operatorId"]
            isOneToOne: false
            referencedRelation: "operators"
            referencedColumns: ["id"]
          },
        ]
      }
      gamesessions: {
        Row: {
          active: boolean
          betAmount: number | null
          endTime: string | null
          gameId: string
          id: string
          metadata: Json | null
          profileId: string
          startTime: string
          tournamentId: string | null
          vipInfoId: string | null
          winAmount: number | null
          xpEarned: number
        }
        Insert: {
          active?: boolean
          betAmount?: number | null
          endTime?: string | null
          gameId: string
          id: string
          metadata?: Json | null
          profileId: string
          startTime?: string
          tournamentId?: string | null
          vipInfoId?: string | null
          winAmount?: number | null
          xpEarned?: number
        }
        Update: {
          active?: boolean
          betAmount?: number | null
          endTime?: string | null
          gameId?: string
          id?: string
          metadata?: Json | null
          profileId?: string
          startTime?: string
          tournamentId?: string | null
          vipInfoId?: string | null
          winAmount?: number | null
          xpEarned?: number
        }
        Relationships: [
          {
            foreignKeyName: "gamesessions_gameId_fkey"
            columns: ["gameId"]
            isOneToOne: false
            referencedRelation: "games"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "gamesessions_profileId_fkey"
            columns: ["profileId"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "gamesessions_tournamentId_fkey"
            columns: ["tournamentId"]
            isOneToOne: false
            referencedRelation: "tournaments"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "gamesessions_vipInfoId_fkey"
            columns: ["vipInfoId"]
            isOneToOne: false
            referencedRelation: "vip_infos"
            referencedColumns: ["id"]
          },
        ]
      }
      invitations: {
        Row: {
          email: string
          expiresAt: string
          id: string
          inviterId: string
          organizationId: string
          role: string | null
          status: string
        }
        Insert: {
          email: string
          expiresAt: string
          id: string
          inviterId: string
          organizationId: string
          role?: string | null
          status: string
        }
        Update: {
          email?: string
          expiresAt?: string
          id?: string
          inviterId?: string
          organizationId?: string
          role?: string | null
          status?: string
        }
        Relationships: [
          {
            foreignKeyName: "invitations_inviterId_fkey"
            columns: ["inviterId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "invitations_organizationId_fkey"
            columns: ["organizationId"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
        ]
      }
      members: {
        Row: {
          createdAt: string
          id: string
          organizationId: string
          role: string
          userId: string
        }
        Insert: {
          createdAt?: string
          id: string
          organizationId: string
          role: string
          userId: string
        }
        Update: {
          createdAt?: string
          id?: string
          organizationId?: string
          role?: string
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "members_organizationId_fkey"
            columns: ["organizationId"]
            isOneToOne: false
            referencedRelation: "organizations"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "members_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      messages: {
        Row: {
          authorId: string | null
          content: string | null
          createdAt: string
          id: string
          updatedAt: string | null
        }
        Insert: {
          authorId?: string | null
          content?: string | null
          createdAt?: string
          id: string
          updatedAt?: string | null
        }
        Update: {
          authorId?: string | null
          content?: string | null
          createdAt?: string
          id?: string
          updatedAt?: string | null
        }
        Relationships: []
      }
      notifications: {
        Row: {
          createdAt: string
          id: string
          isRead: boolean
          message: string
          metadata: Json | null
          readAt: string | null
          title: string
          type: Database["public"]["Enums"]["NotificationType"]
          userId: string
        }
        Insert: {
          createdAt?: string
          id: string
          isRead?: boolean
          message: string
          metadata?: Json | null
          readAt?: string | null
          title: string
          type: Database["public"]["Enums"]["NotificationType"]
          userId: string
        }
        Update: {
          createdAt?: string
          id?: string
          isRead?: boolean
          message?: string
          metadata?: Json | null
          readAt?: string | null
          title?: string
          type?: Database["public"]["Enums"]["NotificationType"]
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "notifications_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      operatorgames: {
        Row: {
          createdAt: string
          description: string | null
          id: string
          isActive: boolean
          isPromoted: boolean
          maxBet: number | null
          minBet: number | null
          name: string
          operatorId: string
          slug: string
          thumbnail: string | null
          updatedAt: string | null
          xpMultiplier: number
        }
        Insert: {
          createdAt?: string
          description?: string | null
          id: string
          isActive?: boolean
          isPromoted?: boolean
          maxBet?: number | null
          minBet?: number | null
          name: string
          operatorId: string
          slug: string
          thumbnail?: string | null
          updatedAt?: string | null
          xpMultiplier?: number
        }
        Update: {
          createdAt?: string
          description?: string | null
          id?: string
          isActive?: boolean
          isPromoted?: boolean
          maxBet?: number | null
          minBet?: number | null
          name?: string
          operatorId?: string
          slug?: string
          thumbnail?: string | null
          updatedAt?: string | null
          xpMultiplier?: number
        }
        Relationships: []
      }
      operators: {
        Row: {
          acceptedPayments: string[] | null
          balance: number
          createdAt: string
          description: string | null
          id: string
          isActive: boolean
          logo: string | null
          name: string
          ownerId: string
          slug: string
          updatedAt: string | null
        }
        Insert: {
          acceptedPayments?: string[] | null
          balance?: number
          createdAt?: string
          description?: string | null
          id: string
          isActive?: boolean
          logo?: string | null
          name: string
          ownerId: string
          slug: string
          updatedAt?: string | null
        }
        Update: {
          acceptedPayments?: string[] | null
          balance?: number
          createdAt?: string
          description?: string | null
          id?: string
          isActive?: boolean
          logo?: string | null
          name?: string
          ownerId?: string
          slug?: string
          updatedAt?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "operators_ownerId_fkey"
            columns: ["ownerId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      organizations: {
        Row: {
          createdAt: string
          id: string
          logo: string | null
          metadata: string | null
          name: string
          slug: string | null
        }
        Insert: {
          createdAt?: string
          id: string
          logo?: string | null
          metadata?: string | null
          name: string
          slug?: string | null
        }
        Update: {
          createdAt?: string
          id?: string
          logo?: string | null
          metadata?: string | null
          name?: string
          slug?: string | null
        }
        Relationships: []
      }
      platform_sessions: {
        Row: {
          active: boolean
          activeGameId: string | null
          createdAt: string
          expiresAt: string
          id: string
          ipAddress: string | null
          refreshToken: string | null
          token: string
          updatedAt: string | null
          userAgent: string | null
          userId: string
        }
        Insert: {
          active?: boolean
          activeGameId?: string | null
          createdAt?: string
          expiresAt: string
          id: string
          ipAddress?: string | null
          refreshToken?: string | null
          token: string
          updatedAt?: string | null
          userAgent?: string | null
          userId: string
        }
        Update: {
          active?: boolean
          activeGameId?: string | null
          createdAt?: string
          expiresAt?: string
          id?: string
          ipAddress?: string | null
          refreshToken?: string | null
          token?: string
          updatedAt?: string | null
          userAgent?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "platform_sessions_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      products: {
        Row: {
          amountToReceiveInCredits: number
          bestValue: number
          bonusCode: string | null
          bonusSpins: number
          bonusTotalInCredits: number
          createdAt: string
          description: string
          discountInCents: number
          id: string
          isPromo: boolean | null
          priceInCents: number
          shopId: string | null
          title: string
          totalDiscountInCents: number
          type: string
          updatedAt: string | null
          url: string
        }
        Insert: {
          amountToReceiveInCredits?: number
          bestValue?: number
          bonusCode?: string | null
          bonusSpins?: number
          bonusTotalInCredits?: number
          createdAt?: string
          description?: string
          discountInCents?: number
          id: string
          isPromo?: boolean | null
          priceInCents?: number
          shopId?: string | null
          title?: string
          totalDiscountInCents?: number
          type?: string
          updatedAt?: string | null
          url?: string
        }
        Update: {
          amountToReceiveInCredits?: number
          bestValue?: number
          bonusCode?: string | null
          bonusSpins?: number
          bonusTotalInCredits?: number
          createdAt?: string
          description?: string
          discountInCents?: number
          id?: string
          isPromo?: boolean | null
          priceInCents?: number
          shopId?: string | null
          title?: string
          totalDiscountInCents?: number
          type?: string
          updatedAt?: string | null
          url?: string
        }
        Relationships: [
          {
            foreignKeyName: "products_shopId_fkey"
            columns: ["shopId"]
            isOneToOne: false
            referencedRelation: "operators"
            referencedColumns: ["id"]
          },
        ]
      }
      profiles: {
        Row: {
          balance: number
          createdAt: string
          currency: string
          id: string
          isActive: boolean
          lastPlayed: string | null
          phpId: number | null
          shopId: string
          updatedAt: string | null
          userId: string
          xpEarned: number
        }
        Insert: {
          balance?: number
          createdAt?: string
          currency?: string
          id: string
          isActive?: boolean
          lastPlayed?: string | null
          phpId?: number | null
          shopId: string
          updatedAt?: string | null
          userId: string
          xpEarned?: number
        }
        Update: {
          balance?: number
          createdAt?: string
          currency?: string
          id?: string
          isActive?: boolean
          lastPlayed?: string | null
          phpId?: number | null
          shopId?: string
          updatedAt?: string | null
          userId?: string
          xpEarned?: number
        }
        Relationships: [
          {
            foreignKeyName: "profiles_shopId_fkey"
            columns: ["shopId"]
            isOneToOne: false
            referencedRelation: "operators"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "profiles_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      rainbets: {
        Row: {
          betAmount: number
          id: string
          odds: number
          outcome: string | null
          rainHistoryId: string
          settledAt: string | null
          userId: string
        }
        Insert: {
          betAmount: number
          id: string
          odds: number
          outcome?: string | null
          rainHistoryId: string
          settledAt?: string | null
          userId: string
        }
        Update: {
          betAmount?: number
          id?: string
          odds?: number
          outcome?: string | null
          rainHistoryId?: string
          settledAt?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "rainbets_rainHistoryId_fkey"
            columns: ["rainHistoryId"]
            isOneToOne: false
            referencedRelation: "rainhistories"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rainbets_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      rainhistories: {
        Row: {
          amount: number
          createdAt: string
          id: string
          rainType: string
          userId: string
        }
        Insert: {
          amount: number
          createdAt?: string
          id: string
          rainType: string
          userId: string
        }
        Update: {
          amount?: number
          createdAt?: string
          id?: string
          rainType?: string
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "rainhistories_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      raintips: {
        Row: {
          id: string
          rainHistoryId: string
          tipAmount: number
          tippedAt: string
          userId: string
        }
        Insert: {
          id: string
          rainHistoryId: string
          tipAmount: number
          tippedAt?: string
          userId: string
        }
        Update: {
          id?: string
          rainHistoryId?: string
          tipAmount?: number
          tippedAt?: string
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "raintips_rainHistoryId_fkey"
            columns: ["rainHistoryId"]
            isOneToOne: false
            referencedRelation: "rainhistories"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "raintips_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      rainwinners: {
        Row: {
          id: string
          rainHistoryId: string
          userId: string
          wonAmount: number
          wonAt: string
        }
        Insert: {
          id: string
          rainHistoryId: string
          userId: string
          wonAmount: number
          wonAt?: string
        }
        Update: {
          id?: string
          rainHistoryId?: string
          userId?: string
          wonAmount?: number
          wonAt?: string
        }
        Relationships: [
          {
            foreignKeyName: "rainwinners_rainHistoryId_fkey"
            columns: ["rainHistoryId"]
            isOneToOne: false
            referencedRelation: "rainhistories"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "rainwinners_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      tournamententries: {
        Row: {
          id: string
          joinedAt: string
          profileId: string
          score: number
          tournamentId: string
          userId: string
          wagered: number
          won: number
        }
        Insert: {
          id: string
          joinedAt?: string
          profileId: string
          score?: number
          tournamentId: string
          userId: string
          wagered?: number
          won?: number
        }
        Update: {
          id?: string
          joinedAt?: string
          profileId?: string
          score?: number
          tournamentId?: string
          userId?: string
          wagered?: number
          won?: number
        }
        Relationships: [
          {
            foreignKeyName: "tournamententries_profileId_fkey"
            columns: ["profileId"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tournamententries_tournamentId_fkey"
            columns: ["tournamentId"]
            isOneToOne: false
            referencedRelation: "tournaments"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tournamententries_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      tournamentgames: {
        Row: {
          gameId: string
          id: string
          multiplier: number
          tournamentId: string
        }
        Insert: {
          gameId: string
          id: string
          multiplier?: number
          tournamentId: string
        }
        Update: {
          gameId?: string
          id?: string
          multiplier?: number
          tournamentId?: string
        }
        Relationships: [
          {
            foreignKeyName: "tournamentgames_gameId_fkey"
            columns: ["gameId"]
            isOneToOne: false
            referencedRelation: "games"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tournamentgames_tournamentId_fkey"
            columns: ["tournamentId"]
            isOneToOne: false
            referencedRelation: "tournaments"
            referencedColumns: ["id"]
          },
        ]
      }
      tournaments: {
        Row: {
          createdAt: string
          description: string | null
          endTime: string
          entryFee: number | null
          id: string
          isActive: boolean
          leaderboard: Json | null
          name: string
          operatorId: string
          prizePool: number
          startTime: string
          updatedAt: string | null
        }
        Insert: {
          createdAt?: string
          description?: string | null
          endTime: string
          entryFee?: number | null
          id: string
          isActive?: boolean
          leaderboard?: Json | null
          name: string
          operatorId: string
          prizePool?: number
          startTime: string
          updatedAt?: string | null
        }
        Update: {
          createdAt?: string
          description?: string | null
          endTime?: string
          entryFee?: number | null
          id?: string
          isActive?: boolean
          leaderboard?: Json | null
          name?: string
          operatorId?: string
          prizePool?: number
          startTime?: string
          updatedAt?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "tournaments_operatorId_fkey"
            columns: ["operatorId"]
            isOneToOne: false
            referencedRelation: "operators"
            referencedColumns: ["id"]
          },
        ]
      }
      transactions: {
        Row: {
          amount: number
          amountCredits: number
          buyerCashtag: string | null
          buyerUserId: string | null
          cashierAvatar: string | null
          cashierId: string | null
          cashiername: string | null
          cashtag: string | null
          createdAt: string
          gameSessionId: string | null
          id: string
          isRealMoney: boolean
          metadata: Json | null
          paymentDetails: Json | null
          paymentMethod: string | null
          processedAt: string | null
          productid: string | null
          profileId: string | null
          reference: string | null
          status: Database["public"]["Enums"]["TransactionStatus"]
          type: Database["public"]["Enums"]["TransactionType"]
          username: string | null
          vipInfoId: string | null
        }
        Insert: {
          amount?: number
          amountCredits?: number
          buyerCashtag?: string | null
          buyerUserId?: string | null
          cashierAvatar?: string | null
          cashierId?: string | null
          cashiername?: string | null
          cashtag?: string | null
          createdAt?: string
          gameSessionId?: string | null
          id: string
          isRealMoney?: boolean
          metadata?: Json | null
          paymentDetails?: Json | null
          paymentMethod?: string | null
          processedAt?: string | null
          productid?: string | null
          profileId?: string | null
          reference?: string | null
          status?: Database["public"]["Enums"]["TransactionStatus"]
          type?: Database["public"]["Enums"]["TransactionType"]
          username?: string | null
          vipInfoId?: string | null
        }
        Update: {
          amount?: number
          amountCredits?: number
          buyerCashtag?: string | null
          buyerUserId?: string | null
          cashierAvatar?: string | null
          cashierId?: string | null
          cashiername?: string | null
          cashtag?: string | null
          createdAt?: string
          gameSessionId?: string | null
          id?: string
          isRealMoney?: boolean
          metadata?: Json | null
          paymentDetails?: Json | null
          paymentMethod?: string | null
          processedAt?: string | null
          productid?: string | null
          profileId?: string | null
          reference?: string | null
          status?: Database["public"]["Enums"]["TransactionStatus"]
          type?: Database["public"]["Enums"]["TransactionType"]
          username?: string | null
          vipInfoId?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "transactions_gameSessionId_fkey"
            columns: ["gameSessionId"]
            isOneToOne: false
            referencedRelation: "gamesessions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "transactions_productid_fkey"
            columns: ["productid"]
            isOneToOne: false
            referencedRelation: "products"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "transactions_profileId_fkey"
            columns: ["profileId"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "transactions_vipInfoId_fkey"
            columns: ["vipInfoId"]
            isOneToOne: false
            referencedRelation: "vip_infos"
            referencedColumns: ["id"]
          },
        ]
      }
      twoFactors: {
        Row: {
          backupCodes: string
          id: string
          secret: string
          userId: string
        }
        Insert: {
          backupCodes: string
          id: string
          secret: string
          userId: string
        }
        Update: {
          backupCodes?: string
          id?: string
          secret?: string
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "twoFactors_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      user: {
        Row: {
          accessToken: string | null
          active: boolean
          activeProfileId: string | null
          avatar: string | null
          balance: number
          banExpires: string | null
          banned: boolean | null
          banReason: string | null
          cashtag: string | null
          createdAt: string
          displayUsername: string
          email: string
          emailVerified: boolean | null
          gender: Database["public"]["Enums"]["Gender"] | null
          id: string
          image: string | null
          isOnline: boolean | null
          isVerified: boolean
          lastDailySpin: string | null
          lastLogin: string | null
          name: string | null
          passwordHash: string | null
          phpId: number | null
          role: string | null
          sbId: string | null
          status: Database["public"]["Enums"]["UserStatus"] | null
          totalXp: number
          twoFactorEnabled: boolean | null
          updatedAt: string | null
          username: string
          verificationToken: string | null
          vipInfoId: string | null
        }
        Insert: {
          accessToken?: string | null
          active?: boolean
          activeProfileId?: string | null
          avatar?: string | null
          balance?: number
          banExpires?: string | null
          banned?: boolean | null
          banReason?: string | null
          cashtag?: string | null
          createdAt?: string
          displayUsername?: string
          email: string
          emailVerified?: boolean | null
          gender?: Database["public"]["Enums"]["Gender"] | null
          id: string
          image?: string | null
          isOnline?: boolean | null
          isVerified?: boolean
          lastDailySpin?: string | null
          lastLogin?: string | null
          name?: string | null
          passwordHash?: string | null
          phpId?: number | null
          role?: string | null
          sbId?: string | null
          status?: Database["public"]["Enums"]["UserStatus"] | null
          totalXp?: number
          twoFactorEnabled?: boolean | null
          updatedAt?: string | null
          username: string
          verificationToken?: string | null
          vipInfoId?: string | null
        }
        Update: {
          accessToken?: string | null
          active?: boolean
          activeProfileId?: string | null
          avatar?: string | null
          balance?: number
          banExpires?: string | null
          banned?: boolean | null
          banReason?: string | null
          cashtag?: string | null
          createdAt?: string
          displayUsername?: string
          email?: string
          emailVerified?: boolean | null
          gender?: Database["public"]["Enums"]["Gender"] | null
          id?: string
          image?: string | null
          isOnline?: boolean | null
          isVerified?: boolean
          lastDailySpin?: string | null
          lastLogin?: string | null
          name?: string | null
          passwordHash?: string | null
          phpId?: number | null
          role?: string | null
          sbId?: string | null
          status?: Database["public"]["Enums"]["UserStatus"] | null
          totalXp?: number
          twoFactorEnabled?: boolean | null
          updatedAt?: string | null
          username?: string
          verificationToken?: string | null
          vipInfoId?: string | null
        }
        Relationships: []
      }
      userachievements: {
        Row: {
          achievementId: string
          createdAt: string
          id: string
          isUnlocked: boolean
          progress: number
          unlockedAt: string | null
          updatedAt: string | null
          userId: string
        }
        Insert: {
          achievementId: string
          createdAt?: string
          id: string
          isUnlocked?: boolean
          progress?: number
          unlockedAt?: string | null
          updatedAt?: string | null
          userId: string
        }
        Update: {
          achievementId?: string
          createdAt?: string
          id?: string
          isUnlocked?: boolean
          progress?: number
          unlockedAt?: string | null
          updatedAt?: string | null
          userId?: string
        }
        Relationships: [
          {
            foreignKeyName: "userachievements_achievementId_fkey"
            columns: ["achievementId"]
            isOneToOne: false
            referencedRelation: "achievement"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "userachievements_userId_fkey"
            columns: ["userId"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
      verifications: {
        Row: {
          createdAt: string | null
          expiresAt: string
          id: string
          identifier: string
          updatedAt: string | null
          value: string
        }
        Insert: {
          createdAt?: string | null
          expiresAt: string
          id: string
          identifier: string
          updatedAt?: string | null
          value: string
        }
        Update: {
          createdAt?: string | null
          expiresAt?: string
          id?: string
          identifier?: string
          updatedAt?: string | null
          value?: string
        }
        Relationships: []
      }
      vip_infos: {
        Row: {
          bet_award_switch: boolean
          bet_exp: number
          can_receive_bet_award: boolean
          can_receive_day_award: boolean
          can_receive_level_award: boolean
          can_receive_month_award: boolean
          can_receive_rank_award: boolean
          can_receive_signin_award: boolean
          can_receive_week_award: boolean
          can_receive_withdrawal_award: boolean
          cycle_award_switch: boolean
          deposit_exp: number
          exp_switch_type: number | null
          free_spin_times: number | null
          history_cash_back: number | null
          icon: string | null
          id: string
          is_protection: boolean
          level: number
          level_award_switch: boolean
          level_bet_exp: string | null
          level_deposit_exp: string | null
          main_currency: string | null
          month_gift: number | null
          now_bet_exp: string | null
          now_cash_back: number | null
          now_deposit_exp: string | null
          operatorId: string | null
          protection_bet_amount: string | null
          protection_bet_exp: string | null
          protection_days: number | null
          protection_deposit_amount: string | null
          protection_deposit_exp: string | null
          protection_switch: number | null
          rank_bet_exp: number
          rank_deposit_exp: number
          rank_name: string | null
          signin_award_switch: boolean
          telegram: string | null
          unprotection_bet_amount: string | null
          unprotection_bet_exp: string | null
          unprotection_days: number | null
          unprotection_deposit_amount: string | null
          unprotection_deposit_exp: string | null
          unprotection_switch: number | null
          upgrade_gift: number | null
          userid: string | null
          week_gift: number | null
          withdrawal_award_switch: boolean
          yesterday_cash_back: number | null
        }
        Insert: {
          bet_award_switch?: boolean
          bet_exp?: number
          can_receive_bet_award?: boolean
          can_receive_day_award?: boolean
          can_receive_level_award?: boolean
          can_receive_month_award?: boolean
          can_receive_rank_award?: boolean
          can_receive_signin_award?: boolean
          can_receive_week_award?: boolean
          can_receive_withdrawal_award?: boolean
          cycle_award_switch?: boolean
          deposit_exp?: number
          exp_switch_type?: number | null
          free_spin_times?: number | null
          history_cash_back?: number | null
          icon?: string | null
          id: string
          is_protection?: boolean
          level?: number
          level_award_switch?: boolean
          level_bet_exp?: string | null
          level_deposit_exp?: string | null
          main_currency?: string | null
          month_gift?: number | null
          now_bet_exp?: string | null
          now_cash_back?: number | null
          now_deposit_exp?: string | null
          operatorId?: string | null
          protection_bet_amount?: string | null
          protection_bet_exp?: string | null
          protection_days?: number | null
          protection_deposit_amount?: string | null
          protection_deposit_exp?: string | null
          protection_switch?: number | null
          rank_bet_exp?: number
          rank_deposit_exp?: number
          rank_name?: string | null
          signin_award_switch?: boolean
          telegram?: string | null
          unprotection_bet_amount?: string | null
          unprotection_bet_exp?: string | null
          unprotection_days?: number | null
          unprotection_deposit_amount?: string | null
          unprotection_deposit_exp?: string | null
          unprotection_switch?: number | null
          upgrade_gift?: number | null
          userid?: string | null
          week_gift?: number | null
          withdrawal_award_switch?: boolean
          yesterday_cash_back?: number | null
        }
        Update: {
          bet_award_switch?: boolean
          bet_exp?: number
          can_receive_bet_award?: boolean
          can_receive_day_award?: boolean
          can_receive_level_award?: boolean
          can_receive_month_award?: boolean
          can_receive_rank_award?: boolean
          can_receive_signin_award?: boolean
          can_receive_week_award?: boolean
          can_receive_withdrawal_award?: boolean
          cycle_award_switch?: boolean
          deposit_exp?: number
          exp_switch_type?: number | null
          free_spin_times?: number | null
          history_cash_back?: number | null
          icon?: string | null
          id?: string
          is_protection?: boolean
          level?: number
          level_award_switch?: boolean
          level_bet_exp?: string | null
          level_deposit_exp?: string | null
          main_currency?: string | null
          month_gift?: number | null
          now_bet_exp?: string | null
          now_cash_back?: number | null
          now_deposit_exp?: string | null
          operatorId?: string | null
          protection_bet_amount?: string | null
          protection_bet_exp?: string | null
          protection_days?: number | null
          protection_deposit_amount?: string | null
          protection_deposit_exp?: string | null
          protection_switch?: number | null
          rank_bet_exp?: number
          rank_deposit_exp?: number
          rank_name?: string | null
          signin_award_switch?: boolean
          telegram?: string | null
          unprotection_bet_amount?: string | null
          unprotection_bet_exp?: string | null
          unprotection_days?: number | null
          unprotection_deposit_amount?: string | null
          unprotection_deposit_exp?: string | null
          unprotection_switch?: number | null
          upgrade_gift?: number | null
          userid?: string | null
          week_gift?: number | null
          withdrawal_award_switch?: boolean
          yesterday_cash_back?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "vip_infos_operatorId_fkey"
            columns: ["operatorId"]
            isOneToOne: false
            referencedRelation: "operators"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "vip_infos_userid_fkey"
            columns: ["userid"]
            isOneToOne: false
            referencedRelation: "user"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      arcade_increment_crystals: {
        Args: { row_id: number; val: number }
        Returns: undefined
      }
      check_min_rights: {
        Args:
          | {
              min_right: Database["public"]["Enums"]["user_min_right"]
              org_id: string
              app_id: string
              channel_id: number
            }
          | {
              min_right: Database["public"]["Enums"]["user_min_right"]
              user_id: string
              org_id: string
              app_id: string
              channel_id: number
            }
        Returns: boolean
      }
      convert_bytes_to_gb: {
        Args: { byt: number }
        Returns: number
      }
      convert_bytes_to_mb: {
        Args: { byt: number }
        Returns: number
      }
      convert_gb_to_bytes: {
        Args: { gb: number }
        Returns: number
      }
      convert_mb_to_bytes: {
        Args: { gb: number }
        Returns: number
      }
      convert_number_to_percent: {
        Args: { val: number; max_val: number }
        Returns: number
      }
      count_all_apps: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      count_all_need_upgrade: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      count_all_onboarded: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      count_all_paying: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      count_all_plans: {
        Args: Record<PropertyKey, never>
        Returns: {
          product_id: string
          count: number
        }[]
      }
      count_all_trial: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      count_all_updates: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      ddlx_get_dependants: {
        Args: { "": unknown }
        Returns: Record<string, unknown>[]
      }
      delete_user: {
        Args: Record<PropertyKey, never>
        Returns: undefined
      }
      exist_app_v2: {
        Args: { appid: string }
        Returns: boolean
      }
      exist_app_versions: {
        Args: { appid: string; name_version: string; apikey: string }
        Returns: boolean
      }
      exist_user: {
        Args: { e_mail: string }
        Returns: string
      }
      find_best_plan_v3: {
        Args: { mau: number; bandwidth: number; storage: number }
        Returns: string
      }
      find_fit_plan_v3: {
        Args: { mau: number; bandwidth: number; storage: number }
        Returns: {
          name: string
        }[]
      }
      generate_inbox: {
        Args: { size: number }
        Returns: string
      }
      get_apikey: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      get_app_versions: {
        Args: { appid: string; name_version: string; apikey: string }
        Returns: number
      }
      get_current_plan_max: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: string
      }
      get_current_plan_name: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: string
      }
      get_cycle_info: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: {
          subscription_anchor_start: string
          subscription_anchor_end: string
        }[]
      }
      get_db_url: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      get_devices_version: {
        Args: { app_id: string; version_id: number }
        Returns: number
      }
      get_external_function_url: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      get_max_plan: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: {
          mau: number
          storage: number
          bandwidth: number
        }[]
      }
      get_metered_usage: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: number
      }
      get_plan_usage_percent: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: number
      }
      get_total_app_storage_size: {
        Args: { app_id: string } | { userid: string; app_id: string }
        Returns: number
      }
      get_total_stats_v2: {
        Args: { dateid: string } | { userid: string; dateid: string }
        Returns: {
          mau: number
          bandwidth: number
          storage: number
        }[]
      }
      get_total_stats_v3: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: {
          mau: number
          bandwidth: number
          storage: number
        }[]
      }
      get_total_storage_size: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: number
      }
      get_total_storage_size_org: {
        Args: { org_id: string }
        Returns: number
      }
      get_usage_mode_and_last_saved: {
        Args: Record<PropertyKey, never>
        Returns: {
          usage_mode: Database["public"]["Enums"]["usage_mode"]
          last_saved: string
        }[]
      }
      get_user_id: {
        Args: { apikey: string }
        Returns: string
      }
      get_weekly_stats: {
        Args: { app_id: string }
        Returns: {
          all_updates: number
          failed_updates: number
          open_app: number
        }[]
      }
      handle_wheel_of_fortune_spin: {
        Args: { row_id: string; crystals_to_add: number }
        Returns: undefined
      }
      has_min_right: {
        Args: {
          _userid: string
          _orgid: string
          _right: Database["public"]["Enums"]["user_min_right"]
          _appid?: string
          _channelid?: number
        }
        Returns: boolean
      }
      http_post_helper: {
        Args: { function_name: string; function_type: string; body: Json }
        Returns: undefined
      }
      increment_coins: {
        Args: { row_id: string; val: number }
        Returns: undefined
      }
      increment_coins_from_arcade: {
        Args: { row_id: number; val: number }
        Returns: undefined
      }
      increment_crystals: {
        Args: { row_id: number; val: number }
        Returns: undefined
      }
      increment_crystals_from_arcade: {
        Args: { row_id: number; val: number }
        Returns: undefined
      }
      increment_store: {
        Args: { app_id: string; updates: number }
        Returns: undefined
      }
      is_admin: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_allowed_action: {
        Args: { apikey: string } | { apikey: string; appid: string }
        Returns: boolean
      }
      is_allowed_action_user: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_allowed_capgkey: {
        Args:
          | {
              apikey: string
              keymode: Database["public"]["Enums"]["key_mode"][]
            }
          | {
              apikey: string
              keymode: Database["public"]["Enums"]["key_mode"][]
              app_id: string
            }
        Returns: boolean
      }
      is_app_owner: {
        Args:
          | { apikey: string; appid: string }
          | { appid: string }
          | { userid: string; appid: string }
        Returns: boolean
      }
      is_app_shared: {
        Args: { appid: string } | { userid: string; appid: string }
        Returns: boolean
      }
      is_canceled: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_free_usage: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_good_plan_v3: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_good_plan_v4: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_in_channel: {
        Args: { userid: string } | { userid: string; ownerid: string }
        Returns: boolean
      }
      is_not_deleted: {
        Args: { email_check: string }
        Returns: boolean
      }
      is_onboarded: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_onboarding_needed: {
        Args: Record<PropertyKey, never> | { userid: string }
        Returns: boolean
      }
      is_paying: {
        Args: Record<PropertyKey, never>
        Returns: boolean
      }
      is_trial: {
        Args: { userid: string }
        Returns: number
      }
      is_version_shared: {
        Args: { userid: string; versionid: number }
        Returns: boolean
      }
      nolimit_decrement_crystals: {
        Args: { row_id: string; val: number }
        Returns: Json
      }
      nolimit_increment_coins: {
        Args: { row_id: string; val: number }
        Returns: Json
      }
      one_month_ahead: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      remove_enum_value: {
        Args: { enum_type: unknown; enum_value: string }
        Returns: undefined
      }
    }
    Enums: {
      ChatChannel: "LOBBY" | "GAME" | "TOURNAMENT" | "PRIVATE"
      FriendshipStatus: "PENDING" | "ACCEPTED" | "BLOCKED"
      GameCategory: "TABLE" | "FISH" | "POKER" | "SLOTS" | "OTHER"
      Gender: "BOY" | "GIRL" | "ALIEN" | "UNSURE" | "ROBOT" | "COMPLICATED"
      key_mode: "read" | "write" | "all" | "upload"
      message_state: "read" | "unread" | "group"
      NotificationType:
        | "SYSTEM"
        | "FRIEND_REQUEST"
        | "ACHIEVEMENT"
        | "BALANCE_UPDATE"
        | "PROMOTIONAL"
        | "TOURNAMENT"
      platform_os: "ios" | "android"
      product_cost: "D500" | "D1000" | "D2000" | "D5000" | "D10000"
      request_status: "PENDING" | "SUCCESS" | "ERROR"
      stripe_status:
        | "created"
        | "succeeded"
        | "updated"
        | "failed"
        | "deleted"
        | "canceled"
      transaction_status: "PENDING" | "COMPLETED" | "DENIED"
      TransactionStatus:
        | "PENDING"
        | "COMPLETED"
        | "FAILED"
        | "CANCELLED"
        | "REFUNDED"
        | "EXPIRED"
        | "REJECTED"
      TransactionType:
        | "DEPOSIT"
        | "WITHDRAWAL"
        | "BET"
        | "WIN"
        | "BONUS"
        | "DONATION"
        | "ADJUSTMENT"
        | "TOURNAMENT_BUYIN"
        | "TOURNAMENT_PRIZE"
      usage_mode: "last_saved" | "min5" | '"day"' | '"cycle"'
      user_min_right: "read" | "upload" | "write" | "admin"
      user_role: "read" | "upload" | "write" | "admin"
      user_status: "ONLINE" | "OFFLINE" | "BUSY" | "AWAY"
      UserStatus: "ACTIVE" | "INACTIVE" | "ONLINE" | "OFFLINE"
      volatility: "HIGH" | "MEDIUM" | "LOW"
    }
    CompositeTypes: {
      stats_table: {
        mau: number | null
        bandwidth: number | null
        storage: number | null
      }
    }
  }
}
type DefaultSchema = Database[Extract<keyof Database, "public">]
export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never
export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never
export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never
export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never
export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never
</file>

<file path="index.html">
<!doctype html>
<html lang="">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <title>Vite App</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Bungee&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Kanit:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
      integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
    <script src="https://cdn.launcher.a8r.games/connector.js" defer></script>
  </body>
</html>
</file>

<file path="postcss.config.js">

</file>

<file path="tailwind.config.js">

</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import AppLoading from 'vite-plugin-app-loading'
</file>

</files>
