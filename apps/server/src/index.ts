
// export default server
import type { Server, ErrorLike } from "bun"; // Import Bun's Server type and Errorlike
import { auth } from "./rest/auth";
import createApp from "./rest/create-app";
import { registerRoutes } from "./routes";
import { WebSocketRouter } from "./sockets";
import { chatRouter } from "./sockets/chat.wsroute";
import { swaggerUI } from "@hono/swagger-ui";

export const app = createApp();
// registerRoutes(app)
interface MyWebSocketData {
  userId?: string;
  roomId?: string;
  username?: string;
}
type AdditionalWsData = Omit<MyWebSocketData, "clientId">;
const wsRouter = new WebSocketRouter<AdditionalWsData>();
wsRouter.addRoutes(chatRouter);

const PORT = 6589;
console.log(`Attempting to start server on port ${PORT}...`);

// Pass the type for the *additional* data (excluding clientId) as the first generic argument.
// Pass an empty object type `{}` as the second generic argument to satisfy the type signature.
const server = Bun.serve<AdditionalWsData, {}>({
  // Corrected: Added second type argument {}
  port: PORT,
  hostname: "0.0.0.0", // Listen on all interfaces
  routes: {
    "/ws": async (req: Request) => {
      const session = await auth.api.getSession({
        headers: req.headers,
      });
      if (!session?.user || !session?.user.id) {
        console.log(
          "[Bun Fetch] WebSocket upgrade denied: Missing userId query param."
        );
        return new Response(
          "userId query parameter is required for WebSocket connection",
          { status: 401 }
        );
      }
      return wsRouter.upgrade(req, {
        server,
        data: {
          userId: session?.user.id,
          roomId: session?.user.id,
          clientId: session?.user.id as string,
        },
      }); // Return the WebSocketHandler
      // // return Response.json(session);
    },
  },
  fetch(
    req: Request,
    server: Server
  ): Response | Promise<Response> | undefined {
    const url = new URL(req.url);
    console.log("x");
    //   // Pass the server instance in the environment object for Hono context
    const honoEnv = { serverInstance: server };
    return app.fetch(req, honoEnv);
    //   // --- End HTTP Request Handling ---
  },
  /**
   * Assign the WebSocket handlers generated by our custom router instance.
   */
  websocket: wsRouter.websocket,

  /**
   * Error handling for the Bun server itself.
   * Corrected return type to satisfy Bun's expected signature.
   */
  error(error: ErrorLike): void | Response | Promise<void> | Promise<Response> {
    console.error("[Bun Server Error]", error);
    // Returning a Response:
    return Promise.resolve(
      new Response(`Server error: ${error.message || "Unknown error"}`, {
        status: 500,
      })
    );
  },
});

console.log(`ðŸš€ Server listening on http://${server.hostname}:${server.port}`);

// Optional: Graceful shutdown handling
process.on("SIGINT", () => {
  console.log("\nReceived SIGINT. Shutting down server...");
  server.stop(true); // true = close existing connections gracefully
  console.log("Server stopped.");
  process.exit(0);
});

export type CashflowServerAppType = typeof app;
