
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model PlatformSession
 * 
 */
export type PlatformSession = $Result.DefaultSelection<Prisma.$PlatformSessionPayload>
/**
 * Model Operator
 * 
 */
export type Operator = $Result.DefaultSelection<Prisma.$OperatorPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model Operatorgame
 * 
 */
export type Operatorgame = $Result.DefaultSelection<Prisma.$OperatorgamePayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model TwoFactor
 * 
 */
export type TwoFactor = $Result.DefaultSelection<Prisma.$TwoFactorPayload>
/**
 * Model Chatmessage
 * 
 */
export type Chatmessage = $Result.DefaultSelection<Prisma.$ChatmessagePayload>
/**
 * Model Chatroom
 * 
 */
export type Chatroom = $Result.DefaultSelection<Prisma.$ChatroomPayload>
/**
 * Model Friendship
 * 
 */
export type Friendship = $Result.DefaultSelection<Prisma.$FriendshipPayload>
/**
 * Model Gamesession
 * 
 */
export type Gamesession = $Result.DefaultSelection<Prisma.$GamesessionPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Tournament
 * 
 */
export type Tournament = $Result.DefaultSelection<Prisma.$TournamentPayload>
/**
 * Model Tournamententry
 * 
 */
export type Tournamententry = $Result.DefaultSelection<Prisma.$TournamententryPayload>
/**
 * Model Tournamentgame
 * 
 */
export type Tournamentgame = $Result.DefaultSelection<Prisma.$TournamentgamePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Userachievement
 * 
 */
export type Userachievement = $Result.DefaultSelection<Prisma.$UserachievementPayload>
/**
 * Model RainBet
 * 
 */
export type RainBet = $Result.DefaultSelection<Prisma.$RainBetPayload>
/**
 * Model RainHistory
 * 
 */
export type RainHistory = $Result.DefaultSelection<Prisma.$RainHistoryPayload>
/**
 * Model RainTip
 * 
 */
export type RainTip = $Result.DefaultSelection<Prisma.$RainTipPayload>
/**
 * Model RainWinner
 * 
 */
export type RainWinner = $Result.DefaultSelection<Prisma.$RainWinnerPayload>
/**
 * Model VipInfo
 * 
 */
export type VipInfo = $Result.DefaultSelection<Prisma.$VipInfoPayload>
/**
 * Model EventLog
 * 
 */
export type EventLog = $Result.DefaultSelection<Prisma.$EventLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  BOY: 'BOY',
  GIRL: 'GIRL',
  ALIEN: 'ALIEN',
  UNSURE: 'UNSURE',
  ROBOT: 'ROBOT',
  COMPLICATED: 'COMPLICATED'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const GameCategory: {
  TABLE: 'TABLE',
  FISH: 'FISH',
  POKER: 'POKER',
  SLOTS: 'SLOTS',
  OTHER: 'OTHER'
};

export type GameCategory = (typeof GameCategory)[keyof typeof GameCategory]


export const ChatChannel: {
  LOBBY: 'LOBBY',
  GAME: 'GAME',
  TOURNAMENT: 'TOURNAMENT',
  PRIVATE: 'PRIVATE'
};

export type ChatChannel = (typeof ChatChannel)[keyof typeof ChatChannel]


export const FriendshipStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  BLOCKED: 'BLOCKED'
};

export type FriendshipStatus = (typeof FriendshipStatus)[keyof typeof FriendshipStatus]


export const NotificationType: {
  SYSTEM: 'SYSTEM',
  FRIEND_REQUEST: 'FRIEND_REQUEST',
  ACHIEVEMENT: 'ACHIEVEMENT',
  BALANCE_UPDATE: 'BALANCE_UPDATE',
  PROMOTIONAL: 'PROMOTIONAL',
  TOURNAMENT: 'TOURNAMENT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const TransactionType: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAWAL: 'WITHDRAWAL',
  BET: 'BET',
  WIN: 'WIN',
  BONUS: 'BONUS',
  DONATION: 'DONATION',
  ADJUSTMENT: 'ADJUSTMENT',
  TOURNAMENT_BUYIN: 'TOURNAMENT_BUYIN',
  TOURNAMENT_PRIZE: 'TOURNAMENT_PRIZE'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED',
  EXPIRED: 'EXPIRED',
  REJECTED: 'REJECTED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type GameCategory = $Enums.GameCategory

export const GameCategory: typeof $Enums.GameCategory

export type ChatChannel = $Enums.ChatChannel

export const ChatChannel: typeof $Enums.ChatChannel

export type FriendshipStatus = $Enums.FriendshipStatus

export const FriendshipStatus: typeof $Enums.FriendshipStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Achievements
 * const achievements = await prisma.achievement.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Achievements
   * const achievements = await prisma.achievement.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.platformSession`: Exposes CRUD operations for the **PlatformSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformSessions
    * const platformSessions = await prisma.platformSession.findMany()
    * ```
    */
  get platformSession(): Prisma.PlatformSessionDelegate<ExtArgs>;

  /**
   * `prisma.operator`: Exposes CRUD operations for the **Operator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operators
    * const operators = await prisma.operator.findMany()
    * ```
    */
  get operator(): Prisma.OperatorDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs>;

  /**
   * `prisma.operatorgame`: Exposes CRUD operations for the **Operatorgame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operatorgames
    * const operatorgames = await prisma.operatorgame.findMany()
    * ```
    */
  get operatorgame(): Prisma.OperatorgameDelegate<ExtArgs>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs>;

  /**
   * `prisma.twoFactor`: Exposes CRUD operations for the **TwoFactor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactors
    * const twoFactors = await prisma.twoFactor.findMany()
    * ```
    */
  get twoFactor(): Prisma.TwoFactorDelegate<ExtArgs>;

  /**
   * `prisma.chatmessage`: Exposes CRUD operations for the **Chatmessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatmessages
    * const chatmessages = await prisma.chatmessage.findMany()
    * ```
    */
  get chatmessage(): Prisma.ChatmessageDelegate<ExtArgs>;

  /**
   * `prisma.chatroom`: Exposes CRUD operations for the **Chatroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatrooms
    * const chatrooms = await prisma.chatroom.findMany()
    * ```
    */
  get chatroom(): Prisma.ChatroomDelegate<ExtArgs>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.FriendshipDelegate<ExtArgs>;

  /**
   * `prisma.gamesession`: Exposes CRUD operations for the **Gamesession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gamesessions
    * const gamesessions = await prisma.gamesession.findMany()
    * ```
    */
  get gamesession(): Prisma.GamesessionDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.tournament`: Exposes CRUD operations for the **Tournament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournament.findMany()
    * ```
    */
  get tournament(): Prisma.TournamentDelegate<ExtArgs>;

  /**
   * `prisma.tournamententry`: Exposes CRUD operations for the **Tournamententry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournamententries
    * const tournamententries = await prisma.tournamententry.findMany()
    * ```
    */
  get tournamententry(): Prisma.TournamententryDelegate<ExtArgs>;

  /**
   * `prisma.tournamentgame`: Exposes CRUD operations for the **Tournamentgame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournamentgames
    * const tournamentgames = await prisma.tournamentgame.findMany()
    * ```
    */
  get tournamentgame(): Prisma.TournamentgameDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.userachievement`: Exposes CRUD operations for the **Userachievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userachievements
    * const userachievements = await prisma.userachievement.findMany()
    * ```
    */
  get userachievement(): Prisma.UserachievementDelegate<ExtArgs>;

  /**
   * `prisma.rainBet`: Exposes CRUD operations for the **RainBet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainBets
    * const rainBets = await prisma.rainBet.findMany()
    * ```
    */
  get rainBet(): Prisma.RainBetDelegate<ExtArgs>;

  /**
   * `prisma.rainHistory`: Exposes CRUD operations for the **RainHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainHistories
    * const rainHistories = await prisma.rainHistory.findMany()
    * ```
    */
  get rainHistory(): Prisma.RainHistoryDelegate<ExtArgs>;

  /**
   * `prisma.rainTip`: Exposes CRUD operations for the **RainTip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainTips
    * const rainTips = await prisma.rainTip.findMany()
    * ```
    */
  get rainTip(): Prisma.RainTipDelegate<ExtArgs>;

  /**
   * `prisma.rainWinner`: Exposes CRUD operations for the **RainWinner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainWinners
    * const rainWinners = await prisma.rainWinner.findMany()
    * ```
    */
  get rainWinner(): Prisma.RainWinnerDelegate<ExtArgs>;

  /**
   * `prisma.vipInfo`: Exposes CRUD operations for the **VipInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VipInfos
    * const vipInfos = await prisma.vipInfo.findMany()
    * ```
    */
  get vipInfo(): Prisma.VipInfoDelegate<ExtArgs>;

  /**
   * `prisma.eventLog`: Exposes CRUD operations for the **EventLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventLogs
    * const eventLogs = await prisma.eventLog.findMany()
    * ```
    */
  get eventLog(): Prisma.EventLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Achievement: 'Achievement',
    User: 'User',
    Account: 'Account',
    PlatformSession: 'PlatformSession',
    Operator: 'Operator',
    Message: 'Message',
    Profile: 'Profile',
    Game: 'Game',
    Operatorgame: 'Operatorgame',
    Verification: 'Verification',
    Organization: 'Organization',
    Member: 'Member',
    Invitation: 'Invitation',
    TwoFactor: 'TwoFactor',
    Chatmessage: 'Chatmessage',
    Chatroom: 'Chatroom',
    Friendship: 'Friendship',
    Gamesession: 'Gamesession',
    Product: 'Product',
    Notification: 'Notification',
    Tournament: 'Tournament',
    Tournamententry: 'Tournamententry',
    Tournamentgame: 'Tournamentgame',
    Transaction: 'Transaction',
    Userachievement: 'Userachievement',
    RainBet: 'RainBet',
    RainHistory: 'RainHistory',
    RainTip: 'RainTip',
    RainWinner: 'RainWinner',
    VipInfo: 'VipInfo',
    EventLog: 'EventLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "achievement" | "user" | "account" | "platformSession" | "operator" | "message" | "profile" | "game" | "operatorgame" | "verification" | "organization" | "member" | "invitation" | "twoFactor" | "chatmessage" | "chatroom" | "friendship" | "gamesession" | "product" | "notification" | "tournament" | "tournamententry" | "tournamentgame" | "transaction" | "userachievement" | "rainBet" | "rainHistory" | "rainTip" | "rainWinner" | "vipInfo" | "eventLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      PlatformSession: {
        payload: Prisma.$PlatformSessionPayload<ExtArgs>
        fields: Prisma.PlatformSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSessionPayload>
          }
          findFirst: {
            args: Prisma.PlatformSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSessionPayload>
          }
          findMany: {
            args: Prisma.PlatformSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSessionPayload>[]
          }
          create: {
            args: Prisma.PlatformSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSessionPayload>
          }
          createMany: {
            args: Prisma.PlatformSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSessionPayload>[]
          }
          delete: {
            args: Prisma.PlatformSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSessionPayload>
          }
          update: {
            args: Prisma.PlatformSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSessionPayload>
          }
          deleteMany: {
            args: Prisma.PlatformSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlatformSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformSessionPayload>
          }
          aggregate: {
            args: Prisma.PlatformSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformSession>
          }
          groupBy: {
            args: Prisma.PlatformSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformSessionCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformSessionCountAggregateOutputType> | number
          }
        }
      }
      Operator: {
        payload: Prisma.$OperatorPayload<ExtArgs>
        fields: Prisma.OperatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          findFirst: {
            args: Prisma.OperatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          findMany: {
            args: Prisma.OperatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>[]
          }
          create: {
            args: Prisma.OperatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          createMany: {
            args: Prisma.OperatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>[]
          }
          delete: {
            args: Prisma.OperatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          update: {
            args: Prisma.OperatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          deleteMany: {
            args: Prisma.OperatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          aggregate: {
            args: Prisma.OperatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperator>
          }
          groupBy: {
            args: Prisma.OperatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperatorCountArgs<ExtArgs>
            result: $Utils.Optional<OperatorCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      Operatorgame: {
        payload: Prisma.$OperatorgamePayload<ExtArgs>
        fields: Prisma.OperatorgameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperatorgameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorgamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperatorgameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorgamePayload>
          }
          findFirst: {
            args: Prisma.OperatorgameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorgamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperatorgameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorgamePayload>
          }
          findMany: {
            args: Prisma.OperatorgameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorgamePayload>[]
          }
          create: {
            args: Prisma.OperatorgameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorgamePayload>
          }
          createMany: {
            args: Prisma.OperatorgameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperatorgameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorgamePayload>[]
          }
          delete: {
            args: Prisma.OperatorgameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorgamePayload>
          }
          update: {
            args: Prisma.OperatorgameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorgamePayload>
          }
          deleteMany: {
            args: Prisma.OperatorgameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperatorgameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperatorgameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorgamePayload>
          }
          aggregate: {
            args: Prisma.OperatorgameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperatorgame>
          }
          groupBy: {
            args: Prisma.OperatorgameGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatorgameGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperatorgameCountArgs<ExtArgs>
            result: $Utils.Optional<OperatorgameCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      TwoFactor: {
        payload: Prisma.$TwoFactorPayload<ExtArgs>
        fields: Prisma.TwoFactorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          findMany: {
            args: Prisma.TwoFactorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>[]
          }
          create: {
            args: Prisma.TwoFactorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          createMany: {
            args: Prisma.TwoFactorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwoFactorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>[]
          }
          delete: {
            args: Prisma.TwoFactorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          update: {
            args: Prisma.TwoFactorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TwoFactorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwoFactor>
          }
          groupBy: {
            args: Prisma.TwoFactorGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorCountArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorCountAggregateOutputType> | number
          }
        }
      }
      Chatmessage: {
        payload: Prisma.$ChatmessagePayload<ExtArgs>
        fields: Prisma.ChatmessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatmessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatmessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatmessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatmessagePayload>
          }
          findFirst: {
            args: Prisma.ChatmessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatmessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatmessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatmessagePayload>
          }
          findMany: {
            args: Prisma.ChatmessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatmessagePayload>[]
          }
          create: {
            args: Prisma.ChatmessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatmessagePayload>
          }
          createMany: {
            args: Prisma.ChatmessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatmessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatmessagePayload>[]
          }
          delete: {
            args: Prisma.ChatmessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatmessagePayload>
          }
          update: {
            args: Prisma.ChatmessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatmessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatmessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatmessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatmessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatmessagePayload>
          }
          aggregate: {
            args: Prisma.ChatmessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatmessage>
          }
          groupBy: {
            args: Prisma.ChatmessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatmessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatmessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatmessageCountAggregateOutputType> | number
          }
        }
      }
      Chatroom: {
        payload: Prisma.$ChatroomPayload<ExtArgs>
        fields: Prisma.ChatroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          findFirst: {
            args: Prisma.ChatroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          findMany: {
            args: Prisma.ChatroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>[]
          }
          create: {
            args: Prisma.ChatroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          createMany: {
            args: Prisma.ChatroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>[]
          }
          delete: {
            args: Prisma.ChatroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          update: {
            args: Prisma.ChatroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          deleteMany: {
            args: Prisma.ChatroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatroomPayload>
          }
          aggregate: {
            args: Prisma.ChatroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatroom>
          }
          groupBy: {
            args: Prisma.ChatroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatroomCountArgs<ExtArgs>
            result: $Utils.Optional<ChatroomCountAggregateOutputType> | number
          }
        }
      }
      Friendship: {
        payload: Prisma.$FriendshipPayload<ExtArgs>
        fields: Prisma.FriendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findFirst: {
            args: Prisma.FriendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findMany: {
            args: Prisma.FriendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          create: {
            args: Prisma.FriendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          createMany: {
            args: Prisma.FriendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          delete: {
            args: Prisma.FriendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          update: {
            args: Prisma.FriendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          deleteMany: {
            args: Prisma.FriendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FriendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.FriendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      Gamesession: {
        payload: Prisma.$GamesessionPayload<ExtArgs>
        fields: Prisma.GamesessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GamesessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamesessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GamesessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamesessionPayload>
          }
          findFirst: {
            args: Prisma.GamesessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamesessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GamesessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamesessionPayload>
          }
          findMany: {
            args: Prisma.GamesessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamesessionPayload>[]
          }
          create: {
            args: Prisma.GamesessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamesessionPayload>
          }
          createMany: {
            args: Prisma.GamesessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GamesessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamesessionPayload>[]
          }
          delete: {
            args: Prisma.GamesessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamesessionPayload>
          }
          update: {
            args: Prisma.GamesessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamesessionPayload>
          }
          deleteMany: {
            args: Prisma.GamesessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GamesessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GamesessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamesessionPayload>
          }
          aggregate: {
            args: Prisma.GamesessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGamesession>
          }
          groupBy: {
            args: Prisma.GamesessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GamesessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GamesessionCountArgs<ExtArgs>
            result: $Utils.Optional<GamesessionCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Tournament: {
        payload: Prisma.$TournamentPayload<ExtArgs>
        fields: Prisma.TournamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          findFirst: {
            args: Prisma.TournamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          findMany: {
            args: Prisma.TournamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          create: {
            args: Prisma.TournamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          createMany: {
            args: Prisma.TournamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          delete: {
            args: Prisma.TournamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          update: {
            args: Prisma.TournamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          deleteMany: {
            args: Prisma.TournamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TournamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          aggregate: {
            args: Prisma.TournamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournament>
          }
          groupBy: {
            args: Prisma.TournamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentCountAggregateOutputType> | number
          }
        }
      }
      Tournamententry: {
        payload: Prisma.$TournamententryPayload<ExtArgs>
        fields: Prisma.TournamententryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamententryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamententryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamententryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamententryPayload>
          }
          findFirst: {
            args: Prisma.TournamententryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamententryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamententryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamententryPayload>
          }
          findMany: {
            args: Prisma.TournamententryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamententryPayload>[]
          }
          create: {
            args: Prisma.TournamententryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamententryPayload>
          }
          createMany: {
            args: Prisma.TournamententryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamententryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamententryPayload>[]
          }
          delete: {
            args: Prisma.TournamententryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamententryPayload>
          }
          update: {
            args: Prisma.TournamententryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamententryPayload>
          }
          deleteMany: {
            args: Prisma.TournamententryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamententryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TournamententryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamententryPayload>
          }
          aggregate: {
            args: Prisma.TournamententryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamententry>
          }
          groupBy: {
            args: Prisma.TournamententryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamententryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamententryCountArgs<ExtArgs>
            result: $Utils.Optional<TournamententryCountAggregateOutputType> | number
          }
        }
      }
      Tournamentgame: {
        payload: Prisma.$TournamentgamePayload<ExtArgs>
        fields: Prisma.TournamentgameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentgameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentgamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentgameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentgamePayload>
          }
          findFirst: {
            args: Prisma.TournamentgameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentgamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentgameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentgamePayload>
          }
          findMany: {
            args: Prisma.TournamentgameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentgamePayload>[]
          }
          create: {
            args: Prisma.TournamentgameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentgamePayload>
          }
          createMany: {
            args: Prisma.TournamentgameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentgameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentgamePayload>[]
          }
          delete: {
            args: Prisma.TournamentgameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentgamePayload>
          }
          update: {
            args: Prisma.TournamentgameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentgamePayload>
          }
          deleteMany: {
            args: Prisma.TournamentgameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentgameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TournamentgameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentgamePayload>
          }
          aggregate: {
            args: Prisma.TournamentgameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamentgame>
          }
          groupBy: {
            args: Prisma.TournamentgameGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentgameGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentgameCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentgameCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Userachievement: {
        payload: Prisma.$UserachievementPayload<ExtArgs>
        fields: Prisma.UserachievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserachievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserachievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserachievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserachievementPayload>
          }
          findFirst: {
            args: Prisma.UserachievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserachievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserachievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserachievementPayload>
          }
          findMany: {
            args: Prisma.UserachievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserachievementPayload>[]
          }
          create: {
            args: Prisma.UserachievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserachievementPayload>
          }
          createMany: {
            args: Prisma.UserachievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserachievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserachievementPayload>[]
          }
          delete: {
            args: Prisma.UserachievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserachievementPayload>
          }
          update: {
            args: Prisma.UserachievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserachievementPayload>
          }
          deleteMany: {
            args: Prisma.UserachievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserachievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserachievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserachievementPayload>
          }
          aggregate: {
            args: Prisma.UserachievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserachievement>
          }
          groupBy: {
            args: Prisma.UserachievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserachievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserachievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserachievementCountAggregateOutputType> | number
          }
        }
      }
      RainBet: {
        payload: Prisma.$RainBetPayload<ExtArgs>
        fields: Prisma.RainBetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainBetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainBetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          findFirst: {
            args: Prisma.RainBetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainBetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          findMany: {
            args: Prisma.RainBetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>[]
          }
          create: {
            args: Prisma.RainBetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          createMany: {
            args: Prisma.RainBetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainBetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>[]
          }
          delete: {
            args: Prisma.RainBetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          update: {
            args: Prisma.RainBetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          deleteMany: {
            args: Prisma.RainBetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainBetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RainBetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          aggregate: {
            args: Prisma.RainBetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainBet>
          }
          groupBy: {
            args: Prisma.RainBetGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainBetGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainBetCountArgs<ExtArgs>
            result: $Utils.Optional<RainBetCountAggregateOutputType> | number
          }
        }
      }
      RainHistory: {
        payload: Prisma.$RainHistoryPayload<ExtArgs>
        fields: Prisma.RainHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          findFirst: {
            args: Prisma.RainHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          findMany: {
            args: Prisma.RainHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>[]
          }
          create: {
            args: Prisma.RainHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          createMany: {
            args: Prisma.RainHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>[]
          }
          delete: {
            args: Prisma.RainHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          update: {
            args: Prisma.RainHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          deleteMany: {
            args: Prisma.RainHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RainHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          aggregate: {
            args: Prisma.RainHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainHistory>
          }
          groupBy: {
            args: Prisma.RainHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<RainHistoryCountAggregateOutputType> | number
          }
        }
      }
      RainTip: {
        payload: Prisma.$RainTipPayload<ExtArgs>
        fields: Prisma.RainTipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainTipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainTipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          findFirst: {
            args: Prisma.RainTipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainTipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          findMany: {
            args: Prisma.RainTipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>[]
          }
          create: {
            args: Prisma.RainTipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          createMany: {
            args: Prisma.RainTipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainTipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>[]
          }
          delete: {
            args: Prisma.RainTipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          update: {
            args: Prisma.RainTipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          deleteMany: {
            args: Prisma.RainTipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainTipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RainTipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          aggregate: {
            args: Prisma.RainTipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainTip>
          }
          groupBy: {
            args: Prisma.RainTipGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainTipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainTipCountArgs<ExtArgs>
            result: $Utils.Optional<RainTipCountAggregateOutputType> | number
          }
        }
      }
      RainWinner: {
        payload: Prisma.$RainWinnerPayload<ExtArgs>
        fields: Prisma.RainWinnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainWinnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainWinnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          findFirst: {
            args: Prisma.RainWinnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainWinnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          findMany: {
            args: Prisma.RainWinnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>[]
          }
          create: {
            args: Prisma.RainWinnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          createMany: {
            args: Prisma.RainWinnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainWinnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>[]
          }
          delete: {
            args: Prisma.RainWinnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          update: {
            args: Prisma.RainWinnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          deleteMany: {
            args: Prisma.RainWinnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainWinnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RainWinnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          aggregate: {
            args: Prisma.RainWinnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainWinner>
          }
          groupBy: {
            args: Prisma.RainWinnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainWinnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainWinnerCountArgs<ExtArgs>
            result: $Utils.Optional<RainWinnerCountAggregateOutputType> | number
          }
        }
      }
      VipInfo: {
        payload: Prisma.$VipInfoPayload<ExtArgs>
        fields: Prisma.VipInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VipInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VipInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          findFirst: {
            args: Prisma.VipInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VipInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          findMany: {
            args: Prisma.VipInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>[]
          }
          create: {
            args: Prisma.VipInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          createMany: {
            args: Prisma.VipInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VipInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>[]
          }
          delete: {
            args: Prisma.VipInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          update: {
            args: Prisma.VipInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          deleteMany: {
            args: Prisma.VipInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VipInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VipInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          aggregate: {
            args: Prisma.VipInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVipInfo>
          }
          groupBy: {
            args: Prisma.VipInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VipInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VipInfoCountArgs<ExtArgs>
            result: $Utils.Optional<VipInfoCountAggregateOutputType> | number
          }
        }
      }
      EventLog: {
        payload: Prisma.$EventLogPayload<ExtArgs>
        fields: Prisma.EventLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          findFirst: {
            args: Prisma.EventLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          findMany: {
            args: Prisma.EventLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>[]
          }
          create: {
            args: Prisma.EventLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          createMany: {
            args: Prisma.EventLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>[]
          }
          delete: {
            args: Prisma.EventLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          update: {
            args: Prisma.EventLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          deleteMany: {
            args: Prisma.EventLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventLogPayload>
          }
          aggregate: {
            args: Prisma.EventLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventLog>
          }
          groupBy: {
            args: Prisma.EventLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventLogCountArgs<ExtArgs>
            result: $Utils.Optional<EventLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    userachievement: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userachievement?: boolean | AchievementCountOutputTypeCountUserachievementArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUserachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserachievementWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    operator: number
    activeProfile: number
    RainBet: number
    RainHistory: number
    RainTip: number
    RainWinner: number
    sessions: number
    accounts: number
    chatmessage: number
    friendshipFriendshipFriendidtouser: number
    friendshipFriendshipUseridtouser: number
    invitations: number
    members: number
    notification: number
    tournamententry: number
    twofactors: number
    userachievement: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | UserCountOutputTypeCountOperatorArgs
    activeProfile?: boolean | UserCountOutputTypeCountActiveProfileArgs
    RainBet?: boolean | UserCountOutputTypeCountRainBetArgs
    RainHistory?: boolean | UserCountOutputTypeCountRainHistoryArgs
    RainTip?: boolean | UserCountOutputTypeCountRainTipArgs
    RainWinner?: boolean | UserCountOutputTypeCountRainWinnerArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    chatmessage?: boolean | UserCountOutputTypeCountChatmessageArgs
    friendshipFriendshipFriendidtouser?: boolean | UserCountOutputTypeCountFriendshipFriendshipFriendidtouserArgs
    friendshipFriendshipUseridtouser?: boolean | UserCountOutputTypeCountFriendshipFriendshipUseridtouserArgs
    invitations?: boolean | UserCountOutputTypeCountInvitationsArgs
    members?: boolean | UserCountOutputTypeCountMembersArgs
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
    tournamententry?: boolean | UserCountOutputTypeCountTournamententryArgs
    twofactors?: boolean | UserCountOutputTypeCountTwofactorsArgs
    userachievement?: boolean | UserCountOutputTypeCountUserachievementArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOperatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActiveProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainBetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainTipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainWinnerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatmessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendshipFriendshipFriendidtouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendshipFriendshipUseridtouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamententryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTwofactorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserachievementWhereInput
  }


  /**
   * Count Type OperatorCountOutputType
   */

  export type OperatorCountOutputType = {
    profiles: number
    games: number
    products: number
    tournaments: number
    VipInfo: number
  }

  export type OperatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profiles?: boolean | OperatorCountOutputTypeCountProfilesArgs
    games?: boolean | OperatorCountOutputTypeCountGamesArgs
    products?: boolean | OperatorCountOutputTypeCountProductsArgs
    tournaments?: boolean | OperatorCountOutputTypeCountTournamentsArgs
    VipInfo?: boolean | OperatorCountOutputTypeCountVipInfoArgs
  }

  // Custom InputTypes
  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCountOutputType
     */
    select?: OperatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountTournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountVipInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VipInfoWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    gamesession: number
    tournamententry: number
    transactions: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | ProfileCountOutputTypeCountGamesessionArgs
    tournamententry?: boolean | ProfileCountOutputTypeCountTournamententryArgs
    transactions?: boolean | ProfileCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountGamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamesessionWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamententryWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    gamesession: number
    tournamentgame: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | GameCountOutputTypeCountGamesessionArgs
    tournamentgame?: boolean | GameCountOutputTypeCountTournamentgameArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountGamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamesessionWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountTournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentgameWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    invitations: number
    members: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitations?: boolean | OrganizationCountOutputTypeCountInvitationsArgs
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * Count Type ChatroomCountOutputType
   */

  export type ChatroomCountOutputType = {
    chatmessage: number
  }

  export type ChatroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatmessage?: boolean | ChatroomCountOutputTypeCountChatmessageArgs
  }

  // Custom InputTypes
  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomCountOutputType
     */
    select?: ChatroomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeCountChatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatmessageWhereInput
  }


  /**
   * Count Type GamesessionCountOutputType
   */

  export type GamesessionCountOutputType = {
    chatroom: number
    Transaction: number
  }

  export type GamesessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | GamesessionCountOutputTypeCountChatroomArgs
    Transaction?: boolean | GamesessionCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * GamesessionCountOutputType without action
   */
  export type GamesessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamesessionCountOutputType
     */
    select?: GamesessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GamesessionCountOutputType without action
   */
  export type GamesessionCountOutputTypeCountChatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomWhereInput
  }

  /**
   * GamesessionCountOutputType without action
   */
  export type GamesessionCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    transactions: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | ProductCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type TournamentCountOutputType
   */

  export type TournamentCountOutputType = {
    gamesession: number
    tournamententry: number
    tournamentgame: number
  }

  export type TournamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | TournamentCountOutputTypeCountGamesessionArgs
    tournamententry?: boolean | TournamentCountOutputTypeCountTournamententryArgs
    tournamentgame?: boolean | TournamentCountOutputTypeCountTournamentgameArgs
  }

  // Custom InputTypes
  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentCountOutputType
     */
    select?: TournamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountGamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamesessionWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountTournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamententryWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountTournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentgameWhereInput
  }


  /**
   * Count Type RainHistoryCountOutputType
   */

  export type RainHistoryCountOutputType = {
    RainBet: number
    RainTip: number
    RainWinner: number
  }

  export type RainHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainBet?: boolean | RainHistoryCountOutputTypeCountRainBetArgs
    RainTip?: boolean | RainHistoryCountOutputTypeCountRainTipArgs
    RainWinner?: boolean | RainHistoryCountOutputTypeCountRainWinnerArgs
  }

  // Custom InputTypes
  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistoryCountOutputType
     */
    select?: RainHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeCountRainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainBetWhereInput
  }

  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeCountRainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainTipWhereInput
  }

  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeCountRainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainWinnerWhereInput
  }


  /**
   * Count Type VipInfoCountOutputType
   */

  export type VipInfoCountOutputType = {
    gamesession: number
    transactions: number
  }

  export type VipInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | VipInfoCountOutputTypeCountGamesessionArgs
    transactions?: boolean | VipInfoCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * VipInfoCountOutputType without action
   */
  export type VipInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfoCountOutputType
     */
    select?: VipInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VipInfoCountOutputType without action
   */
  export type VipInfoCountOutputTypeCountGamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamesessionWhereInput
  }

  /**
   * VipInfoCountOutputType without action
   */
  export type VipInfoCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    targetXp: number | null
    reward: number | null
  }

  export type AchievementSumAggregateOutputType = {
    targetXp: number | null
    reward: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    targetXp: number | null
    reward: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    targetXp: number | null
    reward: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    targetXp: number
    reward: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    targetXp?: true
    reward?: true
  }

  export type AchievementSumAggregateInputType = {
    targetXp?: true
    reward?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetXp?: true
    reward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetXp?: true
    reward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetXp?: true
    reward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    name: string
    description: string
    targetXp: number
    reward: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userachievement?: boolean | Achievement$userachievementArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userachievement?: boolean | Achievement$userachievementArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      userachievement: Prisma.$UserachievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      targetXp: number
      reward: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userachievement<T extends Achievement$userachievementArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$userachievementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */ 
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly targetXp: FieldRef<"Achievement", 'Int'>
    readonly reward: FieldRef<"Achievement", 'Int'>
    readonly isActive: FieldRef<"Achievement", 'Boolean'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
    readonly updatedAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement.userachievement
   */
  export type Achievement$userachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    where?: UserachievementWhereInput
    orderBy?: UserachievementOrderByWithRelationInput | UserachievementOrderByWithRelationInput[]
    cursor?: UserachievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    totalXp: number | null
    balance: number | null
    phpId: number | null
  }

  export type UserSumAggregateOutputType = {
    totalXp: number | null
    balance: number | null
    phpId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    sbId: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    isOnline: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    username: string | null
    displayUsername: string | null
    passwordHash: string | null
    totalXp: number | null
    balance: number | null
    isVerified: boolean | null
    active: boolean | null
    lastLogin: Date | null
    verificationToken: string | null
    avatar: string | null
    activeProfileId: string | null
    gender: $Enums.Gender | null
    status: $Enums.UserStatus | null
    cashtag: string | null
    phpId: number | null
    accessToken: string | null
    vipInfoId: string | null
    lastDailySpin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    sbId: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    isOnline: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    username: string | null
    displayUsername: string | null
    passwordHash: string | null
    totalXp: number | null
    balance: number | null
    isVerified: boolean | null
    active: boolean | null
    lastLogin: Date | null
    verificationToken: string | null
    avatar: string | null
    activeProfileId: string | null
    gender: $Enums.Gender | null
    status: $Enums.UserStatus | null
    cashtag: string | null
    phpId: number | null
    accessToken: string | null
    vipInfoId: string | null
    lastDailySpin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    sbId: number
    name: number
    email: number
    emailVerified: number
    isOnline: number
    image: number
    createdAt: number
    updatedAt: number
    twoFactorEnabled: number
    role: number
    banned: number
    banReason: number
    banExpires: number
    username: number
    displayUsername: number
    passwordHash: number
    totalXp: number
    balance: number
    isVerified: number
    active: number
    lastLogin: number
    verificationToken: number
    avatar: number
    activeProfileId: number
    gender: number
    status: number
    cashtag: number
    phpId: number
    accessToken: number
    vipInfoId: number
    lastDailySpin: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    totalXp?: true
    balance?: true
    phpId?: true
  }

  export type UserSumAggregateInputType = {
    totalXp?: true
    balance?: true
    phpId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    sbId?: true
    name?: true
    email?: true
    emailVerified?: true
    isOnline?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    username?: true
    displayUsername?: true
    passwordHash?: true
    totalXp?: true
    balance?: true
    isVerified?: true
    active?: true
    lastLogin?: true
    verificationToken?: true
    avatar?: true
    activeProfileId?: true
    gender?: true
    status?: true
    cashtag?: true
    phpId?: true
    accessToken?: true
    vipInfoId?: true
    lastDailySpin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    sbId?: true
    name?: true
    email?: true
    emailVerified?: true
    isOnline?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    username?: true
    displayUsername?: true
    passwordHash?: true
    totalXp?: true
    balance?: true
    isVerified?: true
    active?: true
    lastLogin?: true
    verificationToken?: true
    avatar?: true
    activeProfileId?: true
    gender?: true
    status?: true
    cashtag?: true
    phpId?: true
    accessToken?: true
    vipInfoId?: true
    lastDailySpin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    sbId?: true
    name?: true
    email?: true
    emailVerified?: true
    isOnline?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    username?: true
    displayUsername?: true
    passwordHash?: true
    totalXp?: true
    balance?: true
    isVerified?: true
    active?: true
    lastLogin?: true
    verificationToken?: true
    avatar?: true
    activeProfileId?: true
    gender?: true
    status?: true
    cashtag?: true
    phpId?: true
    accessToken?: true
    vipInfoId?: true
    lastDailySpin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    sbId: string | null
    name: string | null
    email: string
    emailVerified: boolean | null
    isOnline: boolean | null
    image: string | null
    createdAt: Date
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    username: string
    displayUsername: string
    passwordHash: string | null
    totalXp: number
    balance: number
    isVerified: boolean
    active: boolean
    lastLogin: Date | null
    verificationToken: string | null
    avatar: string | null
    activeProfileId: string | null
    gender: $Enums.Gender | null
    status: $Enums.UserStatus | null
    cashtag: string | null
    phpId: number | null
    accessToken: string | null
    vipInfoId: string | null
    lastDailySpin: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sbId?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    isOnline?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    username?: boolean
    displayUsername?: boolean
    passwordHash?: boolean
    totalXp?: boolean
    balance?: boolean
    isVerified?: boolean
    active?: boolean
    lastLogin?: boolean
    verificationToken?: boolean
    avatar?: boolean
    activeProfileId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
    vipInfoId?: boolean
    lastDailySpin?: boolean
    operator?: boolean | User$operatorArgs<ExtArgs>
    activeProfile?: boolean | User$activeProfileArgs<ExtArgs>
    RainBet?: boolean | User$RainBetArgs<ExtArgs>
    RainHistory?: boolean | User$RainHistoryArgs<ExtArgs>
    RainTip?: boolean | User$RainTipArgs<ExtArgs>
    RainWinner?: boolean | User$RainWinnerArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    chatmessage?: boolean | User$chatmessageArgs<ExtArgs>
    friendshipFriendshipFriendidtouser?: boolean | User$friendshipFriendshipFriendidtouserArgs<ExtArgs>
    friendshipFriendshipUseridtouser?: boolean | User$friendshipFriendshipUseridtouserArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    members?: boolean | User$membersArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    tournamententry?: boolean | User$tournamententryArgs<ExtArgs>
    twofactors?: boolean | User$twofactorsArgs<ExtArgs>
    userachievement?: boolean | User$userachievementArgs<ExtArgs>
    vipInfo?: boolean | User$vipInfoArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sbId?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    isOnline?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    username?: boolean
    displayUsername?: boolean
    passwordHash?: boolean
    totalXp?: boolean
    balance?: boolean
    isVerified?: boolean
    active?: boolean
    lastLogin?: boolean
    verificationToken?: boolean
    avatar?: boolean
    activeProfileId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
    vipInfoId?: boolean
    lastDailySpin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    sbId?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    isOnline?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    username?: boolean
    displayUsername?: boolean
    passwordHash?: boolean
    totalXp?: boolean
    balance?: boolean
    isVerified?: boolean
    active?: boolean
    lastLogin?: boolean
    verificationToken?: boolean
    avatar?: boolean
    activeProfileId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
    vipInfoId?: boolean
    lastDailySpin?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | User$operatorArgs<ExtArgs>
    activeProfile?: boolean | User$activeProfileArgs<ExtArgs>
    RainBet?: boolean | User$RainBetArgs<ExtArgs>
    RainHistory?: boolean | User$RainHistoryArgs<ExtArgs>
    RainTip?: boolean | User$RainTipArgs<ExtArgs>
    RainWinner?: boolean | User$RainWinnerArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    chatmessage?: boolean | User$chatmessageArgs<ExtArgs>
    friendshipFriendshipFriendidtouser?: boolean | User$friendshipFriendshipFriendidtouserArgs<ExtArgs>
    friendshipFriendshipUseridtouser?: boolean | User$friendshipFriendshipUseridtouserArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    members?: boolean | User$membersArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    tournamententry?: boolean | User$tournamententryArgs<ExtArgs>
    twofactors?: boolean | User$twofactorsArgs<ExtArgs>
    userachievement?: boolean | User$userachievementArgs<ExtArgs>
    vipInfo?: boolean | User$vipInfoArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      operator: Prisma.$OperatorPayload<ExtArgs>[]
      activeProfile: Prisma.$ProfilePayload<ExtArgs>[]
      RainBet: Prisma.$RainBetPayload<ExtArgs>[]
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>[]
      RainTip: Prisma.$RainTipPayload<ExtArgs>[]
      RainWinner: Prisma.$RainWinnerPayload<ExtArgs>[]
      sessions: Prisma.$PlatformSessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      chatmessage: Prisma.$ChatmessagePayload<ExtArgs>[]
      friendshipFriendshipFriendidtouser: Prisma.$FriendshipPayload<ExtArgs>[]
      friendshipFriendshipUseridtouser: Prisma.$FriendshipPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
      members: Prisma.$MemberPayload<ExtArgs>[]
      notification: Prisma.$NotificationPayload<ExtArgs>[]
      tournamententry: Prisma.$TournamententryPayload<ExtArgs>[]
      twofactors: Prisma.$TwoFactorPayload<ExtArgs>[]
      userachievement: Prisma.$UserachievementPayload<ExtArgs>[]
      vipInfo: Prisma.$VipInfoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sbId: string | null
      name: string | null
      email: string
      emailVerified: boolean | null
      isOnline: boolean | null
      image: string | null
      createdAt: Date
      updatedAt: Date | null
      twoFactorEnabled: boolean | null
      role: string | null
      banned: boolean | null
      banReason: string | null
      banExpires: Date | null
      username: string
      displayUsername: string
      passwordHash: string | null
      totalXp: number
      balance: number
      isVerified: boolean
      active: boolean
      lastLogin: Date | null
      verificationToken: string | null
      avatar: string | null
      activeProfileId: string | null
      gender: $Enums.Gender | null
      status: $Enums.UserStatus | null
      cashtag: string | null
      phpId: number | null
      accessToken: string | null
      vipInfoId: string | null
      lastDailySpin: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operator<T extends User$operatorArgs<ExtArgs> = {}>(args?: Subset<T, User$operatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findMany"> | Null>
    activeProfile<T extends User$activeProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$activeProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany"> | Null>
    RainBet<T extends User$RainBetArgs<ExtArgs> = {}>(args?: Subset<T, User$RainBetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findMany"> | Null>
    RainHistory<T extends User$RainHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$RainHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    RainTip<T extends User$RainTipArgs<ExtArgs> = {}>(args?: Subset<T, User$RainTipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findMany"> | Null>
    RainWinner<T extends User$RainWinnerArgs<ExtArgs> = {}>(args?: Subset<T, User$RainWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    chatmessage<T extends User$chatmessageArgs<ExtArgs> = {}>(args?: Subset<T, User$chatmessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "findMany"> | Null>
    friendshipFriendshipFriendidtouser<T extends User$friendshipFriendshipFriendidtouserArgs<ExtArgs> = {}>(args?: Subset<T, User$friendshipFriendshipFriendidtouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany"> | Null>
    friendshipFriendshipUseridtouser<T extends User$friendshipFriendshipUseridtouserArgs<ExtArgs> = {}>(args?: Subset<T, User$friendshipFriendshipUseridtouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany"> | Null>
    invitations<T extends User$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany"> | Null>
    members<T extends User$membersArgs<ExtArgs> = {}>(args?: Subset<T, User$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany"> | Null>
    notification<T extends User$notificationArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    tournamententry<T extends User$tournamententryArgs<ExtArgs> = {}>(args?: Subset<T, User$tournamententryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "findMany"> | Null>
    twofactors<T extends User$twofactorsArgs<ExtArgs> = {}>(args?: Subset<T, User$twofactorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findMany"> | Null>
    userachievement<T extends User$userachievementArgs<ExtArgs> = {}>(args?: Subset<T, User$userachievementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "findMany"> | Null>
    vipInfo<T extends User$vipInfoArgs<ExtArgs> = {}>(args?: Subset<T, User$vipInfoArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly sbId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly isOnline: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'String'>
    readonly banned: FieldRef<"User", 'Boolean'>
    readonly banReason: FieldRef<"User", 'String'>
    readonly banExpires: FieldRef<"User", 'DateTime'>
    readonly username: FieldRef<"User", 'String'>
    readonly displayUsername: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly totalXp: FieldRef<"User", 'Int'>
    readonly balance: FieldRef<"User", 'Int'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly activeProfileId: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly cashtag: FieldRef<"User", 'String'>
    readonly phpId: FieldRef<"User", 'Int'>
    readonly accessToken: FieldRef<"User", 'String'>
    readonly vipInfoId: FieldRef<"User", 'String'>
    readonly lastDailySpin: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.operator
   */
  export type User$operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    where?: OperatorWhereInput
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    cursor?: OperatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * User.activeProfile
   */
  export type User$activeProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * User.RainBet
   */
  export type User$RainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    where?: RainBetWhereInput
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    cursor?: RainBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * User.RainHistory
   */
  export type User$RainHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    where?: RainHistoryWhereInput
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    cursor?: RainHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * User.RainTip
   */
  export type User$RainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    where?: RainTipWhereInput
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    cursor?: RainTipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * User.RainWinner
   */
  export type User$RainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    where?: RainWinnerWhereInput
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    cursor?: RainWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
    where?: PlatformSessionWhereInput
    orderBy?: PlatformSessionOrderByWithRelationInput | PlatformSessionOrderByWithRelationInput[]
    cursor?: PlatformSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformSessionScalarFieldEnum | PlatformSessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.chatmessage
   */
  export type User$chatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    where?: ChatmessageWhereInput
    orderBy?: ChatmessageOrderByWithRelationInput | ChatmessageOrderByWithRelationInput[]
    cursor?: ChatmessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * User.friendshipFriendshipFriendidtouser
   */
  export type User$friendshipFriendshipFriendidtouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.friendshipFriendshipUseridtouser
   */
  export type User$friendshipFriendshipUseridtouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.invitations
   */
  export type User$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User.members
   */
  export type User$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * User.notification
   */
  export type User$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.tournamententry
   */
  export type User$tournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    where?: TournamententryWhereInput
    orderBy?: TournamententryOrderByWithRelationInput | TournamententryOrderByWithRelationInput[]
    cursor?: TournamententryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * User.twofactors
   */
  export type User$twofactorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    where?: TwoFactorWhereInput
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    cursor?: TwoFactorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * User.userachievement
   */
  export type User$userachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    where?: UserachievementWhereInput
    orderBy?: UserachievementOrderByWithRelationInput | UserachievementOrderByWithRelationInput[]
    cursor?: UserachievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * User.vipInfo
   */
  export type User$vipInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    where?: VipInfoWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model PlatformSession
   */

  export type AggregatePlatformSession = {
    _count: PlatformSessionCountAggregateOutputType | null
    _min: PlatformSessionMinAggregateOutputType | null
    _max: PlatformSessionMaxAggregateOutputType | null
  }

  export type PlatformSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    activeGameId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    refreshToken: string | null
    active: boolean | null
    token: string | null
    updatedAt: Date | null
  }

  export type PlatformSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    activeGameId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    refreshToken: string | null
    active: boolean | null
    token: string | null
    updatedAt: Date | null
  }

  export type PlatformSessionCountAggregateOutputType = {
    id: number
    userId: number
    activeGameId: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    refreshToken: number
    active: number
    token: number
    updatedAt: number
    _all: number
  }


  export type PlatformSessionMinAggregateInputType = {
    id?: true
    userId?: true
    activeGameId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    refreshToken?: true
    active?: true
    token?: true
    updatedAt?: true
  }

  export type PlatformSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    activeGameId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    refreshToken?: true
    active?: true
    token?: true
    updatedAt?: true
  }

  export type PlatformSessionCountAggregateInputType = {
    id?: true
    userId?: true
    activeGameId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    refreshToken?: true
    active?: true
    token?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformSession to aggregate.
     */
    where?: PlatformSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSessions to fetch.
     */
    orderBy?: PlatformSessionOrderByWithRelationInput | PlatformSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformSessions
    **/
    _count?: true | PlatformSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformSessionMaxAggregateInputType
  }

  export type GetPlatformSessionAggregateType<T extends PlatformSessionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformSession[P]>
      : GetScalarType<T[P], AggregatePlatformSession[P]>
  }




  export type PlatformSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformSessionWhereInput
    orderBy?: PlatformSessionOrderByWithAggregationInput | PlatformSessionOrderByWithAggregationInput[]
    by: PlatformSessionScalarFieldEnum[] | PlatformSessionScalarFieldEnum
    having?: PlatformSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformSessionCountAggregateInputType | true
    _min?: PlatformSessionMinAggregateInputType
    _max?: PlatformSessionMaxAggregateInputType
  }

  export type PlatformSessionGroupByOutputType = {
    id: string
    userId: string
    activeGameId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    refreshToken: string | null
    active: boolean
    token: string
    updatedAt: Date | null
    _count: PlatformSessionCountAggregateOutputType | null
    _min: PlatformSessionMinAggregateOutputType | null
    _max: PlatformSessionMaxAggregateOutputType | null
  }

  type GetPlatformSessionGroupByPayload<T extends PlatformSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformSessionGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformSessionGroupByOutputType[P]>
        }
      >
    >


  export type PlatformSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
    token?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformSession"]>

  export type PlatformSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
    token?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformSession"]>

  export type PlatformSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
    token?: boolean
    updatedAt?: boolean
  }

  export type PlatformSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlatformSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlatformSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      activeGameId: string | null
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
      refreshToken: string | null
      active: boolean
      token: string
      updatedAt: Date | null
    }, ExtArgs["result"]["platformSession"]>
    composites: {}
  }

  type PlatformSessionGetPayload<S extends boolean | null | undefined | PlatformSessionDefaultArgs> = $Result.GetResult<Prisma.$PlatformSessionPayload, S>

  type PlatformSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlatformSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlatformSessionCountAggregateInputType | true
    }

  export interface PlatformSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformSession'], meta: { name: 'PlatformSession' } }
    /**
     * Find zero or one PlatformSession that matches the filter.
     * @param {PlatformSessionFindUniqueArgs} args - Arguments to find a PlatformSession
     * @example
     * // Get one PlatformSession
     * const platformSession = await prisma.platformSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformSessionFindUniqueArgs>(args: SelectSubset<T, PlatformSessionFindUniqueArgs<ExtArgs>>): Prisma__PlatformSessionClient<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlatformSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlatformSessionFindUniqueOrThrowArgs} args - Arguments to find a PlatformSession
     * @example
     * // Get one PlatformSession
     * const platformSession = await prisma.platformSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformSessionClient<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlatformSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSessionFindFirstArgs} args - Arguments to find a PlatformSession
     * @example
     * // Get one PlatformSession
     * const platformSession = await prisma.platformSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformSessionFindFirstArgs>(args?: SelectSubset<T, PlatformSessionFindFirstArgs<ExtArgs>>): Prisma__PlatformSessionClient<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlatformSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSessionFindFirstOrThrowArgs} args - Arguments to find a PlatformSession
     * @example
     * // Get one PlatformSession
     * const platformSession = await prisma.platformSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformSessionClient<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlatformSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformSessions
     * const platformSessions = await prisma.platformSession.findMany()
     * 
     * // Get first 10 PlatformSessions
     * const platformSessions = await prisma.platformSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformSessionWithIdOnly = await prisma.platformSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformSessionFindManyArgs>(args?: SelectSubset<T, PlatformSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlatformSession.
     * @param {PlatformSessionCreateArgs} args - Arguments to create a PlatformSession.
     * @example
     * // Create one PlatformSession
     * const PlatformSession = await prisma.platformSession.create({
     *   data: {
     *     // ... data to create a PlatformSession
     *   }
     * })
     * 
     */
    create<T extends PlatformSessionCreateArgs>(args: SelectSubset<T, PlatformSessionCreateArgs<ExtArgs>>): Prisma__PlatformSessionClient<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlatformSessions.
     * @param {PlatformSessionCreateManyArgs} args - Arguments to create many PlatformSessions.
     * @example
     * // Create many PlatformSessions
     * const platformSession = await prisma.platformSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformSessionCreateManyArgs>(args?: SelectSubset<T, PlatformSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformSessions and returns the data saved in the database.
     * @param {PlatformSessionCreateManyAndReturnArgs} args - Arguments to create many PlatformSessions.
     * @example
     * // Create many PlatformSessions
     * const platformSession = await prisma.platformSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformSessions and only return the `id`
     * const platformSessionWithIdOnly = await prisma.platformSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlatformSession.
     * @param {PlatformSessionDeleteArgs} args - Arguments to delete one PlatformSession.
     * @example
     * // Delete one PlatformSession
     * const PlatformSession = await prisma.platformSession.delete({
     *   where: {
     *     // ... filter to delete one PlatformSession
     *   }
     * })
     * 
     */
    delete<T extends PlatformSessionDeleteArgs>(args: SelectSubset<T, PlatformSessionDeleteArgs<ExtArgs>>): Prisma__PlatformSessionClient<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlatformSession.
     * @param {PlatformSessionUpdateArgs} args - Arguments to update one PlatformSession.
     * @example
     * // Update one PlatformSession
     * const platformSession = await prisma.platformSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformSessionUpdateArgs>(args: SelectSubset<T, PlatformSessionUpdateArgs<ExtArgs>>): Prisma__PlatformSessionClient<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlatformSessions.
     * @param {PlatformSessionDeleteManyArgs} args - Arguments to filter PlatformSessions to delete.
     * @example
     * // Delete a few PlatformSessions
     * const { count } = await prisma.platformSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformSessionDeleteManyArgs>(args?: SelectSubset<T, PlatformSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformSessions
     * const platformSession = await prisma.platformSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformSessionUpdateManyArgs>(args: SelectSubset<T, PlatformSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlatformSession.
     * @param {PlatformSessionUpsertArgs} args - Arguments to update or create a PlatformSession.
     * @example
     * // Update or create a PlatformSession
     * const platformSession = await prisma.platformSession.upsert({
     *   create: {
     *     // ... data to create a PlatformSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformSession we want to update
     *   }
     * })
     */
    upsert<T extends PlatformSessionUpsertArgs>(args: SelectSubset<T, PlatformSessionUpsertArgs<ExtArgs>>): Prisma__PlatformSessionClient<$Result.GetResult<Prisma.$PlatformSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlatformSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSessionCountArgs} args - Arguments to filter PlatformSessions to count.
     * @example
     * // Count the number of PlatformSessions
     * const count = await prisma.platformSession.count({
     *   where: {
     *     // ... the filter for the PlatformSessions we want to count
     *   }
     * })
    **/
    count<T extends PlatformSessionCountArgs>(
      args?: Subset<T, PlatformSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformSessionAggregateArgs>(args: Subset<T, PlatformSessionAggregateArgs>): Prisma.PrismaPromise<GetPlatformSessionAggregateType<T>>

    /**
     * Group by PlatformSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformSessionGroupByArgs['orderBy'] }
        : { orderBy?: PlatformSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformSession model
   */
  readonly fields: PlatformSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformSession model
   */ 
  interface PlatformSessionFieldRefs {
    readonly id: FieldRef<"PlatformSession", 'String'>
    readonly userId: FieldRef<"PlatformSession", 'String'>
    readonly activeGameId: FieldRef<"PlatformSession", 'String'>
    readonly ipAddress: FieldRef<"PlatformSession", 'String'>
    readonly userAgent: FieldRef<"PlatformSession", 'String'>
    readonly expiresAt: FieldRef<"PlatformSession", 'DateTime'>
    readonly createdAt: FieldRef<"PlatformSession", 'DateTime'>
    readonly refreshToken: FieldRef<"PlatformSession", 'String'>
    readonly active: FieldRef<"PlatformSession", 'Boolean'>
    readonly token: FieldRef<"PlatformSession", 'String'>
    readonly updatedAt: FieldRef<"PlatformSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformSession findUnique
   */
  export type PlatformSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
    /**
     * Filter, which PlatformSession to fetch.
     */
    where: PlatformSessionWhereUniqueInput
  }

  /**
   * PlatformSession findUniqueOrThrow
   */
  export type PlatformSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
    /**
     * Filter, which PlatformSession to fetch.
     */
    where: PlatformSessionWhereUniqueInput
  }

  /**
   * PlatformSession findFirst
   */
  export type PlatformSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
    /**
     * Filter, which PlatformSession to fetch.
     */
    where?: PlatformSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSessions to fetch.
     */
    orderBy?: PlatformSessionOrderByWithRelationInput | PlatformSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformSessions.
     */
    cursor?: PlatformSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformSessions.
     */
    distinct?: PlatformSessionScalarFieldEnum | PlatformSessionScalarFieldEnum[]
  }

  /**
   * PlatformSession findFirstOrThrow
   */
  export type PlatformSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
    /**
     * Filter, which PlatformSession to fetch.
     */
    where?: PlatformSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSessions to fetch.
     */
    orderBy?: PlatformSessionOrderByWithRelationInput | PlatformSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformSessions.
     */
    cursor?: PlatformSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformSessions.
     */
    distinct?: PlatformSessionScalarFieldEnum | PlatformSessionScalarFieldEnum[]
  }

  /**
   * PlatformSession findMany
   */
  export type PlatformSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
    /**
     * Filter, which PlatformSessions to fetch.
     */
    where?: PlatformSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformSessions to fetch.
     */
    orderBy?: PlatformSessionOrderByWithRelationInput | PlatformSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformSessions.
     */
    cursor?: PlatformSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformSessions.
     */
    skip?: number
    distinct?: PlatformSessionScalarFieldEnum | PlatformSessionScalarFieldEnum[]
  }

  /**
   * PlatformSession create
   */
  export type PlatformSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformSession.
     */
    data: XOR<PlatformSessionCreateInput, PlatformSessionUncheckedCreateInput>
  }

  /**
   * PlatformSession createMany
   */
  export type PlatformSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformSessions.
     */
    data: PlatformSessionCreateManyInput | PlatformSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformSession createManyAndReturn
   */
  export type PlatformSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlatformSessions.
     */
    data: PlatformSessionCreateManyInput | PlatformSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformSession update
   */
  export type PlatformSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformSession.
     */
    data: XOR<PlatformSessionUpdateInput, PlatformSessionUncheckedUpdateInput>
    /**
     * Choose, which PlatformSession to update.
     */
    where: PlatformSessionWhereUniqueInput
  }

  /**
   * PlatformSession updateMany
   */
  export type PlatformSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformSessions.
     */
    data: XOR<PlatformSessionUpdateManyMutationInput, PlatformSessionUncheckedUpdateManyInput>
    /**
     * Filter which PlatformSessions to update
     */
    where?: PlatformSessionWhereInput
  }

  /**
   * PlatformSession upsert
   */
  export type PlatformSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformSession to update in case it exists.
     */
    where: PlatformSessionWhereUniqueInput
    /**
     * In case the PlatformSession found by the `where` argument doesn't exist, create a new PlatformSession with this data.
     */
    create: XOR<PlatformSessionCreateInput, PlatformSessionUncheckedCreateInput>
    /**
     * In case the PlatformSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformSessionUpdateInput, PlatformSessionUncheckedUpdateInput>
  }

  /**
   * PlatformSession delete
   */
  export type PlatformSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
    /**
     * Filter which PlatformSession to delete.
     */
    where: PlatformSessionWhereUniqueInput
  }

  /**
   * PlatformSession deleteMany
   */
  export type PlatformSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformSessions to delete
     */
    where?: PlatformSessionWhereInput
  }

  /**
   * PlatformSession without action
   */
  export type PlatformSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformSession
     */
    select?: PlatformSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformSessionInclude<ExtArgs> | null
  }


  /**
   * Model Operator
   */

  export type AggregateOperator = {
    _count: OperatorCountAggregateOutputType | null
    _avg: OperatorAvgAggregateOutputType | null
    _sum: OperatorSumAggregateOutputType | null
    _min: OperatorMinAggregateOutputType | null
    _max: OperatorMaxAggregateOutputType | null
  }

  export type OperatorAvgAggregateOutputType = {
    balance: number | null
  }

  export type OperatorSumAggregateOutputType = {
    balance: number | null
  }

  export type OperatorMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
    balance: number | null
  }

  export type OperatorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
    balance: number | null
  }

  export type OperatorCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logo: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    acceptedPayments: number
    ownerId: number
    balance: number
    _all: number
  }


  export type OperatorAvgAggregateInputType = {
    balance?: true
  }

  export type OperatorSumAggregateInputType = {
    balance?: true
  }

  export type OperatorMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    balance?: true
  }

  export type OperatorMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    balance?: true
  }

  export type OperatorCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    acceptedPayments?: true
    ownerId?: true
    balance?: true
    _all?: true
  }

  export type OperatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operator to aggregate.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Operators
    **/
    _count?: true | OperatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatorMaxAggregateInputType
  }

  export type GetOperatorAggregateType<T extends OperatorAggregateArgs> = {
        [P in keyof T & keyof AggregateOperator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperator[P]>
      : GetScalarType<T[P], AggregateOperator[P]>
  }




  export type OperatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorWhereInput
    orderBy?: OperatorOrderByWithAggregationInput | OperatorOrderByWithAggregationInput[]
    by: OperatorScalarFieldEnum[] | OperatorScalarFieldEnum
    having?: OperatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatorCountAggregateInputType | true
    _avg?: OperatorAvgAggregateInputType
    _sum?: OperatorSumAggregateInputType
    _min?: OperatorMinAggregateInputType
    _max?: OperatorMaxAggregateInputType
  }

  export type OperatorGroupByOutputType = {
    id: string
    name: string
    slug: string
    logo: string | null
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    acceptedPayments: string[]
    ownerId: string
    balance: number
    _count: OperatorCountAggregateOutputType | null
    _avg: OperatorAvgAggregateOutputType | null
    _sum: OperatorSumAggregateOutputType | null
    _min: OperatorMinAggregateOutputType | null
    _max: OperatorMaxAggregateOutputType | null
  }

  type GetOperatorGroupByPayload<T extends OperatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatorGroupByOutputType[P]>
            : GetScalarType<T[P], OperatorGroupByOutputType[P]>
        }
      >
    >


  export type OperatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acceptedPayments?: boolean
    ownerId?: boolean
    balance?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    profiles?: boolean | Operator$profilesArgs<ExtArgs>
    games?: boolean | Operator$gamesArgs<ExtArgs>
    products?: boolean | Operator$productsArgs<ExtArgs>
    tournaments?: boolean | Operator$tournamentsArgs<ExtArgs>
    VipInfo?: boolean | Operator$VipInfoArgs<ExtArgs>
    _count?: boolean | OperatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operator"]>

  export type OperatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acceptedPayments?: boolean
    ownerId?: boolean
    balance?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operator"]>

  export type OperatorSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acceptedPayments?: boolean
    ownerId?: boolean
    balance?: boolean
  }

  export type OperatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    profiles?: boolean | Operator$profilesArgs<ExtArgs>
    games?: boolean | Operator$gamesArgs<ExtArgs>
    products?: boolean | Operator$productsArgs<ExtArgs>
    tournaments?: boolean | Operator$tournamentsArgs<ExtArgs>
    VipInfo?: boolean | Operator$VipInfoArgs<ExtArgs>
    _count?: boolean | OperatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OperatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OperatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Operator"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      profiles: Prisma.$ProfilePayload<ExtArgs>[]
      games: Prisma.$GamePayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      tournaments: Prisma.$TournamentPayload<ExtArgs>[]
      VipInfo: Prisma.$VipInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      logo: string | null
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
      acceptedPayments: string[]
      ownerId: string
      balance: number
    }, ExtArgs["result"]["operator"]>
    composites: {}
  }

  type OperatorGetPayload<S extends boolean | null | undefined | OperatorDefaultArgs> = $Result.GetResult<Prisma.$OperatorPayload, S>

  type OperatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperatorCountAggregateInputType | true
    }

  export interface OperatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Operator'], meta: { name: 'Operator' } }
    /**
     * Find zero or one Operator that matches the filter.
     * @param {OperatorFindUniqueArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperatorFindUniqueArgs>(args: SelectSubset<T, OperatorFindUniqueArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Operator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperatorFindUniqueOrThrowArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperatorFindUniqueOrThrowArgs>(args: SelectSubset<T, OperatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Operator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindFirstArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperatorFindFirstArgs>(args?: SelectSubset<T, OperatorFindFirstArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Operator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindFirstOrThrowArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperatorFindFirstOrThrowArgs>(args?: SelectSubset<T, OperatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Operators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operators
     * const operators = await prisma.operator.findMany()
     * 
     * // Get first 10 Operators
     * const operators = await prisma.operator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatorWithIdOnly = await prisma.operator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperatorFindManyArgs>(args?: SelectSubset<T, OperatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Operator.
     * @param {OperatorCreateArgs} args - Arguments to create a Operator.
     * @example
     * // Create one Operator
     * const Operator = await prisma.operator.create({
     *   data: {
     *     // ... data to create a Operator
     *   }
     * })
     * 
     */
    create<T extends OperatorCreateArgs>(args: SelectSubset<T, OperatorCreateArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Operators.
     * @param {OperatorCreateManyArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operator = await prisma.operator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperatorCreateManyArgs>(args?: SelectSubset<T, OperatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operators and returns the data saved in the database.
     * @param {OperatorCreateManyAndReturnArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operator = await prisma.operator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operators and only return the `id`
     * const operatorWithIdOnly = await prisma.operator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperatorCreateManyAndReturnArgs>(args?: SelectSubset<T, OperatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Operator.
     * @param {OperatorDeleteArgs} args - Arguments to delete one Operator.
     * @example
     * // Delete one Operator
     * const Operator = await prisma.operator.delete({
     *   where: {
     *     // ... filter to delete one Operator
     *   }
     * })
     * 
     */
    delete<T extends OperatorDeleteArgs>(args: SelectSubset<T, OperatorDeleteArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Operator.
     * @param {OperatorUpdateArgs} args - Arguments to update one Operator.
     * @example
     * // Update one Operator
     * const operator = await prisma.operator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperatorUpdateArgs>(args: SelectSubset<T, OperatorUpdateArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Operators.
     * @param {OperatorDeleteManyArgs} args - Arguments to filter Operators to delete.
     * @example
     * // Delete a few Operators
     * const { count } = await prisma.operator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperatorDeleteManyArgs>(args?: SelectSubset<T, OperatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operators
     * const operator = await prisma.operator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperatorUpdateManyArgs>(args: SelectSubset<T, OperatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operator.
     * @param {OperatorUpsertArgs} args - Arguments to update or create a Operator.
     * @example
     * // Update or create a Operator
     * const operator = await prisma.operator.upsert({
     *   create: {
     *     // ... data to create a Operator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operator we want to update
     *   }
     * })
     */
    upsert<T extends OperatorUpsertArgs>(args: SelectSubset<T, OperatorUpsertArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCountArgs} args - Arguments to filter Operators to count.
     * @example
     * // Count the number of Operators
     * const count = await prisma.operator.count({
     *   where: {
     *     // ... the filter for the Operators we want to count
     *   }
     * })
    **/
    count<T extends OperatorCountArgs>(
      args?: Subset<T, OperatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatorAggregateArgs>(args: Subset<T, OperatorAggregateArgs>): Prisma.PrismaPromise<GetOperatorAggregateType<T>>

    /**
     * Group by Operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperatorGroupByArgs['orderBy'] }
        : { orderBy?: OperatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Operator model
   */
  readonly fields: OperatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Operator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profiles<T extends Operator$profilesArgs<ExtArgs> = {}>(args?: Subset<T, Operator$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany"> | Null>
    games<T extends Operator$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Operator$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Operator$productsArgs<ExtArgs> = {}>(args?: Subset<T, Operator$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    tournaments<T extends Operator$tournamentsArgs<ExtArgs> = {}>(args?: Subset<T, Operator$tournamentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findMany"> | Null>
    VipInfo<T extends Operator$VipInfoArgs<ExtArgs> = {}>(args?: Subset<T, Operator$VipInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Operator model
   */ 
  interface OperatorFieldRefs {
    readonly id: FieldRef<"Operator", 'String'>
    readonly name: FieldRef<"Operator", 'String'>
    readonly slug: FieldRef<"Operator", 'String'>
    readonly logo: FieldRef<"Operator", 'String'>
    readonly description: FieldRef<"Operator", 'String'>
    readonly isActive: FieldRef<"Operator", 'Boolean'>
    readonly createdAt: FieldRef<"Operator", 'DateTime'>
    readonly updatedAt: FieldRef<"Operator", 'DateTime'>
    readonly acceptedPayments: FieldRef<"Operator", 'String[]'>
    readonly ownerId: FieldRef<"Operator", 'String'>
    readonly balance: FieldRef<"Operator", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Operator findUnique
   */
  export type OperatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator findUniqueOrThrow
   */
  export type OperatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator findFirst
   */
  export type OperatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operators.
     */
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator findFirstOrThrow
   */
  export type OperatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operators.
     */
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator findMany
   */
  export type OperatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operators to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator create
   */
  export type OperatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Operator.
     */
    data: XOR<OperatorCreateInput, OperatorUncheckedCreateInput>
  }

  /**
   * Operator createMany
   */
  export type OperatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Operators.
     */
    data: OperatorCreateManyInput | OperatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Operator createManyAndReturn
   */
  export type OperatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Operators.
     */
    data: OperatorCreateManyInput | OperatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Operator update
   */
  export type OperatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Operator.
     */
    data: XOR<OperatorUpdateInput, OperatorUncheckedUpdateInput>
    /**
     * Choose, which Operator to update.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator updateMany
   */
  export type OperatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Operators.
     */
    data: XOR<OperatorUpdateManyMutationInput, OperatorUncheckedUpdateManyInput>
    /**
     * Filter which Operators to update
     */
    where?: OperatorWhereInput
  }

  /**
   * Operator upsert
   */
  export type OperatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Operator to update in case it exists.
     */
    where: OperatorWhereUniqueInput
    /**
     * In case the Operator found by the `where` argument doesn't exist, create a new Operator with this data.
     */
    create: XOR<OperatorCreateInput, OperatorUncheckedCreateInput>
    /**
     * In case the Operator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperatorUpdateInput, OperatorUncheckedUpdateInput>
  }

  /**
   * Operator delete
   */
  export type OperatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter which Operator to delete.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator deleteMany
   */
  export type OperatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operators to delete
     */
    where?: OperatorWhereInput
  }

  /**
   * Operator.profiles
   */
  export type Operator$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Operator.games
   */
  export type Operator$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Operator.products
   */
  export type Operator$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Operator.tournaments
   */
  export type Operator$tournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    where?: TournamentWhereInput
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    cursor?: TournamentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Operator.VipInfo
   */
  export type Operator$VipInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    where?: VipInfoWhereInput
    orderBy?: VipInfoOrderByWithRelationInput | VipInfoOrderByWithRelationInput[]
    cursor?: VipInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VipInfoScalarFieldEnum | VipInfoScalarFieldEnum[]
  }

  /**
   * Operator without action
   */
  export type OperatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    authorId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string | null
    createdAt: Date
    updatedAt: Date | null
    authorId: string | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }


  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string | null
      createdAt: Date
      updatedAt: Date | null
      authorId: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly authorId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data?: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    balance: number | null
    xpEarned: number | null
    phpId: number | null
  }

  export type ProfileSumAggregateOutputType = {
    balance: number | null
    xpEarned: number | null
    phpId: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    balance: number | null
    xpEarned: number | null
    isActive: boolean | null
    lastPlayed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    phpId: number | null
    userId: string | null
    currency: string | null
    shopId: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    balance: number | null
    xpEarned: number | null
    isActive: boolean | null
    lastPlayed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    phpId: number | null
    userId: string | null
    currency: string | null
    shopId: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    balance: number
    xpEarned: number
    isActive: number
    lastPlayed: number
    createdAt: number
    updatedAt: number
    phpId: number
    userId: number
    currency: number
    shopId: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    balance?: true
    xpEarned?: true
    phpId?: true
  }

  export type ProfileSumAggregateInputType = {
    balance?: true
    xpEarned?: true
    phpId?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    balance?: true
    xpEarned?: true
    isActive?: true
    lastPlayed?: true
    createdAt?: true
    updatedAt?: true
    phpId?: true
    userId?: true
    currency?: true
    shopId?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    balance?: true
    xpEarned?: true
    isActive?: true
    lastPlayed?: true
    createdAt?: true
    updatedAt?: true
    phpId?: true
    userId?: true
    currency?: true
    shopId?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    balance?: true
    xpEarned?: true
    isActive?: true
    lastPlayed?: true
    createdAt?: true
    updatedAt?: true
    phpId?: true
    userId?: true
    currency?: true
    shopId?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    balance: number
    xpEarned: number
    isActive: boolean
    lastPlayed: Date | null
    createdAt: Date
    updatedAt: Date | null
    phpId: number | null
    userId: string
    currency: string
    shopId: string
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    currency?: boolean
    shopId?: boolean
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    userProfileUseridtouser?: boolean | UserDefaultArgs<ExtArgs>
    gamesession?: boolean | Profile$gamesessionArgs<ExtArgs>
    tournamententry?: boolean | Profile$tournamententryArgs<ExtArgs>
    transactions?: boolean | Profile$transactionsArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    currency?: boolean
    shopId?: boolean
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    userProfileUseridtouser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    currency?: boolean
    shopId?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    userProfileUseridtouser?: boolean | UserDefaultArgs<ExtArgs>
    gamesession?: boolean | Profile$gamesessionArgs<ExtArgs>
    tournamententry?: boolean | Profile$tournamententryArgs<ExtArgs>
    transactions?: boolean | Profile$transactionsArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    userProfileUseridtouser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      operator: Prisma.$OperatorPayload<ExtArgs>
      userProfileUseridtouser: Prisma.$UserPayload<ExtArgs>
      gamesession: Prisma.$GamesessionPayload<ExtArgs>[]
      tournamententry: Prisma.$TournamententryPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      balance: number
      xpEarned: number
      isActive: boolean
      lastPlayed: Date | null
      createdAt: Date
      updatedAt: Date | null
      phpId: number | null
      userId: string
      currency: string
      shopId: string
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operator<T extends OperatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperatorDefaultArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userProfileUseridtouser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    gamesession<T extends Profile$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, Profile$gamesessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findMany"> | Null>
    tournamententry<T extends Profile$tournamententryArgs<ExtArgs> = {}>(args?: Subset<T, Profile$tournamententryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Profile$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly balance: FieldRef<"Profile", 'Int'>
    readonly xpEarned: FieldRef<"Profile", 'Int'>
    readonly isActive: FieldRef<"Profile", 'Boolean'>
    readonly lastPlayed: FieldRef<"Profile", 'DateTime'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
    readonly phpId: FieldRef<"Profile", 'Int'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly currency: FieldRef<"Profile", 'String'>
    readonly shopId: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile.gamesession
   */
  export type Profile$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    where?: GamesessionWhereInput
    orderBy?: GamesessionOrderByWithRelationInput | GamesessionOrderByWithRelationInput[]
    cursor?: GamesessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * Profile.tournamententry
   */
  export type Profile$tournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    where?: TournamententryWhereInput
    orderBy?: TournamententryOrderByWithRelationInput | TournamententryOrderByWithRelationInput[]
    cursor?: TournamententryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * Profile.transactions
   */
  export type Profile$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    vipLevel: number | null
    device: number | null
    bet: number | null
    denomination: number | null
    categoryTemp: number | null
    originalId: number | null
    bids: number | null
    statIn: number | null
    statOut: number | null
    currentRtp: number | null
    rtpStatIn: number | null
    rtpStatOut: number | null
    standardRtp: number | null
    popularity: number | null
    chanceFirepot1: number | null
    chanceFirepot2: number | null
    chanceFirepot3: number | null
    fireCount1: number | null
    fireCount2: number | null
    fireCount3: number | null
    rezerv: number | null
    cask: number | null
    view: number | null
  }

  export type GameSumAggregateOutputType = {
    vipLevel: number | null
    device: number | null
    bet: number | null
    denomination: number | null
    categoryTemp: number | null
    originalId: number | null
    bids: number | null
    statIn: number | null
    statOut: number | null
    currentRtp: number | null
    rtpStatIn: number | null
    rtpStatOut: number | null
    standardRtp: number | null
    popularity: number | null
    chanceFirepot1: number | null
    chanceFirepot2: number | null
    chanceFirepot3: number | null
    fireCount1: number | null
    fireCount2: number | null
    fireCount3: number | null
    rezerv: number | null
    cask: number | null
    view: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    temperature: string | null
    developer: string | null
    vipLevel: number | null
    isActive: boolean | null
    device: number | null
    featured: boolean | null
    gamebank: string | null
    bet: number | null
    denomination: number | null
    categoryTemp: number | null
    originalId: number | null
    bids: number | null
    statIn: number | null
    statOut: number | null
    currentRtp: number | null
    rtpStatIn: number | null
    rtpStatOut: number | null
    standardRtp: number | null
    popularity: number | null
    chanceFirepot1: number | null
    chanceFirepot2: number | null
    chanceFirepot3: number | null
    fireCount1: number | null
    fireCount2: number | null
    fireCount3: number | null
    linesPercentConfigSpin: string | null
    linesPercentConfigSpinBonus: string | null
    linesPercentConfigBonus: string | null
    linesPercentConfigBonusBonus: string | null
    rezerv: number | null
    cask: number | null
    advanced: string | null
    scaleMode: string | null
    slotViewState: string | null
    view: number | null
    categoryId: string | null
    operatorId: string | null
    providerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    jackpotGroupId: string | null
    active: boolean | null
    password: string | null
    category: $Enums.GameCategory | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    temperature: string | null
    developer: string | null
    vipLevel: number | null
    isActive: boolean | null
    device: number | null
    featured: boolean | null
    gamebank: string | null
    bet: number | null
    denomination: number | null
    categoryTemp: number | null
    originalId: number | null
    bids: number | null
    statIn: number | null
    statOut: number | null
    currentRtp: number | null
    rtpStatIn: number | null
    rtpStatOut: number | null
    standardRtp: number | null
    popularity: number | null
    chanceFirepot1: number | null
    chanceFirepot2: number | null
    chanceFirepot3: number | null
    fireCount1: number | null
    fireCount2: number | null
    fireCount3: number | null
    linesPercentConfigSpin: string | null
    linesPercentConfigSpinBonus: string | null
    linesPercentConfigBonus: string | null
    linesPercentConfigBonusBonus: string | null
    rezerv: number | null
    cask: number | null
    advanced: string | null
    scaleMode: string | null
    slotViewState: string | null
    view: number | null
    categoryId: string | null
    operatorId: string | null
    providerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    jackpotGroupId: string | null
    active: boolean | null
    password: string | null
    category: $Enums.GameCategory | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    name: number
    title: number
    temperature: number
    developer: number
    vipLevel: number
    isActive: number
    device: number
    featured: number
    gamebank: number
    bet: number
    denomination: number
    categoryTemp: number
    originalId: number
    bids: number
    statIn: number
    statOut: number
    currentRtp: number
    rtpStatIn: number
    rtpStatOut: number
    standardRtp: number
    popularity: number
    chanceFirepot1: number
    chanceFirepot2: number
    chanceFirepot3: number
    fireCount1: number
    fireCount2: number
    fireCount3: number
    linesPercentConfigSpin: number
    linesPercentConfigSpinBonus: number
    linesPercentConfigBonus: number
    linesPercentConfigBonusBonus: number
    rezerv: number
    cask: number
    advanced: number
    scaleMode: number
    slotViewState: number
    view: number
    categoryId: number
    operatorId: number
    providerId: number
    createdAt: number
    updatedAt: number
    jackpotGroupId: number
    active: number
    password: number
    category: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    vipLevel?: true
    device?: true
    bet?: true
    denomination?: true
    categoryTemp?: true
    originalId?: true
    bids?: true
    statIn?: true
    statOut?: true
    currentRtp?: true
    rtpStatIn?: true
    rtpStatOut?: true
    standardRtp?: true
    popularity?: true
    chanceFirepot1?: true
    chanceFirepot2?: true
    chanceFirepot3?: true
    fireCount1?: true
    fireCount2?: true
    fireCount3?: true
    rezerv?: true
    cask?: true
    view?: true
  }

  export type GameSumAggregateInputType = {
    vipLevel?: true
    device?: true
    bet?: true
    denomination?: true
    categoryTemp?: true
    originalId?: true
    bids?: true
    statIn?: true
    statOut?: true
    currentRtp?: true
    rtpStatIn?: true
    rtpStatOut?: true
    standardRtp?: true
    popularity?: true
    chanceFirepot1?: true
    chanceFirepot2?: true
    chanceFirepot3?: true
    fireCount1?: true
    fireCount2?: true
    fireCount3?: true
    rezerv?: true
    cask?: true
    view?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    name?: true
    title?: true
    temperature?: true
    developer?: true
    vipLevel?: true
    isActive?: true
    device?: true
    featured?: true
    gamebank?: true
    bet?: true
    denomination?: true
    categoryTemp?: true
    originalId?: true
    bids?: true
    statIn?: true
    statOut?: true
    currentRtp?: true
    rtpStatIn?: true
    rtpStatOut?: true
    standardRtp?: true
    popularity?: true
    chanceFirepot1?: true
    chanceFirepot2?: true
    chanceFirepot3?: true
    fireCount1?: true
    fireCount2?: true
    fireCount3?: true
    linesPercentConfigSpin?: true
    linesPercentConfigSpinBonus?: true
    linesPercentConfigBonus?: true
    linesPercentConfigBonusBonus?: true
    rezerv?: true
    cask?: true
    advanced?: true
    scaleMode?: true
    slotViewState?: true
    view?: true
    categoryId?: true
    operatorId?: true
    providerId?: true
    createdAt?: true
    updatedAt?: true
    jackpotGroupId?: true
    active?: true
    password?: true
    category?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    name?: true
    title?: true
    temperature?: true
    developer?: true
    vipLevel?: true
    isActive?: true
    device?: true
    featured?: true
    gamebank?: true
    bet?: true
    denomination?: true
    categoryTemp?: true
    originalId?: true
    bids?: true
    statIn?: true
    statOut?: true
    currentRtp?: true
    rtpStatIn?: true
    rtpStatOut?: true
    standardRtp?: true
    popularity?: true
    chanceFirepot1?: true
    chanceFirepot2?: true
    chanceFirepot3?: true
    fireCount1?: true
    fireCount2?: true
    fireCount3?: true
    linesPercentConfigSpin?: true
    linesPercentConfigSpinBonus?: true
    linesPercentConfigBonus?: true
    linesPercentConfigBonusBonus?: true
    rezerv?: true
    cask?: true
    advanced?: true
    scaleMode?: true
    slotViewState?: true
    view?: true
    categoryId?: true
    operatorId?: true
    providerId?: true
    createdAt?: true
    updatedAt?: true
    jackpotGroupId?: true
    active?: true
    password?: true
    category?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    name?: true
    title?: true
    temperature?: true
    developer?: true
    vipLevel?: true
    isActive?: true
    device?: true
    featured?: true
    gamebank?: true
    bet?: true
    denomination?: true
    categoryTemp?: true
    originalId?: true
    bids?: true
    statIn?: true
    statOut?: true
    currentRtp?: true
    rtpStatIn?: true
    rtpStatOut?: true
    standardRtp?: true
    popularity?: true
    chanceFirepot1?: true
    chanceFirepot2?: true
    chanceFirepot3?: true
    fireCount1?: true
    fireCount2?: true
    fireCount3?: true
    linesPercentConfigSpin?: true
    linesPercentConfigSpinBonus?: true
    linesPercentConfigBonus?: true
    linesPercentConfigBonusBonus?: true
    rezerv?: true
    cask?: true
    advanced?: true
    scaleMode?: true
    slotViewState?: true
    view?: true
    categoryId?: true
    operatorId?: true
    providerId?: true
    createdAt?: true
    updatedAt?: true
    jackpotGroupId?: true
    active?: true
    password?: true
    category?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    name: string
    title: string
    temperature: string | null
    developer: string | null
    vipLevel: number | null
    isActive: boolean | null
    device: number | null
    featured: boolean | null
    gamebank: string | null
    bet: number | null
    denomination: number | null
    categoryTemp: number | null
    originalId: number | null
    bids: number | null
    statIn: number | null
    statOut: number | null
    currentRtp: number | null
    rtpStatIn: number | null
    rtpStatOut: number | null
    standardRtp: number | null
    popularity: number | null
    chanceFirepot1: number | null
    chanceFirepot2: number | null
    chanceFirepot3: number | null
    fireCount1: number | null
    fireCount2: number | null
    fireCount3: number | null
    linesPercentConfigSpin: string | null
    linesPercentConfigSpinBonus: string | null
    linesPercentConfigBonus: string | null
    linesPercentConfigBonusBonus: string | null
    rezerv: number | null
    cask: number | null
    advanced: string | null
    scaleMode: string
    slotViewState: string
    view: number | null
    categoryId: string | null
    operatorId: string | null
    providerId: string | null
    createdAt: Date
    updatedAt: Date | null
    jackpotGroupId: string | null
    active: boolean
    password: string | null
    category: $Enums.GameCategory
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    temperature?: boolean
    developer?: boolean
    vipLevel?: boolean
    isActive?: boolean
    device?: boolean
    featured?: boolean
    gamebank?: boolean
    bet?: boolean
    denomination?: boolean
    categoryTemp?: boolean
    originalId?: boolean
    bids?: boolean
    statIn?: boolean
    statOut?: boolean
    currentRtp?: boolean
    rtpStatIn?: boolean
    rtpStatOut?: boolean
    standardRtp?: boolean
    popularity?: boolean
    chanceFirepot1?: boolean
    chanceFirepot2?: boolean
    chanceFirepot3?: boolean
    fireCount1?: boolean
    fireCount2?: boolean
    fireCount3?: boolean
    linesPercentConfigSpin?: boolean
    linesPercentConfigSpinBonus?: boolean
    linesPercentConfigBonus?: boolean
    linesPercentConfigBonusBonus?: boolean
    rezerv?: boolean
    cask?: boolean
    advanced?: boolean
    scaleMode?: boolean
    slotViewState?: boolean
    view?: boolean
    categoryId?: boolean
    operatorId?: boolean
    providerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jackpotGroupId?: boolean
    active?: boolean
    password?: boolean
    category?: boolean
    operator?: boolean | Game$operatorArgs<ExtArgs>
    gamesession?: boolean | Game$gamesessionArgs<ExtArgs>
    tournamentgame?: boolean | Game$tournamentgameArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    temperature?: boolean
    developer?: boolean
    vipLevel?: boolean
    isActive?: boolean
    device?: boolean
    featured?: boolean
    gamebank?: boolean
    bet?: boolean
    denomination?: boolean
    categoryTemp?: boolean
    originalId?: boolean
    bids?: boolean
    statIn?: boolean
    statOut?: boolean
    currentRtp?: boolean
    rtpStatIn?: boolean
    rtpStatOut?: boolean
    standardRtp?: boolean
    popularity?: boolean
    chanceFirepot1?: boolean
    chanceFirepot2?: boolean
    chanceFirepot3?: boolean
    fireCount1?: boolean
    fireCount2?: boolean
    fireCount3?: boolean
    linesPercentConfigSpin?: boolean
    linesPercentConfigSpinBonus?: boolean
    linesPercentConfigBonus?: boolean
    linesPercentConfigBonusBonus?: boolean
    rezerv?: boolean
    cask?: boolean
    advanced?: boolean
    scaleMode?: boolean
    slotViewState?: boolean
    view?: boolean
    categoryId?: boolean
    operatorId?: boolean
    providerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jackpotGroupId?: boolean
    active?: boolean
    password?: boolean
    category?: boolean
    operator?: boolean | Game$operatorArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    name?: boolean
    title?: boolean
    temperature?: boolean
    developer?: boolean
    vipLevel?: boolean
    isActive?: boolean
    device?: boolean
    featured?: boolean
    gamebank?: boolean
    bet?: boolean
    denomination?: boolean
    categoryTemp?: boolean
    originalId?: boolean
    bids?: boolean
    statIn?: boolean
    statOut?: boolean
    currentRtp?: boolean
    rtpStatIn?: boolean
    rtpStatOut?: boolean
    standardRtp?: boolean
    popularity?: boolean
    chanceFirepot1?: boolean
    chanceFirepot2?: boolean
    chanceFirepot3?: boolean
    fireCount1?: boolean
    fireCount2?: boolean
    fireCount3?: boolean
    linesPercentConfigSpin?: boolean
    linesPercentConfigSpinBonus?: boolean
    linesPercentConfigBonus?: boolean
    linesPercentConfigBonusBonus?: boolean
    rezerv?: boolean
    cask?: boolean
    advanced?: boolean
    scaleMode?: boolean
    slotViewState?: boolean
    view?: boolean
    categoryId?: boolean
    operatorId?: boolean
    providerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jackpotGroupId?: boolean
    active?: boolean
    password?: boolean
    category?: boolean
  }

  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | Game$operatorArgs<ExtArgs>
    gamesession?: boolean | Game$gamesessionArgs<ExtArgs>
    tournamentgame?: boolean | Game$tournamentgameArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | Game$operatorArgs<ExtArgs>
  }

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      operator: Prisma.$OperatorPayload<ExtArgs> | null
      gamesession: Prisma.$GamesessionPayload<ExtArgs>[]
      tournamentgame: Prisma.$TournamentgamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      title: string
      temperature: string | null
      developer: string | null
      vipLevel: number | null
      isActive: boolean | null
      device: number | null
      featured: boolean | null
      gamebank: string | null
      bet: number | null
      denomination: number | null
      categoryTemp: number | null
      originalId: number | null
      bids: number | null
      statIn: number | null
      statOut: number | null
      currentRtp: number | null
      rtpStatIn: number | null
      rtpStatOut: number | null
      standardRtp: number | null
      popularity: number | null
      chanceFirepot1: number | null
      chanceFirepot2: number | null
      chanceFirepot3: number | null
      fireCount1: number | null
      fireCount2: number | null
      fireCount3: number | null
      linesPercentConfigSpin: string | null
      linesPercentConfigSpinBonus: string | null
      linesPercentConfigBonus: string | null
      linesPercentConfigBonusBonus: string | null
      rezerv: number | null
      cask: number | null
      advanced: string | null
      scaleMode: string
      slotViewState: string
      view: number | null
      categoryId: string | null
      operatorId: string | null
      providerId: string | null
      createdAt: Date
      updatedAt: Date | null
      jackpotGroupId: string | null
      active: boolean
      password: string | null
      category: $Enums.GameCategory
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operator<T extends Game$operatorArgs<ExtArgs> = {}>(args?: Subset<T, Game$operatorArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    gamesession<T extends Game$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, Game$gamesessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findMany"> | Null>
    tournamentgame<T extends Game$tournamentgameArgs<ExtArgs> = {}>(args?: Subset<T, Game$tournamentgameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */ 
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly name: FieldRef<"Game", 'String'>
    readonly title: FieldRef<"Game", 'String'>
    readonly temperature: FieldRef<"Game", 'String'>
    readonly developer: FieldRef<"Game", 'String'>
    readonly vipLevel: FieldRef<"Game", 'Int'>
    readonly isActive: FieldRef<"Game", 'Boolean'>
    readonly device: FieldRef<"Game", 'Int'>
    readonly featured: FieldRef<"Game", 'Boolean'>
    readonly gamebank: FieldRef<"Game", 'String'>
    readonly bet: FieldRef<"Game", 'Float'>
    readonly denomination: FieldRef<"Game", 'Float'>
    readonly categoryTemp: FieldRef<"Game", 'Float'>
    readonly originalId: FieldRef<"Game", 'Int'>
    readonly bids: FieldRef<"Game", 'Int'>
    readonly statIn: FieldRef<"Game", 'Float'>
    readonly statOut: FieldRef<"Game", 'Float'>
    readonly currentRtp: FieldRef<"Game", 'Float'>
    readonly rtpStatIn: FieldRef<"Game", 'Float'>
    readonly rtpStatOut: FieldRef<"Game", 'Float'>
    readonly standardRtp: FieldRef<"Game", 'Float'>
    readonly popularity: FieldRef<"Game", 'Float'>
    readonly chanceFirepot1: FieldRef<"Game", 'Float'>
    readonly chanceFirepot2: FieldRef<"Game", 'Float'>
    readonly chanceFirepot3: FieldRef<"Game", 'Float'>
    readonly fireCount1: FieldRef<"Game", 'Float'>
    readonly fireCount2: FieldRef<"Game", 'Float'>
    readonly fireCount3: FieldRef<"Game", 'Float'>
    readonly linesPercentConfigSpin: FieldRef<"Game", 'String'>
    readonly linesPercentConfigSpinBonus: FieldRef<"Game", 'String'>
    readonly linesPercentConfigBonus: FieldRef<"Game", 'String'>
    readonly linesPercentConfigBonusBonus: FieldRef<"Game", 'String'>
    readonly rezerv: FieldRef<"Game", 'Float'>
    readonly cask: FieldRef<"Game", 'Float'>
    readonly advanced: FieldRef<"Game", 'String'>
    readonly scaleMode: FieldRef<"Game", 'String'>
    readonly slotViewState: FieldRef<"Game", 'String'>
    readonly view: FieldRef<"Game", 'Int'>
    readonly categoryId: FieldRef<"Game", 'String'>
    readonly operatorId: FieldRef<"Game", 'String'>
    readonly providerId: FieldRef<"Game", 'String'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
    readonly updatedAt: FieldRef<"Game", 'DateTime'>
    readonly jackpotGroupId: FieldRef<"Game", 'String'>
    readonly active: FieldRef<"Game", 'Boolean'>
    readonly password: FieldRef<"Game", 'String'>
    readonly category: FieldRef<"Game", 'GameCategory'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
  }

  /**
   * Game.operator
   */
  export type Game$operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    where?: OperatorWhereInput
  }

  /**
   * Game.gamesession
   */
  export type Game$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    where?: GamesessionWhereInput
    orderBy?: GamesessionOrderByWithRelationInput | GamesessionOrderByWithRelationInput[]
    cursor?: GamesessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * Game.tournamentgame
   */
  export type Game$tournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    where?: TournamentgameWhereInput
    orderBy?: TournamentgameOrderByWithRelationInput | TournamentgameOrderByWithRelationInput[]
    cursor?: TournamentgameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model Operatorgame
   */

  export type AggregateOperatorgame = {
    _count: OperatorgameCountAggregateOutputType | null
    _avg: OperatorgameAvgAggregateOutputType | null
    _sum: OperatorgameSumAggregateOutputType | null
    _min: OperatorgameMinAggregateOutputType | null
    _max: OperatorgameMaxAggregateOutputType | null
  }

  export type OperatorgameAvgAggregateOutputType = {
    minBet: number | null
    maxBet: number | null
    xpMultiplier: number | null
  }

  export type OperatorgameSumAggregateOutputType = {
    minBet: number | null
    maxBet: number | null
    xpMultiplier: number | null
  }

  export type OperatorgameMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    thumbnail: string | null
    minBet: number | null
    maxBet: number | null
    xpMultiplier: number | null
    isActive: boolean | null
    isPromoted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type OperatorgameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    thumbnail: string | null
    minBet: number | null
    maxBet: number | null
    xpMultiplier: number | null
    isActive: boolean | null
    isPromoted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type OperatorgameCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    thumbnail: number
    minBet: number
    maxBet: number
    xpMultiplier: number
    isActive: number
    isPromoted: number
    createdAt: number
    updatedAt: number
    operatorId: number
    _all: number
  }


  export type OperatorgameAvgAggregateInputType = {
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
  }

  export type OperatorgameSumAggregateInputType = {
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
  }

  export type OperatorgameMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    thumbnail?: true
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
    isActive?: true
    isPromoted?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type OperatorgameMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    thumbnail?: true
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
    isActive?: true
    isPromoted?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type OperatorgameCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    thumbnail?: true
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
    isActive?: true
    isPromoted?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
    _all?: true
  }

  export type OperatorgameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operatorgame to aggregate.
     */
    where?: OperatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operatorgames to fetch.
     */
    orderBy?: OperatorgameOrderByWithRelationInput | OperatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operatorgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Operatorgames
    **/
    _count?: true | OperatorgameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperatorgameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperatorgameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatorgameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatorgameMaxAggregateInputType
  }

  export type GetOperatorgameAggregateType<T extends OperatorgameAggregateArgs> = {
        [P in keyof T & keyof AggregateOperatorgame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperatorgame[P]>
      : GetScalarType<T[P], AggregateOperatorgame[P]>
  }




  export type OperatorgameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorgameWhereInput
    orderBy?: OperatorgameOrderByWithAggregationInput | OperatorgameOrderByWithAggregationInput[]
    by: OperatorgameScalarFieldEnum[] | OperatorgameScalarFieldEnum
    having?: OperatorgameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatorgameCountAggregateInputType | true
    _avg?: OperatorgameAvgAggregateInputType
    _sum?: OperatorgameSumAggregateInputType
    _min?: OperatorgameMinAggregateInputType
    _max?: OperatorgameMaxAggregateInputType
  }

  export type OperatorgameGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    thumbnail: string | null
    minBet: number | null
    maxBet: number | null
    xpMultiplier: number
    isActive: boolean
    isPromoted: boolean
    createdAt: Date
    updatedAt: Date | null
    operatorId: string
    _count: OperatorgameCountAggregateOutputType | null
    _avg: OperatorgameAvgAggregateOutputType | null
    _sum: OperatorgameSumAggregateOutputType | null
    _min: OperatorgameMinAggregateOutputType | null
    _max: OperatorgameMaxAggregateOutputType | null
  }

  type GetOperatorgameGroupByPayload<T extends OperatorgameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatorgameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatorgameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatorgameGroupByOutputType[P]>
            : GetScalarType<T[P], OperatorgameGroupByOutputType[P]>
        }
      >
    >


  export type OperatorgameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
  }, ExtArgs["result"]["operatorgame"]>

  export type OperatorgameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
  }, ExtArgs["result"]["operatorgame"]>

  export type OperatorgameSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
  }


  export type $OperatorgamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Operatorgame"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      thumbnail: string | null
      minBet: number | null
      maxBet: number | null
      xpMultiplier: number
      isActive: boolean
      isPromoted: boolean
      createdAt: Date
      updatedAt: Date | null
      operatorId: string
    }, ExtArgs["result"]["operatorgame"]>
    composites: {}
  }

  type OperatorgameGetPayload<S extends boolean | null | undefined | OperatorgameDefaultArgs> = $Result.GetResult<Prisma.$OperatorgamePayload, S>

  type OperatorgameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperatorgameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperatorgameCountAggregateInputType | true
    }

  export interface OperatorgameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Operatorgame'], meta: { name: 'Operatorgame' } }
    /**
     * Find zero or one Operatorgame that matches the filter.
     * @param {OperatorgameFindUniqueArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperatorgameFindUniqueArgs>(args: SelectSubset<T, OperatorgameFindUniqueArgs<ExtArgs>>): Prisma__OperatorgameClient<$Result.GetResult<Prisma.$OperatorgamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Operatorgame that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperatorgameFindUniqueOrThrowArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperatorgameFindUniqueOrThrowArgs>(args: SelectSubset<T, OperatorgameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperatorgameClient<$Result.GetResult<Prisma.$OperatorgamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Operatorgame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorgameFindFirstArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperatorgameFindFirstArgs>(args?: SelectSubset<T, OperatorgameFindFirstArgs<ExtArgs>>): Prisma__OperatorgameClient<$Result.GetResult<Prisma.$OperatorgamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Operatorgame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorgameFindFirstOrThrowArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperatorgameFindFirstOrThrowArgs>(args?: SelectSubset<T, OperatorgameFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperatorgameClient<$Result.GetResult<Prisma.$OperatorgamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Operatorgames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorgameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operatorgames
     * const operatorgames = await prisma.operatorgame.findMany()
     * 
     * // Get first 10 Operatorgames
     * const operatorgames = await prisma.operatorgame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatorgameWithIdOnly = await prisma.operatorgame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperatorgameFindManyArgs>(args?: SelectSubset<T, OperatorgameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorgamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Operatorgame.
     * @param {OperatorgameCreateArgs} args - Arguments to create a Operatorgame.
     * @example
     * // Create one Operatorgame
     * const Operatorgame = await prisma.operatorgame.create({
     *   data: {
     *     // ... data to create a Operatorgame
     *   }
     * })
     * 
     */
    create<T extends OperatorgameCreateArgs>(args: SelectSubset<T, OperatorgameCreateArgs<ExtArgs>>): Prisma__OperatorgameClient<$Result.GetResult<Prisma.$OperatorgamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Operatorgames.
     * @param {OperatorgameCreateManyArgs} args - Arguments to create many Operatorgames.
     * @example
     * // Create many Operatorgames
     * const operatorgame = await prisma.operatorgame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperatorgameCreateManyArgs>(args?: SelectSubset<T, OperatorgameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operatorgames and returns the data saved in the database.
     * @param {OperatorgameCreateManyAndReturnArgs} args - Arguments to create many Operatorgames.
     * @example
     * // Create many Operatorgames
     * const operatorgame = await prisma.operatorgame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operatorgames and only return the `id`
     * const operatorgameWithIdOnly = await prisma.operatorgame.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperatorgameCreateManyAndReturnArgs>(args?: SelectSubset<T, OperatorgameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorgamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Operatorgame.
     * @param {OperatorgameDeleteArgs} args - Arguments to delete one Operatorgame.
     * @example
     * // Delete one Operatorgame
     * const Operatorgame = await prisma.operatorgame.delete({
     *   where: {
     *     // ... filter to delete one Operatorgame
     *   }
     * })
     * 
     */
    delete<T extends OperatorgameDeleteArgs>(args: SelectSubset<T, OperatorgameDeleteArgs<ExtArgs>>): Prisma__OperatorgameClient<$Result.GetResult<Prisma.$OperatorgamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Operatorgame.
     * @param {OperatorgameUpdateArgs} args - Arguments to update one Operatorgame.
     * @example
     * // Update one Operatorgame
     * const operatorgame = await prisma.operatorgame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperatorgameUpdateArgs>(args: SelectSubset<T, OperatorgameUpdateArgs<ExtArgs>>): Prisma__OperatorgameClient<$Result.GetResult<Prisma.$OperatorgamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Operatorgames.
     * @param {OperatorgameDeleteManyArgs} args - Arguments to filter Operatorgames to delete.
     * @example
     * // Delete a few Operatorgames
     * const { count } = await prisma.operatorgame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperatorgameDeleteManyArgs>(args?: SelectSubset<T, OperatorgameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operatorgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorgameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operatorgames
     * const operatorgame = await prisma.operatorgame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperatorgameUpdateManyArgs>(args: SelectSubset<T, OperatorgameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operatorgame.
     * @param {OperatorgameUpsertArgs} args - Arguments to update or create a Operatorgame.
     * @example
     * // Update or create a Operatorgame
     * const operatorgame = await prisma.operatorgame.upsert({
     *   create: {
     *     // ... data to create a Operatorgame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operatorgame we want to update
     *   }
     * })
     */
    upsert<T extends OperatorgameUpsertArgs>(args: SelectSubset<T, OperatorgameUpsertArgs<ExtArgs>>): Prisma__OperatorgameClient<$Result.GetResult<Prisma.$OperatorgamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Operatorgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorgameCountArgs} args - Arguments to filter Operatorgames to count.
     * @example
     * // Count the number of Operatorgames
     * const count = await prisma.operatorgame.count({
     *   where: {
     *     // ... the filter for the Operatorgames we want to count
     *   }
     * })
    **/
    count<T extends OperatorgameCountArgs>(
      args?: Subset<T, OperatorgameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatorgameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operatorgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorgameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatorgameAggregateArgs>(args: Subset<T, OperatorgameAggregateArgs>): Prisma.PrismaPromise<GetOperatorgameAggregateType<T>>

    /**
     * Group by Operatorgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorgameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperatorgameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperatorgameGroupByArgs['orderBy'] }
        : { orderBy?: OperatorgameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperatorgameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatorgameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Operatorgame model
   */
  readonly fields: OperatorgameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Operatorgame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperatorgameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Operatorgame model
   */ 
  interface OperatorgameFieldRefs {
    readonly id: FieldRef<"Operatorgame", 'String'>
    readonly name: FieldRef<"Operatorgame", 'String'>
    readonly slug: FieldRef<"Operatorgame", 'String'>
    readonly description: FieldRef<"Operatorgame", 'String'>
    readonly thumbnail: FieldRef<"Operatorgame", 'String'>
    readonly minBet: FieldRef<"Operatorgame", 'Int'>
    readonly maxBet: FieldRef<"Operatorgame", 'Int'>
    readonly xpMultiplier: FieldRef<"Operatorgame", 'Float'>
    readonly isActive: FieldRef<"Operatorgame", 'Boolean'>
    readonly isPromoted: FieldRef<"Operatorgame", 'Boolean'>
    readonly createdAt: FieldRef<"Operatorgame", 'DateTime'>
    readonly updatedAt: FieldRef<"Operatorgame", 'DateTime'>
    readonly operatorId: FieldRef<"Operatorgame", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Operatorgame findUnique
   */
  export type OperatorgameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelect<ExtArgs> | null
    /**
     * Filter, which Operatorgame to fetch.
     */
    where: OperatorgameWhereUniqueInput
  }

  /**
   * Operatorgame findUniqueOrThrow
   */
  export type OperatorgameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelect<ExtArgs> | null
    /**
     * Filter, which Operatorgame to fetch.
     */
    where: OperatorgameWhereUniqueInput
  }

  /**
   * Operatorgame findFirst
   */
  export type OperatorgameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelect<ExtArgs> | null
    /**
     * Filter, which Operatorgame to fetch.
     */
    where?: OperatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operatorgames to fetch.
     */
    orderBy?: OperatorgameOrderByWithRelationInput | OperatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operatorgames.
     */
    cursor?: OperatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operatorgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operatorgames.
     */
    distinct?: OperatorgameScalarFieldEnum | OperatorgameScalarFieldEnum[]
  }

  /**
   * Operatorgame findFirstOrThrow
   */
  export type OperatorgameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelect<ExtArgs> | null
    /**
     * Filter, which Operatorgame to fetch.
     */
    where?: OperatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operatorgames to fetch.
     */
    orderBy?: OperatorgameOrderByWithRelationInput | OperatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operatorgames.
     */
    cursor?: OperatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operatorgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operatorgames.
     */
    distinct?: OperatorgameScalarFieldEnum | OperatorgameScalarFieldEnum[]
  }

  /**
   * Operatorgame findMany
   */
  export type OperatorgameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelect<ExtArgs> | null
    /**
     * Filter, which Operatorgames to fetch.
     */
    where?: OperatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operatorgames to fetch.
     */
    orderBy?: OperatorgameOrderByWithRelationInput | OperatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Operatorgames.
     */
    cursor?: OperatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operatorgames.
     */
    skip?: number
    distinct?: OperatorgameScalarFieldEnum | OperatorgameScalarFieldEnum[]
  }

  /**
   * Operatorgame create
   */
  export type OperatorgameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelect<ExtArgs> | null
    /**
     * The data needed to create a Operatorgame.
     */
    data: XOR<OperatorgameCreateInput, OperatorgameUncheckedCreateInput>
  }

  /**
   * Operatorgame createMany
   */
  export type OperatorgameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Operatorgames.
     */
    data: OperatorgameCreateManyInput | OperatorgameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Operatorgame createManyAndReturn
   */
  export type OperatorgameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Operatorgames.
     */
    data: OperatorgameCreateManyInput | OperatorgameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Operatorgame update
   */
  export type OperatorgameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelect<ExtArgs> | null
    /**
     * The data needed to update a Operatorgame.
     */
    data: XOR<OperatorgameUpdateInput, OperatorgameUncheckedUpdateInput>
    /**
     * Choose, which Operatorgame to update.
     */
    where: OperatorgameWhereUniqueInput
  }

  /**
   * Operatorgame updateMany
   */
  export type OperatorgameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Operatorgames.
     */
    data: XOR<OperatorgameUpdateManyMutationInput, OperatorgameUncheckedUpdateManyInput>
    /**
     * Filter which Operatorgames to update
     */
    where?: OperatorgameWhereInput
  }

  /**
   * Operatorgame upsert
   */
  export type OperatorgameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelect<ExtArgs> | null
    /**
     * The filter to search for the Operatorgame to update in case it exists.
     */
    where: OperatorgameWhereUniqueInput
    /**
     * In case the Operatorgame found by the `where` argument doesn't exist, create a new Operatorgame with this data.
     */
    create: XOR<OperatorgameCreateInput, OperatorgameUncheckedCreateInput>
    /**
     * In case the Operatorgame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperatorgameUpdateInput, OperatorgameUncheckedUpdateInput>
  }

  /**
   * Operatorgame delete
   */
  export type OperatorgameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelect<ExtArgs> | null
    /**
     * Filter which Operatorgame to delete.
     */
    where: OperatorgameWhereUniqueInput
  }

  /**
   * Operatorgame deleteMany
   */
  export type OperatorgameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operatorgames to delete
     */
    where?: OperatorgameWhereInput
  }

  /**
   * Operatorgame without action
   */
  export type OperatorgameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operatorgame
     */
    select?: OperatorgameSelect<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */ 
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    createdAt: Date | null
    metadata: string | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    createdAt: Date | null
    metadata: string | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logo: number
    createdAt: number
    metadata: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    metadata?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    metadata?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    metadata?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    logo: string | null
    createdAt: Date
    metadata: string | null
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    metadata?: boolean
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    members?: boolean | Organization$membersArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    metadata?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    members?: boolean | Organization$membersArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
      members: Prisma.$MemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      logo: string | null
      createdAt: Date
      metadata: string | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitations<T extends Organization$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany"> | Null>
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly logo: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly metadata: FieldRef<"Organization", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.invitations
   */
  export type Organization$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    role: number
    createdAt: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    organizationId: string
    userId: string
    role: string
    createdAt: Date
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      userId: string
      role: string
      createdAt: Date
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */ 
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly organizationId: FieldRef<"Member", 'String'>
    readonly userId: FieldRef<"Member", 'String'>
    readonly role: FieldRef<"Member", 'String'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    email: string | null
    role: string | null
    status: string | null
    expiresAt: Date | null
    inviterId: string | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    email: string | null
    role: string | null
    status: string | null
    expiresAt: Date | null
    inviterId: string | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    organizationId: number
    email: number
    role: number
    status: number
    expiresAt: number
    inviterId: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    organizationId: string
    email: string
    role: string | null
    status: string
    expiresAt: Date
    inviterId: string
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
  }

  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      email: string
      role: string | null
      status: string
      expiresAt: Date
      inviterId: string
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */ 
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly organizationId: FieldRef<"Invitation", 'String'>
    readonly email: FieldRef<"Invitation", 'String'>
    readonly role: FieldRef<"Invitation", 'String'>
    readonly status: FieldRef<"Invitation", 'String'>
    readonly expiresAt: FieldRef<"Invitation", 'DateTime'>
    readonly inviterId: FieldRef<"Invitation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model TwoFactor
   */

  export type AggregateTwoFactor = {
    _count: TwoFactorCountAggregateOutputType | null
    _min: TwoFactorMinAggregateOutputType | null
    _max: TwoFactorMaxAggregateOutputType | null
  }

  export type TwoFactorMinAggregateOutputType = {
    id: string | null
    secret: string | null
    backupCodes: string | null
    userId: string | null
  }

  export type TwoFactorMaxAggregateOutputType = {
    id: string | null
    secret: string | null
    backupCodes: string | null
    userId: string | null
  }

  export type TwoFactorCountAggregateOutputType = {
    id: number
    secret: number
    backupCodes: number
    userId: number
    _all: number
  }


  export type TwoFactorMinAggregateInputType = {
    id?: true
    secret?: true
    backupCodes?: true
    userId?: true
  }

  export type TwoFactorMaxAggregateInputType = {
    id?: true
    secret?: true
    backupCodes?: true
    userId?: true
  }

  export type TwoFactorCountAggregateInputType = {
    id?: true
    secret?: true
    backupCodes?: true
    userId?: true
    _all?: true
  }

  export type TwoFactorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactor to aggregate.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactors
    **/
    _count?: true | TwoFactorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorMaxAggregateInputType
  }

  export type GetTwoFactorAggregateType<T extends TwoFactorAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactor[P]>
      : GetScalarType<T[P], AggregateTwoFactor[P]>
  }




  export type TwoFactorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorWhereInput
    orderBy?: TwoFactorOrderByWithAggregationInput | TwoFactorOrderByWithAggregationInput[]
    by: TwoFactorScalarFieldEnum[] | TwoFactorScalarFieldEnum
    having?: TwoFactorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorCountAggregateInputType | true
    _min?: TwoFactorMinAggregateInputType
    _max?: TwoFactorMaxAggregateInputType
  }

  export type TwoFactorGroupByOutputType = {
    id: string
    secret: string
    backupCodes: string
    userId: string
    _count: TwoFactorCountAggregateOutputType | null
    _min: TwoFactorMinAggregateOutputType | null
    _max: TwoFactorMaxAggregateOutputType | null
  }

  type GetTwoFactorGroupByPayload<T extends TwoFactorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    secret?: boolean
    backupCodes?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactor"]>

  export type TwoFactorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    secret?: boolean
    backupCodes?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactor"]>

  export type TwoFactorSelectScalar = {
    id?: boolean
    secret?: boolean
    backupCodes?: boolean
    userId?: boolean
  }

  export type TwoFactorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TwoFactorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TwoFactorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      secret: string
      backupCodes: string
      userId: string
    }, ExtArgs["result"]["twoFactor"]>
    composites: {}
  }

  type TwoFactorGetPayload<S extends boolean | null | undefined | TwoFactorDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorPayload, S>

  type TwoFactorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TwoFactorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TwoFactorCountAggregateInputType | true
    }

  export interface TwoFactorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactor'], meta: { name: 'TwoFactor' } }
    /**
     * Find zero or one TwoFactor that matches the filter.
     * @param {TwoFactorFindUniqueArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwoFactorFindUniqueArgs>(args: SelectSubset<T, TwoFactorFindUniqueArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TwoFactor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TwoFactorFindUniqueOrThrowArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwoFactorFindUniqueOrThrowArgs>(args: SelectSubset<T, TwoFactorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TwoFactor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorFindFirstArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwoFactorFindFirstArgs>(args?: SelectSubset<T, TwoFactorFindFirstArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TwoFactor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorFindFirstOrThrowArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwoFactorFindFirstOrThrowArgs>(args?: SelectSubset<T, TwoFactorFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TwoFactors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactors
     * const twoFactors = await prisma.twoFactor.findMany()
     * 
     * // Get first 10 TwoFactors
     * const twoFactors = await prisma.twoFactor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorWithIdOnly = await prisma.twoFactor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwoFactorFindManyArgs>(args?: SelectSubset<T, TwoFactorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TwoFactor.
     * @param {TwoFactorCreateArgs} args - Arguments to create a TwoFactor.
     * @example
     * // Create one TwoFactor
     * const TwoFactor = await prisma.twoFactor.create({
     *   data: {
     *     // ... data to create a TwoFactor
     *   }
     * })
     * 
     */
    create<T extends TwoFactorCreateArgs>(args: SelectSubset<T, TwoFactorCreateArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TwoFactors.
     * @param {TwoFactorCreateManyArgs} args - Arguments to create many TwoFactors.
     * @example
     * // Create many TwoFactors
     * const twoFactor = await prisma.twoFactor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwoFactorCreateManyArgs>(args?: SelectSubset<T, TwoFactorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwoFactors and returns the data saved in the database.
     * @param {TwoFactorCreateManyAndReturnArgs} args - Arguments to create many TwoFactors.
     * @example
     * // Create many TwoFactors
     * const twoFactor = await prisma.twoFactor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwoFactors and only return the `id`
     * const twoFactorWithIdOnly = await prisma.twoFactor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwoFactorCreateManyAndReturnArgs>(args?: SelectSubset<T, TwoFactorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TwoFactor.
     * @param {TwoFactorDeleteArgs} args - Arguments to delete one TwoFactor.
     * @example
     * // Delete one TwoFactor
     * const TwoFactor = await prisma.twoFactor.delete({
     *   where: {
     *     // ... filter to delete one TwoFactor
     *   }
     * })
     * 
     */
    delete<T extends TwoFactorDeleteArgs>(args: SelectSubset<T, TwoFactorDeleteArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TwoFactor.
     * @param {TwoFactorUpdateArgs} args - Arguments to update one TwoFactor.
     * @example
     * // Update one TwoFactor
     * const twoFactor = await prisma.twoFactor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwoFactorUpdateArgs>(args: SelectSubset<T, TwoFactorUpdateArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TwoFactors.
     * @param {TwoFactorDeleteManyArgs} args - Arguments to filter TwoFactors to delete.
     * @example
     * // Delete a few TwoFactors
     * const { count } = await prisma.twoFactor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwoFactorDeleteManyArgs>(args?: SelectSubset<T, TwoFactorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactors
     * const twoFactor = await prisma.twoFactor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwoFactorUpdateManyArgs>(args: SelectSubset<T, TwoFactorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFactor.
     * @param {TwoFactorUpsertArgs} args - Arguments to update or create a TwoFactor.
     * @example
     * // Update or create a TwoFactor
     * const twoFactor = await prisma.twoFactor.upsert({
     *   create: {
     *     // ... data to create a TwoFactor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactor we want to update
     *   }
     * })
     */
    upsert<T extends TwoFactorUpsertArgs>(args: SelectSubset<T, TwoFactorUpsertArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TwoFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorCountArgs} args - Arguments to filter TwoFactors to count.
     * @example
     * // Count the number of TwoFactors
     * const count = await prisma.twoFactor.count({
     *   where: {
     *     // ... the filter for the TwoFactors we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorCountArgs>(
      args?: Subset<T, TwoFactorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorAggregateArgs>(args: Subset<T, TwoFactorAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorAggregateType<T>>

    /**
     * Group by TwoFactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactor model
   */
  readonly fields: TwoFactorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwoFactor model
   */ 
  interface TwoFactorFieldRefs {
    readonly id: FieldRef<"TwoFactor", 'String'>
    readonly secret: FieldRef<"TwoFactor", 'String'>
    readonly backupCodes: FieldRef<"TwoFactor", 'String'>
    readonly userId: FieldRef<"TwoFactor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TwoFactor findUnique
   */
  export type TwoFactorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor findUniqueOrThrow
   */
  export type TwoFactorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor findFirst
   */
  export type TwoFactorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactors.
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactors.
     */
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * TwoFactor findFirstOrThrow
   */
  export type TwoFactorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactors.
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactors.
     */
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * TwoFactor findMany
   */
  export type TwoFactorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactors to fetch.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactors.
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * TwoFactor create
   */
  export type TwoFactorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFactor.
     */
    data: XOR<TwoFactorCreateInput, TwoFactorUncheckedCreateInput>
  }

  /**
   * TwoFactor createMany
   */
  export type TwoFactorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactors.
     */
    data: TwoFactorCreateManyInput | TwoFactorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactor createManyAndReturn
   */
  export type TwoFactorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TwoFactors.
     */
    data: TwoFactorCreateManyInput | TwoFactorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwoFactor update
   */
  export type TwoFactorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFactor.
     */
    data: XOR<TwoFactorUpdateInput, TwoFactorUncheckedUpdateInput>
    /**
     * Choose, which TwoFactor to update.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor updateMany
   */
  export type TwoFactorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactors.
     */
    data: XOR<TwoFactorUpdateManyMutationInput, TwoFactorUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactors to update
     */
    where?: TwoFactorWhereInput
  }

  /**
   * TwoFactor upsert
   */
  export type TwoFactorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFactor to update in case it exists.
     */
    where: TwoFactorWhereUniqueInput
    /**
     * In case the TwoFactor found by the `where` argument doesn't exist, create a new TwoFactor with this data.
     */
    create: XOR<TwoFactorCreateInput, TwoFactorUncheckedCreateInput>
    /**
     * In case the TwoFactor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorUpdateInput, TwoFactorUncheckedUpdateInput>
  }

  /**
   * TwoFactor delete
   */
  export type TwoFactorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter which TwoFactor to delete.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor deleteMany
   */
  export type TwoFactorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactors to delete
     */
    where?: TwoFactorWhereInput
  }

  /**
   * TwoFactor without action
   */
  export type TwoFactorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
  }


  /**
   * Model Chatmessage
   */

  export type AggregateChatmessage = {
    _count: ChatmessageCountAggregateOutputType | null
    _min: ChatmessageMinAggregateOutputType | null
    _max: ChatmessageMaxAggregateOutputType | null
  }

  export type ChatmessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    channel: $Enums.ChatChannel | null
    createdAt: Date | null
    userId: string | null
    roomId: string | null
  }

  export type ChatmessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    channel: $Enums.ChatChannel | null
    createdAt: Date | null
    userId: string | null
    roomId: string | null
  }

  export type ChatmessageCountAggregateOutputType = {
    id: number
    content: number
    channel: number
    metadata: number
    createdAt: number
    userId: number
    roomId: number
    _all: number
  }


  export type ChatmessageMinAggregateInputType = {
    id?: true
    content?: true
    channel?: true
    createdAt?: true
    userId?: true
    roomId?: true
  }

  export type ChatmessageMaxAggregateInputType = {
    id?: true
    content?: true
    channel?: true
    createdAt?: true
    userId?: true
    roomId?: true
  }

  export type ChatmessageCountAggregateInputType = {
    id?: true
    content?: true
    channel?: true
    metadata?: true
    createdAt?: true
    userId?: true
    roomId?: true
    _all?: true
  }

  export type ChatmessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chatmessage to aggregate.
     */
    where?: ChatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatmessages to fetch.
     */
    orderBy?: ChatmessageOrderByWithRelationInput | ChatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chatmessages
    **/
    _count?: true | ChatmessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatmessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatmessageMaxAggregateInputType
  }

  export type GetChatmessageAggregateType<T extends ChatmessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatmessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatmessage[P]>
      : GetScalarType<T[P], AggregateChatmessage[P]>
  }




  export type ChatmessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatmessageWhereInput
    orderBy?: ChatmessageOrderByWithAggregationInput | ChatmessageOrderByWithAggregationInput[]
    by: ChatmessageScalarFieldEnum[] | ChatmessageScalarFieldEnum
    having?: ChatmessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatmessageCountAggregateInputType | true
    _min?: ChatmessageMinAggregateInputType
    _max?: ChatmessageMaxAggregateInputType
  }

  export type ChatmessageGroupByOutputType = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata: JsonValue | null
    createdAt: Date
    userId: string
    roomId: string | null
    _count: ChatmessageCountAggregateOutputType | null
    _min: ChatmessageMinAggregateOutputType | null
    _max: ChatmessageMaxAggregateOutputType | null
  }

  type GetChatmessageGroupByPayload<T extends ChatmessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatmessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatmessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatmessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatmessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatmessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
    chatroom?: boolean | Chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatmessage"]>

  export type ChatmessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
    chatroom?: boolean | Chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatmessage"]>

  export type ChatmessageSelectScalar = {
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
  }

  export type ChatmessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | Chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatmessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | Chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatmessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chatmessage"
    objects: {
      chatroom: Prisma.$ChatroomPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      channel: $Enums.ChatChannel
      metadata: Prisma.JsonValue | null
      createdAt: Date
      userId: string
      roomId: string | null
    }, ExtArgs["result"]["chatmessage"]>
    composites: {}
  }

  type ChatmessageGetPayload<S extends boolean | null | undefined | ChatmessageDefaultArgs> = $Result.GetResult<Prisma.$ChatmessagePayload, S>

  type ChatmessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatmessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatmessageCountAggregateInputType | true
    }

  export interface ChatmessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chatmessage'], meta: { name: 'Chatmessage' } }
    /**
     * Find zero or one Chatmessage that matches the filter.
     * @param {ChatmessageFindUniqueArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatmessageFindUniqueArgs>(args: SelectSubset<T, ChatmessageFindUniqueArgs<ExtArgs>>): Prisma__ChatmessageClient<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chatmessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatmessageFindUniqueOrThrowArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatmessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatmessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatmessageClient<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chatmessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatmessageFindFirstArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatmessageFindFirstArgs>(args?: SelectSubset<T, ChatmessageFindFirstArgs<ExtArgs>>): Prisma__ChatmessageClient<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chatmessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatmessageFindFirstOrThrowArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatmessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatmessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatmessageClient<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chatmessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatmessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatmessages
     * const chatmessages = await prisma.chatmessage.findMany()
     * 
     * // Get first 10 Chatmessages
     * const chatmessages = await prisma.chatmessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatmessageWithIdOnly = await prisma.chatmessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatmessageFindManyArgs>(args?: SelectSubset<T, ChatmessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chatmessage.
     * @param {ChatmessageCreateArgs} args - Arguments to create a Chatmessage.
     * @example
     * // Create one Chatmessage
     * const Chatmessage = await prisma.chatmessage.create({
     *   data: {
     *     // ... data to create a Chatmessage
     *   }
     * })
     * 
     */
    create<T extends ChatmessageCreateArgs>(args: SelectSubset<T, ChatmessageCreateArgs<ExtArgs>>): Prisma__ChatmessageClient<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chatmessages.
     * @param {ChatmessageCreateManyArgs} args - Arguments to create many Chatmessages.
     * @example
     * // Create many Chatmessages
     * const chatmessage = await prisma.chatmessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatmessageCreateManyArgs>(args?: SelectSubset<T, ChatmessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatmessages and returns the data saved in the database.
     * @param {ChatmessageCreateManyAndReturnArgs} args - Arguments to create many Chatmessages.
     * @example
     * // Create many Chatmessages
     * const chatmessage = await prisma.chatmessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatmessages and only return the `id`
     * const chatmessageWithIdOnly = await prisma.chatmessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatmessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatmessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chatmessage.
     * @param {ChatmessageDeleteArgs} args - Arguments to delete one Chatmessage.
     * @example
     * // Delete one Chatmessage
     * const Chatmessage = await prisma.chatmessage.delete({
     *   where: {
     *     // ... filter to delete one Chatmessage
     *   }
     * })
     * 
     */
    delete<T extends ChatmessageDeleteArgs>(args: SelectSubset<T, ChatmessageDeleteArgs<ExtArgs>>): Prisma__ChatmessageClient<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chatmessage.
     * @param {ChatmessageUpdateArgs} args - Arguments to update one Chatmessage.
     * @example
     * // Update one Chatmessage
     * const chatmessage = await prisma.chatmessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatmessageUpdateArgs>(args: SelectSubset<T, ChatmessageUpdateArgs<ExtArgs>>): Prisma__ChatmessageClient<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chatmessages.
     * @param {ChatmessageDeleteManyArgs} args - Arguments to filter Chatmessages to delete.
     * @example
     * // Delete a few Chatmessages
     * const { count } = await prisma.chatmessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatmessageDeleteManyArgs>(args?: SelectSubset<T, ChatmessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatmessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatmessages
     * const chatmessage = await prisma.chatmessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatmessageUpdateManyArgs>(args: SelectSubset<T, ChatmessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chatmessage.
     * @param {ChatmessageUpsertArgs} args - Arguments to update or create a Chatmessage.
     * @example
     * // Update or create a Chatmessage
     * const chatmessage = await prisma.chatmessage.upsert({
     *   create: {
     *     // ... data to create a Chatmessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatmessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatmessageUpsertArgs>(args: SelectSubset<T, ChatmessageUpsertArgs<ExtArgs>>): Prisma__ChatmessageClient<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chatmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatmessageCountArgs} args - Arguments to filter Chatmessages to count.
     * @example
     * // Count the number of Chatmessages
     * const count = await prisma.chatmessage.count({
     *   where: {
     *     // ... the filter for the Chatmessages we want to count
     *   }
     * })
    **/
    count<T extends ChatmessageCountArgs>(
      args?: Subset<T, ChatmessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatmessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatmessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatmessageAggregateArgs>(args: Subset<T, ChatmessageAggregateArgs>): Prisma.PrismaPromise<GetChatmessageAggregateType<T>>

    /**
     * Group by Chatmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatmessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatmessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatmessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatmessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatmessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatmessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chatmessage model
   */
  readonly fields: ChatmessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chatmessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatmessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatroom<T extends Chatmessage$chatroomArgs<ExtArgs> = {}>(args?: Subset<T, Chatmessage$chatroomArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chatmessage model
   */ 
  interface ChatmessageFieldRefs {
    readonly id: FieldRef<"Chatmessage", 'String'>
    readonly content: FieldRef<"Chatmessage", 'String'>
    readonly channel: FieldRef<"Chatmessage", 'ChatChannel'>
    readonly metadata: FieldRef<"Chatmessage", 'Json'>
    readonly createdAt: FieldRef<"Chatmessage", 'DateTime'>
    readonly userId: FieldRef<"Chatmessage", 'String'>
    readonly roomId: FieldRef<"Chatmessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chatmessage findUnique
   */
  export type ChatmessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    /**
     * Filter, which Chatmessage to fetch.
     */
    where: ChatmessageWhereUniqueInput
  }

  /**
   * Chatmessage findUniqueOrThrow
   */
  export type ChatmessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    /**
     * Filter, which Chatmessage to fetch.
     */
    where: ChatmessageWhereUniqueInput
  }

  /**
   * Chatmessage findFirst
   */
  export type ChatmessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    /**
     * Filter, which Chatmessage to fetch.
     */
    where?: ChatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatmessages to fetch.
     */
    orderBy?: ChatmessageOrderByWithRelationInput | ChatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatmessages.
     */
    cursor?: ChatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatmessages.
     */
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * Chatmessage findFirstOrThrow
   */
  export type ChatmessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    /**
     * Filter, which Chatmessage to fetch.
     */
    where?: ChatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatmessages to fetch.
     */
    orderBy?: ChatmessageOrderByWithRelationInput | ChatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatmessages.
     */
    cursor?: ChatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatmessages.
     */
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * Chatmessage findMany
   */
  export type ChatmessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    /**
     * Filter, which Chatmessages to fetch.
     */
    where?: ChatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatmessages to fetch.
     */
    orderBy?: ChatmessageOrderByWithRelationInput | ChatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chatmessages.
     */
    cursor?: ChatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatmessages.
     */
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * Chatmessage create
   */
  export type ChatmessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Chatmessage.
     */
    data: XOR<ChatmessageCreateInput, ChatmessageUncheckedCreateInput>
  }

  /**
   * Chatmessage createMany
   */
  export type ChatmessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chatmessages.
     */
    data: ChatmessageCreateManyInput | ChatmessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chatmessage createManyAndReturn
   */
  export type ChatmessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chatmessages.
     */
    data: ChatmessageCreateManyInput | ChatmessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chatmessage update
   */
  export type ChatmessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Chatmessage.
     */
    data: XOR<ChatmessageUpdateInput, ChatmessageUncheckedUpdateInput>
    /**
     * Choose, which Chatmessage to update.
     */
    where: ChatmessageWhereUniqueInput
  }

  /**
   * Chatmessage updateMany
   */
  export type ChatmessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chatmessages.
     */
    data: XOR<ChatmessageUpdateManyMutationInput, ChatmessageUncheckedUpdateManyInput>
    /**
     * Filter which Chatmessages to update
     */
    where?: ChatmessageWhereInput
  }

  /**
   * Chatmessage upsert
   */
  export type ChatmessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Chatmessage to update in case it exists.
     */
    where: ChatmessageWhereUniqueInput
    /**
     * In case the Chatmessage found by the `where` argument doesn't exist, create a new Chatmessage with this data.
     */
    create: XOR<ChatmessageCreateInput, ChatmessageUncheckedCreateInput>
    /**
     * In case the Chatmessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatmessageUpdateInput, ChatmessageUncheckedUpdateInput>
  }

  /**
   * Chatmessage delete
   */
  export type ChatmessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    /**
     * Filter which Chatmessage to delete.
     */
    where: ChatmessageWhereUniqueInput
  }

  /**
   * Chatmessage deleteMany
   */
  export type ChatmessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chatmessages to delete
     */
    where?: ChatmessageWhereInput
  }

  /**
   * Chatmessage.chatroom
   */
  export type Chatmessage$chatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    where?: ChatroomWhereInput
  }

  /**
   * Chatmessage without action
   */
  export type ChatmessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
  }


  /**
   * Model Chatroom
   */

  export type AggregateChatroom = {
    _count: ChatroomCountAggregateOutputType | null
    _min: ChatroomMinAggregateOutputType | null
    _max: ChatroomMaxAggregateOutputType | null
  }

  export type ChatroomMinAggregateOutputType = {
    id: string | null
    name: string | null
    isGameRoom: boolean | null
    createdAt: Date | null
    gameSessionId: string | null
  }

  export type ChatroomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isGameRoom: boolean | null
    createdAt: Date | null
    gameSessionId: string | null
  }

  export type ChatroomCountAggregateOutputType = {
    id: number
    name: number
    isGameRoom: number
    createdAt: number
    gameSessionId: number
    _all: number
  }


  export type ChatroomMinAggregateInputType = {
    id?: true
    name?: true
    isGameRoom?: true
    createdAt?: true
    gameSessionId?: true
  }

  export type ChatroomMaxAggregateInputType = {
    id?: true
    name?: true
    isGameRoom?: true
    createdAt?: true
    gameSessionId?: true
  }

  export type ChatroomCountAggregateInputType = {
    id?: true
    name?: true
    isGameRoom?: true
    createdAt?: true
    gameSessionId?: true
    _all?: true
  }

  export type ChatroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chatroom to aggregate.
     */
    where?: ChatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatrooms to fetch.
     */
    orderBy?: ChatroomOrderByWithRelationInput | ChatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chatrooms
    **/
    _count?: true | ChatroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatroomMaxAggregateInputType
  }

  export type GetChatroomAggregateType<T extends ChatroomAggregateArgs> = {
        [P in keyof T & keyof AggregateChatroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatroom[P]>
      : GetScalarType<T[P], AggregateChatroom[P]>
  }




  export type ChatroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatroomWhereInput
    orderBy?: ChatroomOrderByWithAggregationInput | ChatroomOrderByWithAggregationInput[]
    by: ChatroomScalarFieldEnum[] | ChatroomScalarFieldEnum
    having?: ChatroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatroomCountAggregateInputType | true
    _min?: ChatroomMinAggregateInputType
    _max?: ChatroomMaxAggregateInputType
  }

  export type ChatroomGroupByOutputType = {
    id: string
    name: string
    isGameRoom: boolean
    createdAt: Date
    gameSessionId: string | null
    _count: ChatroomCountAggregateOutputType | null
    _min: ChatroomMinAggregateOutputType | null
    _max: ChatroomMaxAggregateOutputType | null
  }

  type GetChatroomGroupByPayload<T extends ChatroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatroomGroupByOutputType[P]>
            : GetScalarType<T[P], ChatroomGroupByOutputType[P]>
        }
      >
    >


  export type ChatroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
    chatmessage?: boolean | Chatroom$chatmessageArgs<ExtArgs>
    gamesession?: boolean | Chatroom$gamesessionArgs<ExtArgs>
    _count?: boolean | ChatroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom"]>

  export type ChatroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
    gamesession?: boolean | Chatroom$gamesessionArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom"]>

  export type ChatroomSelectScalar = {
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
  }

  export type ChatroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatmessage?: boolean | Chatroom$chatmessageArgs<ExtArgs>
    gamesession?: boolean | Chatroom$gamesessionArgs<ExtArgs>
    _count?: boolean | ChatroomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | Chatroom$gamesessionArgs<ExtArgs>
  }

  export type $ChatroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chatroom"
    objects: {
      chatmessage: Prisma.$ChatmessagePayload<ExtArgs>[]
      gamesession: Prisma.$GamesessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isGameRoom: boolean
      createdAt: Date
      gameSessionId: string | null
    }, ExtArgs["result"]["chatroom"]>
    composites: {}
  }

  type ChatroomGetPayload<S extends boolean | null | undefined | ChatroomDefaultArgs> = $Result.GetResult<Prisma.$ChatroomPayload, S>

  type ChatroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatroomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatroomCountAggregateInputType | true
    }

  export interface ChatroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chatroom'], meta: { name: 'Chatroom' } }
    /**
     * Find zero or one Chatroom that matches the filter.
     * @param {ChatroomFindUniqueArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatroomFindUniqueArgs>(args: SelectSubset<T, ChatroomFindUniqueArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chatroom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatroomFindUniqueOrThrowArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatroomFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chatroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomFindFirstArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatroomFindFirstArgs>(args?: SelectSubset<T, ChatroomFindFirstArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chatroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomFindFirstOrThrowArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatroomFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chatrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatrooms
     * const chatrooms = await prisma.chatroom.findMany()
     * 
     * // Get first 10 Chatrooms
     * const chatrooms = await prisma.chatroom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatroomFindManyArgs>(args?: SelectSubset<T, ChatroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chatroom.
     * @param {ChatroomCreateArgs} args - Arguments to create a Chatroom.
     * @example
     * // Create one Chatroom
     * const Chatroom = await prisma.chatroom.create({
     *   data: {
     *     // ... data to create a Chatroom
     *   }
     * })
     * 
     */
    create<T extends ChatroomCreateArgs>(args: SelectSubset<T, ChatroomCreateArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chatrooms.
     * @param {ChatroomCreateManyArgs} args - Arguments to create many Chatrooms.
     * @example
     * // Create many Chatrooms
     * const chatroom = await prisma.chatroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatroomCreateManyArgs>(args?: SelectSubset<T, ChatroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatrooms and returns the data saved in the database.
     * @param {ChatroomCreateManyAndReturnArgs} args - Arguments to create many Chatrooms.
     * @example
     * // Create many Chatrooms
     * const chatroom = await prisma.chatroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatrooms and only return the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatroomCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chatroom.
     * @param {ChatroomDeleteArgs} args - Arguments to delete one Chatroom.
     * @example
     * // Delete one Chatroom
     * const Chatroom = await prisma.chatroom.delete({
     *   where: {
     *     // ... filter to delete one Chatroom
     *   }
     * })
     * 
     */
    delete<T extends ChatroomDeleteArgs>(args: SelectSubset<T, ChatroomDeleteArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chatroom.
     * @param {ChatroomUpdateArgs} args - Arguments to update one Chatroom.
     * @example
     * // Update one Chatroom
     * const chatroom = await prisma.chatroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatroomUpdateArgs>(args: SelectSubset<T, ChatroomUpdateArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chatrooms.
     * @param {ChatroomDeleteManyArgs} args - Arguments to filter Chatrooms to delete.
     * @example
     * // Delete a few Chatrooms
     * const { count } = await prisma.chatroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatroomDeleteManyArgs>(args?: SelectSubset<T, ChatroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatrooms
     * const chatroom = await prisma.chatroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatroomUpdateManyArgs>(args: SelectSubset<T, ChatroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chatroom.
     * @param {ChatroomUpsertArgs} args - Arguments to update or create a Chatroom.
     * @example
     * // Update or create a Chatroom
     * const chatroom = await prisma.chatroom.upsert({
     *   create: {
     *     // ... data to create a Chatroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatroom we want to update
     *   }
     * })
     */
    upsert<T extends ChatroomUpsertArgs>(args: SelectSubset<T, ChatroomUpsertArgs<ExtArgs>>): Prisma__ChatroomClient<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chatrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomCountArgs} args - Arguments to filter Chatrooms to count.
     * @example
     * // Count the number of Chatrooms
     * const count = await prisma.chatroom.count({
     *   where: {
     *     // ... the filter for the Chatrooms we want to count
     *   }
     * })
    **/
    count<T extends ChatroomCountArgs>(
      args?: Subset<T, ChatroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatroomAggregateArgs>(args: Subset<T, ChatroomAggregateArgs>): Prisma.PrismaPromise<GetChatroomAggregateType<T>>

    /**
     * Group by Chatroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatroomGroupByArgs['orderBy'] }
        : { orderBy?: ChatroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chatroom model
   */
  readonly fields: ChatroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chatroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatmessage<T extends Chatroom$chatmessageArgs<ExtArgs> = {}>(args?: Subset<T, Chatroom$chatmessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatmessagePayload<ExtArgs>, T, "findMany"> | Null>
    gamesession<T extends Chatroom$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, Chatroom$gamesessionArgs<ExtArgs>>): Prisma__GamesessionClient<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chatroom model
   */ 
  interface ChatroomFieldRefs {
    readonly id: FieldRef<"Chatroom", 'String'>
    readonly name: FieldRef<"Chatroom", 'String'>
    readonly isGameRoom: FieldRef<"Chatroom", 'Boolean'>
    readonly createdAt: FieldRef<"Chatroom", 'DateTime'>
    readonly gameSessionId: FieldRef<"Chatroom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chatroom findUnique
   */
  export type ChatroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter, which Chatroom to fetch.
     */
    where: ChatroomWhereUniqueInput
  }

  /**
   * Chatroom findUniqueOrThrow
   */
  export type ChatroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter, which Chatroom to fetch.
     */
    where: ChatroomWhereUniqueInput
  }

  /**
   * Chatroom findFirst
   */
  export type ChatroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter, which Chatroom to fetch.
     */
    where?: ChatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatrooms to fetch.
     */
    orderBy?: ChatroomOrderByWithRelationInput | ChatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatrooms.
     */
    cursor?: ChatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatrooms.
     */
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * Chatroom findFirstOrThrow
   */
  export type ChatroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter, which Chatroom to fetch.
     */
    where?: ChatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatrooms to fetch.
     */
    orderBy?: ChatroomOrderByWithRelationInput | ChatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatrooms.
     */
    cursor?: ChatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatrooms.
     */
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * Chatroom findMany
   */
  export type ChatroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter, which Chatrooms to fetch.
     */
    where?: ChatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatrooms to fetch.
     */
    orderBy?: ChatroomOrderByWithRelationInput | ChatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chatrooms.
     */
    cursor?: ChatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatrooms.
     */
    skip?: number
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * Chatroom create
   */
  export type ChatroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * The data needed to create a Chatroom.
     */
    data: XOR<ChatroomCreateInput, ChatroomUncheckedCreateInput>
  }

  /**
   * Chatroom createMany
   */
  export type ChatroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chatrooms.
     */
    data: ChatroomCreateManyInput | ChatroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chatroom createManyAndReturn
   */
  export type ChatroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chatrooms.
     */
    data: ChatroomCreateManyInput | ChatroomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chatroom update
   */
  export type ChatroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * The data needed to update a Chatroom.
     */
    data: XOR<ChatroomUpdateInput, ChatroomUncheckedUpdateInput>
    /**
     * Choose, which Chatroom to update.
     */
    where: ChatroomWhereUniqueInput
  }

  /**
   * Chatroom updateMany
   */
  export type ChatroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chatrooms.
     */
    data: XOR<ChatroomUpdateManyMutationInput, ChatroomUncheckedUpdateManyInput>
    /**
     * Filter which Chatrooms to update
     */
    where?: ChatroomWhereInput
  }

  /**
   * Chatroom upsert
   */
  export type ChatroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * The filter to search for the Chatroom to update in case it exists.
     */
    where: ChatroomWhereUniqueInput
    /**
     * In case the Chatroom found by the `where` argument doesn't exist, create a new Chatroom with this data.
     */
    create: XOR<ChatroomCreateInput, ChatroomUncheckedCreateInput>
    /**
     * In case the Chatroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatroomUpdateInput, ChatroomUncheckedUpdateInput>
  }

  /**
   * Chatroom delete
   */
  export type ChatroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    /**
     * Filter which Chatroom to delete.
     */
    where: ChatroomWhereUniqueInput
  }

  /**
   * Chatroom deleteMany
   */
  export type ChatroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chatrooms to delete
     */
    where?: ChatroomWhereInput
  }

  /**
   * Chatroom.chatmessage
   */
  export type Chatroom$chatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatmessage
     */
    select?: ChatmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatmessageInclude<ExtArgs> | null
    where?: ChatmessageWhereInput
    orderBy?: ChatmessageOrderByWithRelationInput | ChatmessageOrderByWithRelationInput[]
    cursor?: ChatmessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * Chatroom.gamesession
   */
  export type Chatroom$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    where?: GamesessionWhereInput
  }

  /**
   * Chatroom without action
   */
  export type ChatroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
  }


  /**
   * Model Friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    status: $Enums.FriendshipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    friendId: string | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    status: $Enums.FriendshipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    friendId: string | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    updatedAt: number
    userId: number
    friendId: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    friendId?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    friendId?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    friendId?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendship to aggregate.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type FriendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithAggregationInput | FriendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: FriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    status: $Enums.FriendshipStatus
    createdAt: Date
    updatedAt: Date | null
    userId: string
    friendId: string
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends FriendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type FriendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
    userFriendshipFriendidtouser?: boolean | UserDefaultArgs<ExtArgs>
    userFriendshipUseridtouser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
    userFriendshipFriendidtouser?: boolean | UserDefaultArgs<ExtArgs>
    userFriendshipUseridtouser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
  }

  export type FriendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userFriendshipFriendidtouser?: boolean | UserDefaultArgs<ExtArgs>
    userFriendshipUseridtouser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userFriendshipFriendidtouser?: boolean | UserDefaultArgs<ExtArgs>
    userFriendshipUseridtouser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FriendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friendship"
    objects: {
      userFriendshipFriendidtouser: Prisma.$UserPayload<ExtArgs>
      userFriendshipUseridtouser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.FriendshipStatus
      createdAt: Date
      updatedAt: Date | null
      userId: string
      friendId: string
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type FriendshipGetPayload<S extends boolean | null | undefined | FriendshipDefaultArgs> = $Result.GetResult<Prisma.$FriendshipPayload, S>

  type FriendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FriendshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface FriendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friendship'], meta: { name: 'Friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {FriendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendshipFindUniqueArgs>(args: SelectSubset<T, FriendshipFindUniqueArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FriendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendshipFindFirstArgs>(args?: SelectSubset<T, FriendshipFindFirstArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendshipFindManyArgs>(args?: SelectSubset<T, FriendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Friendship.
     * @param {FriendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends FriendshipCreateArgs>(args: SelectSubset<T, FriendshipCreateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Friendships.
     * @param {FriendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendshipCreateManyArgs>(args?: SelectSubset<T, FriendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {FriendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Friendship.
     * @param {FriendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends FriendshipDeleteArgs>(args: SelectSubset<T, FriendshipDeleteArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Friendship.
     * @param {FriendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendshipUpdateArgs>(args: SelectSubset<T, FriendshipUpdateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Friendships.
     * @param {FriendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendshipDeleteManyArgs>(args?: SelectSubset<T, FriendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendshipUpdateManyArgs>(args: SelectSubset<T, FriendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Friendship.
     * @param {FriendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends FriendshipUpsertArgs>(args: SelectSubset<T, FriendshipUpsertArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends FriendshipCountArgs>(
      args?: Subset<T, FriendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendshipGroupByArgs['orderBy'] }
        : { orderBy?: FriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friendship model
   */
  readonly fields: FriendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userFriendshipFriendidtouser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userFriendshipUseridtouser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friendship model
   */ 
  interface FriendshipFieldRefs {
    readonly id: FieldRef<"Friendship", 'String'>
    readonly status: FieldRef<"Friendship", 'FriendshipStatus'>
    readonly createdAt: FieldRef<"Friendship", 'DateTime'>
    readonly updatedAt: FieldRef<"Friendship", 'DateTime'>
    readonly userId: FieldRef<"Friendship", 'String'>
    readonly friendId: FieldRef<"Friendship", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Friendship findUnique
   */
  export type FriendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findUniqueOrThrow
   */
  export type FriendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findFirst
   */
  export type FriendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findFirstOrThrow
   */
  export type FriendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findMany
   */
  export type FriendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendships to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship create
   */
  export type FriendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Friendship.
     */
    data: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
  }

  /**
   * Friendship createMany
   */
  export type FriendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friendship createManyAndReturn
   */
  export type FriendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship update
   */
  export type FriendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Friendship.
     */
    data: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
    /**
     * Choose, which Friendship to update.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship updateMany
   */
  export type FriendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship upsert
   */
  export type FriendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Friendship to update in case it exists.
     */
    where: FriendshipWhereUniqueInput
    /**
     * In case the Friendship found by the `where` argument doesn't exist, create a new Friendship with this data.
     */
    create: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
    /**
     * In case the Friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
  }

  /**
   * Friendship delete
   */
  export type FriendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter which Friendship to delete.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship deleteMany
   */
  export type FriendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendships to delete
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship without action
   */
  export type FriendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
  }


  /**
   * Model Gamesession
   */

  export type AggregateGamesession = {
    _count: GamesessionCountAggregateOutputType | null
    _avg: GamesessionAvgAggregateOutputType | null
    _sum: GamesessionSumAggregateOutputType | null
    _min: GamesessionMinAggregateOutputType | null
    _max: GamesessionMaxAggregateOutputType | null
  }

  export type GamesessionAvgAggregateOutputType = {
    betAmount: number | null
    winAmount: number | null
    xpEarned: number | null
  }

  export type GamesessionSumAggregateOutputType = {
    betAmount: number | null
    winAmount: number | null
    xpEarned: number | null
  }

  export type GamesessionMinAggregateOutputType = {
    id: string | null
    startTime: Date | null
    endTime: Date | null
    betAmount: number | null
    winAmount: number | null
    xpEarned: number | null
    gameId: string | null
    tournamentId: string | null
    active: boolean | null
    profileId: string | null
    vipInfoId: string | null
  }

  export type GamesessionMaxAggregateOutputType = {
    id: string | null
    startTime: Date | null
    endTime: Date | null
    betAmount: number | null
    winAmount: number | null
    xpEarned: number | null
    gameId: string | null
    tournamentId: string | null
    active: boolean | null
    profileId: string | null
    vipInfoId: string | null
  }

  export type GamesessionCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    betAmount: number
    winAmount: number
    xpEarned: number
    metadata: number
    gameId: number
    tournamentId: number
    active: number
    profileId: number
    vipInfoId: number
    _all: number
  }


  export type GamesessionAvgAggregateInputType = {
    betAmount?: true
    winAmount?: true
    xpEarned?: true
  }

  export type GamesessionSumAggregateInputType = {
    betAmount?: true
    winAmount?: true
    xpEarned?: true
  }

  export type GamesessionMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    betAmount?: true
    winAmount?: true
    xpEarned?: true
    gameId?: true
    tournamentId?: true
    active?: true
    profileId?: true
    vipInfoId?: true
  }

  export type GamesessionMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    betAmount?: true
    winAmount?: true
    xpEarned?: true
    gameId?: true
    tournamentId?: true
    active?: true
    profileId?: true
    vipInfoId?: true
  }

  export type GamesessionCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    betAmount?: true
    winAmount?: true
    xpEarned?: true
    metadata?: true
    gameId?: true
    tournamentId?: true
    active?: true
    profileId?: true
    vipInfoId?: true
    _all?: true
  }

  export type GamesessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gamesession to aggregate.
     */
    where?: GamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamesessions to fetch.
     */
    orderBy?: GamesessionOrderByWithRelationInput | GamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamesessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gamesessions
    **/
    _count?: true | GamesessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GamesessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GamesessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GamesessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GamesessionMaxAggregateInputType
  }

  export type GetGamesessionAggregateType<T extends GamesessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGamesession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGamesession[P]>
      : GetScalarType<T[P], AggregateGamesession[P]>
  }




  export type GamesessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamesessionWhereInput
    orderBy?: GamesessionOrderByWithAggregationInput | GamesessionOrderByWithAggregationInput[]
    by: GamesessionScalarFieldEnum[] | GamesessionScalarFieldEnum
    having?: GamesessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GamesessionCountAggregateInputType | true
    _avg?: GamesessionAvgAggregateInputType
    _sum?: GamesessionSumAggregateInputType
    _min?: GamesessionMinAggregateInputType
    _max?: GamesessionMaxAggregateInputType
  }

  export type GamesessionGroupByOutputType = {
    id: string
    startTime: Date
    endTime: Date | null
    betAmount: number | null
    winAmount: number | null
    xpEarned: number
    metadata: JsonValue | null
    gameId: string
    tournamentId: string | null
    active: boolean
    profileId: string
    vipInfoId: string | null
    _count: GamesessionCountAggregateOutputType | null
    _avg: GamesessionAvgAggregateOutputType | null
    _sum: GamesessionSumAggregateOutputType | null
    _min: GamesessionMinAggregateOutputType | null
    _max: GamesessionMaxAggregateOutputType | null
  }

  type GetGamesessionGroupByPayload<T extends GamesessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GamesessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GamesessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamesessionGroupByOutputType[P]>
            : GetScalarType<T[P], GamesessionGroupByOutputType[P]>
        }
      >
    >


  export type GamesessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
    vipInfoId?: boolean
    chatroom?: boolean | Gamesession$chatroomArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | Gamesession$tournamentArgs<ExtArgs>
    Transaction?: boolean | Gamesession$TransactionArgs<ExtArgs>
    VipInfo?: boolean | Gamesession$VipInfoArgs<ExtArgs>
    _count?: boolean | GamesessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gamesession"]>

  export type GamesessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
    vipInfoId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | Gamesession$tournamentArgs<ExtArgs>
    VipInfo?: boolean | Gamesession$VipInfoArgs<ExtArgs>
  }, ExtArgs["result"]["gamesession"]>

  export type GamesessionSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
    vipInfoId?: boolean
  }

  export type GamesessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | Gamesession$chatroomArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | Gamesession$tournamentArgs<ExtArgs>
    Transaction?: boolean | Gamesession$TransactionArgs<ExtArgs>
    VipInfo?: boolean | Gamesession$VipInfoArgs<ExtArgs>
    _count?: boolean | GamesessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GamesessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | Gamesession$tournamentArgs<ExtArgs>
    VipInfo?: boolean | Gamesession$VipInfoArgs<ExtArgs>
  }

  export type $GamesessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gamesession"
    objects: {
      chatroom: Prisma.$ChatroomPayload<ExtArgs>[]
      game: Prisma.$GamePayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
      tournament: Prisma.$TournamentPayload<ExtArgs> | null
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
      VipInfo: Prisma.$VipInfoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startTime: Date
      endTime: Date | null
      betAmount: number | null
      winAmount: number | null
      xpEarned: number
      metadata: Prisma.JsonValue | null
      gameId: string
      tournamentId: string | null
      active: boolean
      profileId: string
      vipInfoId: string | null
    }, ExtArgs["result"]["gamesession"]>
    composites: {}
  }

  type GamesessionGetPayload<S extends boolean | null | undefined | GamesessionDefaultArgs> = $Result.GetResult<Prisma.$GamesessionPayload, S>

  type GamesessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GamesessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GamesessionCountAggregateInputType | true
    }

  export interface GamesessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gamesession'], meta: { name: 'Gamesession' } }
    /**
     * Find zero or one Gamesession that matches the filter.
     * @param {GamesessionFindUniqueArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GamesessionFindUniqueArgs>(args: SelectSubset<T, GamesessionFindUniqueArgs<ExtArgs>>): Prisma__GamesessionClient<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gamesession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GamesessionFindUniqueOrThrowArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GamesessionFindUniqueOrThrowArgs>(args: SelectSubset<T, GamesessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GamesessionClient<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gamesession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesessionFindFirstArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GamesessionFindFirstArgs>(args?: SelectSubset<T, GamesessionFindFirstArgs<ExtArgs>>): Prisma__GamesessionClient<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gamesession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesessionFindFirstOrThrowArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GamesessionFindFirstOrThrowArgs>(args?: SelectSubset<T, GamesessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GamesessionClient<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gamesessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gamesessions
     * const gamesessions = await prisma.gamesession.findMany()
     * 
     * // Get first 10 Gamesessions
     * const gamesessions = await prisma.gamesession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gamesessionWithIdOnly = await prisma.gamesession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GamesessionFindManyArgs>(args?: SelectSubset<T, GamesessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gamesession.
     * @param {GamesessionCreateArgs} args - Arguments to create a Gamesession.
     * @example
     * // Create one Gamesession
     * const Gamesession = await prisma.gamesession.create({
     *   data: {
     *     // ... data to create a Gamesession
     *   }
     * })
     * 
     */
    create<T extends GamesessionCreateArgs>(args: SelectSubset<T, GamesessionCreateArgs<ExtArgs>>): Prisma__GamesessionClient<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gamesessions.
     * @param {GamesessionCreateManyArgs} args - Arguments to create many Gamesessions.
     * @example
     * // Create many Gamesessions
     * const gamesession = await prisma.gamesession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GamesessionCreateManyArgs>(args?: SelectSubset<T, GamesessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gamesessions and returns the data saved in the database.
     * @param {GamesessionCreateManyAndReturnArgs} args - Arguments to create many Gamesessions.
     * @example
     * // Create many Gamesessions
     * const gamesession = await prisma.gamesession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gamesessions and only return the `id`
     * const gamesessionWithIdOnly = await prisma.gamesession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GamesessionCreateManyAndReturnArgs>(args?: SelectSubset<T, GamesessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Gamesession.
     * @param {GamesessionDeleteArgs} args - Arguments to delete one Gamesession.
     * @example
     * // Delete one Gamesession
     * const Gamesession = await prisma.gamesession.delete({
     *   where: {
     *     // ... filter to delete one Gamesession
     *   }
     * })
     * 
     */
    delete<T extends GamesessionDeleteArgs>(args: SelectSubset<T, GamesessionDeleteArgs<ExtArgs>>): Prisma__GamesessionClient<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gamesession.
     * @param {GamesessionUpdateArgs} args - Arguments to update one Gamesession.
     * @example
     * // Update one Gamesession
     * const gamesession = await prisma.gamesession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GamesessionUpdateArgs>(args: SelectSubset<T, GamesessionUpdateArgs<ExtArgs>>): Prisma__GamesessionClient<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gamesessions.
     * @param {GamesessionDeleteManyArgs} args - Arguments to filter Gamesessions to delete.
     * @example
     * // Delete a few Gamesessions
     * const { count } = await prisma.gamesession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GamesessionDeleteManyArgs>(args?: SelectSubset<T, GamesessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gamesessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gamesessions
     * const gamesession = await prisma.gamesession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GamesessionUpdateManyArgs>(args: SelectSubset<T, GamesessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gamesession.
     * @param {GamesessionUpsertArgs} args - Arguments to update or create a Gamesession.
     * @example
     * // Update or create a Gamesession
     * const gamesession = await prisma.gamesession.upsert({
     *   create: {
     *     // ... data to create a Gamesession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gamesession we want to update
     *   }
     * })
     */
    upsert<T extends GamesessionUpsertArgs>(args: SelectSubset<T, GamesessionUpsertArgs<ExtArgs>>): Prisma__GamesessionClient<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gamesessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesessionCountArgs} args - Arguments to filter Gamesessions to count.
     * @example
     * // Count the number of Gamesessions
     * const count = await prisma.gamesession.count({
     *   where: {
     *     // ... the filter for the Gamesessions we want to count
     *   }
     * })
    **/
    count<T extends GamesessionCountArgs>(
      args?: Subset<T, GamesessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamesessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gamesession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GamesessionAggregateArgs>(args: Subset<T, GamesessionAggregateArgs>): Prisma.PrismaPromise<GetGamesessionAggregateType<T>>

    /**
     * Group by Gamesession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GamesessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GamesessionGroupByArgs['orderBy'] }
        : { orderBy?: GamesessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GamesessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGamesessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gamesession model
   */
  readonly fields: GamesessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gamesession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GamesessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatroom<T extends Gamesession$chatroomArgs<ExtArgs> = {}>(args?: Subset<T, Gamesession$chatroomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatroomPayload<ExtArgs>, T, "findMany"> | Null>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tournament<T extends Gamesession$tournamentArgs<ExtArgs> = {}>(args?: Subset<T, Gamesession$tournamentArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Transaction<T extends Gamesession$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Gamesession$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    VipInfo<T extends Gamesession$VipInfoArgs<ExtArgs> = {}>(args?: Subset<T, Gamesession$VipInfoArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gamesession model
   */ 
  interface GamesessionFieldRefs {
    readonly id: FieldRef<"Gamesession", 'String'>
    readonly startTime: FieldRef<"Gamesession", 'DateTime'>
    readonly endTime: FieldRef<"Gamesession", 'DateTime'>
    readonly betAmount: FieldRef<"Gamesession", 'Int'>
    readonly winAmount: FieldRef<"Gamesession", 'Int'>
    readonly xpEarned: FieldRef<"Gamesession", 'Int'>
    readonly metadata: FieldRef<"Gamesession", 'Json'>
    readonly gameId: FieldRef<"Gamesession", 'String'>
    readonly tournamentId: FieldRef<"Gamesession", 'String'>
    readonly active: FieldRef<"Gamesession", 'Boolean'>
    readonly profileId: FieldRef<"Gamesession", 'String'>
    readonly vipInfoId: FieldRef<"Gamesession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Gamesession findUnique
   */
  export type GamesessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    /**
     * Filter, which Gamesession to fetch.
     */
    where: GamesessionWhereUniqueInput
  }

  /**
   * Gamesession findUniqueOrThrow
   */
  export type GamesessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    /**
     * Filter, which Gamesession to fetch.
     */
    where: GamesessionWhereUniqueInput
  }

  /**
   * Gamesession findFirst
   */
  export type GamesessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    /**
     * Filter, which Gamesession to fetch.
     */
    where?: GamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamesessions to fetch.
     */
    orderBy?: GamesessionOrderByWithRelationInput | GamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gamesessions.
     */
    cursor?: GamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamesessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gamesessions.
     */
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * Gamesession findFirstOrThrow
   */
  export type GamesessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    /**
     * Filter, which Gamesession to fetch.
     */
    where?: GamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamesessions to fetch.
     */
    orderBy?: GamesessionOrderByWithRelationInput | GamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gamesessions.
     */
    cursor?: GamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamesessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gamesessions.
     */
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * Gamesession findMany
   */
  export type GamesessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    /**
     * Filter, which Gamesessions to fetch.
     */
    where?: GamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamesessions to fetch.
     */
    orderBy?: GamesessionOrderByWithRelationInput | GamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gamesessions.
     */
    cursor?: GamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamesessions.
     */
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * Gamesession create
   */
  export type GamesessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Gamesession.
     */
    data: XOR<GamesessionCreateInput, GamesessionUncheckedCreateInput>
  }

  /**
   * Gamesession createMany
   */
  export type GamesessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gamesessions.
     */
    data: GamesessionCreateManyInput | GamesessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gamesession createManyAndReturn
   */
  export type GamesessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Gamesessions.
     */
    data: GamesessionCreateManyInput | GamesessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gamesession update
   */
  export type GamesessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Gamesession.
     */
    data: XOR<GamesessionUpdateInput, GamesessionUncheckedUpdateInput>
    /**
     * Choose, which Gamesession to update.
     */
    where: GamesessionWhereUniqueInput
  }

  /**
   * Gamesession updateMany
   */
  export type GamesessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gamesessions.
     */
    data: XOR<GamesessionUpdateManyMutationInput, GamesessionUncheckedUpdateManyInput>
    /**
     * Filter which Gamesessions to update
     */
    where?: GamesessionWhereInput
  }

  /**
   * Gamesession upsert
   */
  export type GamesessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Gamesession to update in case it exists.
     */
    where: GamesessionWhereUniqueInput
    /**
     * In case the Gamesession found by the `where` argument doesn't exist, create a new Gamesession with this data.
     */
    create: XOR<GamesessionCreateInput, GamesessionUncheckedCreateInput>
    /**
     * In case the Gamesession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GamesessionUpdateInput, GamesessionUncheckedUpdateInput>
  }

  /**
   * Gamesession delete
   */
  export type GamesessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    /**
     * Filter which Gamesession to delete.
     */
    where: GamesessionWhereUniqueInput
  }

  /**
   * Gamesession deleteMany
   */
  export type GamesessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gamesessions to delete
     */
    where?: GamesessionWhereInput
  }

  /**
   * Gamesession.chatroom
   */
  export type Gamesession$chatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatroom
     */
    select?: ChatroomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatroomInclude<ExtArgs> | null
    where?: ChatroomWhereInput
    orderBy?: ChatroomOrderByWithRelationInput | ChatroomOrderByWithRelationInput[]
    cursor?: ChatroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * Gamesession.tournament
   */
  export type Gamesession$tournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    where?: TournamentWhereInput
  }

  /**
   * Gamesession.Transaction
   */
  export type Gamesession$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Gamesession.VipInfo
   */
  export type Gamesession$VipInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    where?: VipInfoWhereInput
  }

  /**
   * Gamesession without action
   */
  export type GamesessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    bonusTotalInCredits: number | null
    priceInCents: number | null
    amountToReceiveInCredits: number | null
    bestValue: number | null
    discountInCents: number | null
    bonusSpins: number | null
    totalDiscountInCents: number | null
  }

  export type ProductSumAggregateOutputType = {
    bonusTotalInCredits: number | null
    priceInCents: number | null
    amountToReceiveInCredits: number | null
    bestValue: number | null
    discountInCents: number | null
    bonusSpins: number | null
    totalDiscountInCents: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    type: string | null
    bonusCode: string | null
    bonusTotalInCredits: number | null
    priceInCents: number | null
    amountToReceiveInCredits: number | null
    bestValue: number | null
    discountInCents: number | null
    bonusSpins: number | null
    isPromo: boolean | null
    totalDiscountInCents: number | null
    shopId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    type: string | null
    bonusCode: string | null
    bonusTotalInCredits: number | null
    priceInCents: number | null
    amountToReceiveInCredits: number | null
    bestValue: number | null
    discountInCents: number | null
    bonusSpins: number | null
    isPromo: boolean | null
    totalDiscountInCents: number | null
    shopId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    title: number
    description: number
    url: number
    type: number
    bonusCode: number
    bonusTotalInCredits: number
    priceInCents: number
    amountToReceiveInCredits: number
    bestValue: number
    discountInCents: number
    bonusSpins: number
    isPromo: number
    totalDiscountInCents: number
    shopId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    bonusTotalInCredits?: true
    priceInCents?: true
    amountToReceiveInCredits?: true
    bestValue?: true
    discountInCents?: true
    bonusSpins?: true
    totalDiscountInCents?: true
  }

  export type ProductSumAggregateInputType = {
    bonusTotalInCredits?: true
    priceInCents?: true
    amountToReceiveInCredits?: true
    bestValue?: true
    discountInCents?: true
    bonusSpins?: true
    totalDiscountInCents?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    type?: true
    bonusCode?: true
    bonusTotalInCredits?: true
    priceInCents?: true
    amountToReceiveInCredits?: true
    bestValue?: true
    discountInCents?: true
    bonusSpins?: true
    isPromo?: true
    totalDiscountInCents?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    type?: true
    bonusCode?: true
    bonusTotalInCredits?: true
    priceInCents?: true
    amountToReceiveInCredits?: true
    bestValue?: true
    discountInCents?: true
    bonusSpins?: true
    isPromo?: true
    totalDiscountInCents?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    type?: true
    bonusCode?: true
    bonusTotalInCredits?: true
    priceInCents?: true
    amountToReceiveInCredits?: true
    bestValue?: true
    discountInCents?: true
    bonusSpins?: true
    isPromo?: true
    totalDiscountInCents?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    title: string
    description: string
    url: string
    type: string
    bonusCode: string | null
    bonusTotalInCredits: number
    priceInCents: number
    amountToReceiveInCredits: number
    bestValue: number
    discountInCents: number
    bonusSpins: number
    isPromo: boolean | null
    totalDiscountInCents: number
    shopId: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    bonusCode?: boolean
    bonusTotalInCredits?: boolean
    priceInCents?: boolean
    amountToReceiveInCredits?: boolean
    bestValue?: boolean
    discountInCents?: boolean
    bonusSpins?: boolean
    isPromo?: boolean
    totalDiscountInCents?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operator?: boolean | Product$operatorArgs<ExtArgs>
    transactions?: boolean | Product$transactionsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    bonusCode?: boolean
    bonusTotalInCredits?: boolean
    priceInCents?: boolean
    amountToReceiveInCredits?: boolean
    bestValue?: boolean
    discountInCents?: boolean
    bonusSpins?: boolean
    isPromo?: boolean
    totalDiscountInCents?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operator?: boolean | Product$operatorArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    bonusCode?: boolean
    bonusTotalInCredits?: boolean
    priceInCents?: boolean
    amountToReceiveInCredits?: boolean
    bestValue?: boolean
    discountInCents?: boolean
    bonusSpins?: boolean
    isPromo?: boolean
    totalDiscountInCents?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | Product$operatorArgs<ExtArgs>
    transactions?: boolean | Product$transactionsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | Product$operatorArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      operator: Prisma.$OperatorPayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      url: string
      type: string
      bonusCode: string | null
      bonusTotalInCredits: number
      priceInCents: number
      amountToReceiveInCredits: number
      bestValue: number
      discountInCents: number
      bonusSpins: number
      isPromo: boolean | null
      totalDiscountInCents: number
      shopId: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operator<T extends Product$operatorArgs<ExtArgs> = {}>(args?: Subset<T, Product$operatorArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transactions<T extends Product$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Product$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly title: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly url: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'String'>
    readonly bonusCode: FieldRef<"Product", 'String'>
    readonly bonusTotalInCredits: FieldRef<"Product", 'Int'>
    readonly priceInCents: FieldRef<"Product", 'Int'>
    readonly amountToReceiveInCredits: FieldRef<"Product", 'Int'>
    readonly bestValue: FieldRef<"Product", 'Int'>
    readonly discountInCents: FieldRef<"Product", 'Int'>
    readonly bonusSpins: FieldRef<"Product", 'Int'>
    readonly isPromo: FieldRef<"Product", 'Boolean'>
    readonly totalDiscountInCents: FieldRef<"Product", 'Int'>
    readonly shopId: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data?: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.operator
   */
  export type Product$operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    where?: OperatorWhereInput
  }

  /**
   * Product.transactions
   */
  export type Product$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    isRead: number
    readAt: number
    metadata: number
    createdAt: number
    userId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    metadata?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    readAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      readAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly userId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Tournament
   */

  export type AggregateTournament = {
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  export type TournamentAvgAggregateOutputType = {
    entryFee: number | null
    prizePool: number | null
  }

  export type TournamentSumAggregateOutputType = {
    entryFee: number | null
    prizePool: number | null
  }

  export type TournamentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    entryFee: number | null
    prizePool: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type TournamentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    entryFee: number | null
    prizePool: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type TournamentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startTime: number
    endTime: number
    entryFee: number
    prizePool: number
    isActive: number
    createdAt: number
    updatedAt: number
    operatorId: number
    leaderboard: number
    _all: number
  }


  export type TournamentAvgAggregateInputType = {
    entryFee?: true
    prizePool?: true
  }

  export type TournamentSumAggregateInputType = {
    entryFee?: true
    prizePool?: true
  }

  export type TournamentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    entryFee?: true
    prizePool?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type TournamentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    entryFee?: true
    prizePool?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type TournamentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    entryFee?: true
    prizePool?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
    leaderboard?: true
    _all?: true
  }

  export type TournamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournament to aggregate.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tournaments
    **/
    _count?: true | TournamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentMaxAggregateInputType
  }

  export type GetTournamentAggregateType<T extends TournamentAggregateArgs> = {
        [P in keyof T & keyof AggregateTournament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament[P]>
      : GetScalarType<T[P], AggregateTournament[P]>
  }




  export type TournamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentWhereInput
    orderBy?: TournamentOrderByWithAggregationInput | TournamentOrderByWithAggregationInput[]
    by: TournamentScalarFieldEnum[] | TournamentScalarFieldEnum
    having?: TournamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentCountAggregateInputType | true
    _avg?: TournamentAvgAggregateInputType
    _sum?: TournamentSumAggregateInputType
    _min?: TournamentMinAggregateInputType
    _max?: TournamentMaxAggregateInputType
  }

  export type TournamentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startTime: Date
    endTime: Date
    entryFee: number | null
    prizePool: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    operatorId: string
    leaderboard: JsonValue | null
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  type GetTournamentGroupByPayload<T extends TournamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentGroupByOutputType[P]>
        }
      >
    >


  export type TournamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
    gamesession?: boolean | Tournament$gamesessionArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    tournamententry?: boolean | Tournament$tournamententryArgs<ExtArgs>
    tournamentgame?: boolean | Tournament$tournamentgameArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
  }

  export type TournamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | Tournament$gamesessionArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    tournamententry?: boolean | Tournament$tournamententryArgs<ExtArgs>
    tournamentgame?: boolean | Tournament$tournamentgameArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TournamentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }

  export type $TournamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tournament"
    objects: {
      gamesession: Prisma.$GamesessionPayload<ExtArgs>[]
      operator: Prisma.$OperatorPayload<ExtArgs>
      tournamententry: Prisma.$TournamententryPayload<ExtArgs>[]
      tournamentgame: Prisma.$TournamentgamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startTime: Date
      endTime: Date
      entryFee: number | null
      prizePool: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
      operatorId: string
      leaderboard: Prisma.JsonValue | null
    }, ExtArgs["result"]["tournament"]>
    composites: {}
  }

  type TournamentGetPayload<S extends boolean | null | undefined | TournamentDefaultArgs> = $Result.GetResult<Prisma.$TournamentPayload, S>

  type TournamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TournamentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TournamentCountAggregateInputType | true
    }

  export interface TournamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tournament'], meta: { name: 'Tournament' } }
    /**
     * Find zero or one Tournament that matches the filter.
     * @param {TournamentFindUniqueArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentFindUniqueArgs>(args: SelectSubset<T, TournamentFindUniqueArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tournament that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TournamentFindUniqueOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tournament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindFirstArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentFindFirstArgs>(args?: SelectSubset<T, TournamentFindFirstArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tournament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindFirstOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournament.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentWithIdOnly = await prisma.tournament.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TournamentFindManyArgs>(args?: SelectSubset<T, TournamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tournament.
     * @param {TournamentCreateArgs} args - Arguments to create a Tournament.
     * @example
     * // Create one Tournament
     * const Tournament = await prisma.tournament.create({
     *   data: {
     *     // ... data to create a Tournament
     *   }
     * })
     * 
     */
    create<T extends TournamentCreateArgs>(args: SelectSubset<T, TournamentCreateArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tournaments.
     * @param {TournamentCreateManyArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentCreateManyArgs>(args?: SelectSubset<T, TournamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournaments and returns the data saved in the database.
     * @param {TournamentCreateManyAndReturnArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournaments and only return the `id`
     * const tournamentWithIdOnly = await prisma.tournament.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tournament.
     * @param {TournamentDeleteArgs} args - Arguments to delete one Tournament.
     * @example
     * // Delete one Tournament
     * const Tournament = await prisma.tournament.delete({
     *   where: {
     *     // ... filter to delete one Tournament
     *   }
     * })
     * 
     */
    delete<T extends TournamentDeleteArgs>(args: SelectSubset<T, TournamentDeleteArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tournament.
     * @param {TournamentUpdateArgs} args - Arguments to update one Tournament.
     * @example
     * // Update one Tournament
     * const tournament = await prisma.tournament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentUpdateArgs>(args: SelectSubset<T, TournamentUpdateArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tournaments.
     * @param {TournamentDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentDeleteManyArgs>(args?: SelectSubset<T, TournamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentUpdateManyArgs>(args: SelectSubset<T, TournamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tournament.
     * @param {TournamentUpsertArgs} args - Arguments to update or create a Tournament.
     * @example
     * // Update or create a Tournament
     * const tournament = await prisma.tournament.upsert({
     *   create: {
     *     // ... data to create a Tournament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament we want to update
     *   }
     * })
     */
    upsert<T extends TournamentUpsertArgs>(args: SelectSubset<T, TournamentUpsertArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournament.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends TournamentCountArgs>(
      args?: Subset<T, TournamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentAggregateArgs>(args: Subset<T, TournamentAggregateArgs>): Prisma.PrismaPromise<GetTournamentAggregateType<T>>

    /**
     * Group by Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentGroupByArgs['orderBy'] }
        : { orderBy?: TournamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tournament model
   */
  readonly fields: TournamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tournament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamesession<T extends Tournament$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$gamesessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findMany"> | Null>
    operator<T extends OperatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperatorDefaultArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tournamententry<T extends Tournament$tournamententryArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$tournamententryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "findMany"> | Null>
    tournamentgame<T extends Tournament$tournamentgameArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$tournamentgameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tournament model
   */ 
  interface TournamentFieldRefs {
    readonly id: FieldRef<"Tournament", 'String'>
    readonly name: FieldRef<"Tournament", 'String'>
    readonly description: FieldRef<"Tournament", 'String'>
    readonly startTime: FieldRef<"Tournament", 'DateTime'>
    readonly endTime: FieldRef<"Tournament", 'DateTime'>
    readonly entryFee: FieldRef<"Tournament", 'Int'>
    readonly prizePool: FieldRef<"Tournament", 'Int'>
    readonly isActive: FieldRef<"Tournament", 'Boolean'>
    readonly createdAt: FieldRef<"Tournament", 'DateTime'>
    readonly updatedAt: FieldRef<"Tournament", 'DateTime'>
    readonly operatorId: FieldRef<"Tournament", 'String'>
    readonly leaderboard: FieldRef<"Tournament", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Tournament findUnique
   */
  export type TournamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament findUniqueOrThrow
   */
  export type TournamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament findFirst
   */
  export type TournamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament findFirstOrThrow
   */
  export type TournamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament findMany
   */
  export type TournamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournaments to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament create
   */
  export type TournamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The data needed to create a Tournament.
     */
    data: XOR<TournamentCreateInput, TournamentUncheckedCreateInput>
  }

  /**
   * Tournament createMany
   */
  export type TournamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tournaments.
     */
    data: TournamentCreateManyInput | TournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tournament createManyAndReturn
   */
  export type TournamentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tournaments.
     */
    data: TournamentCreateManyInput | TournamentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tournament update
   */
  export type TournamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The data needed to update a Tournament.
     */
    data: XOR<TournamentUpdateInput, TournamentUncheckedUpdateInput>
    /**
     * Choose, which Tournament to update.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament updateMany
   */
  export type TournamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tournaments.
     */
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyInput>
    /**
     * Filter which Tournaments to update
     */
    where?: TournamentWhereInput
  }

  /**
   * Tournament upsert
   */
  export type TournamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The filter to search for the Tournament to update in case it exists.
     */
    where: TournamentWhereUniqueInput
    /**
     * In case the Tournament found by the `where` argument doesn't exist, create a new Tournament with this data.
     */
    create: XOR<TournamentCreateInput, TournamentUncheckedCreateInput>
    /**
     * In case the Tournament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentUpdateInput, TournamentUncheckedUpdateInput>
  }

  /**
   * Tournament delete
   */
  export type TournamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter which Tournament to delete.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament deleteMany
   */
  export type TournamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournaments to delete
     */
    where?: TournamentWhereInput
  }

  /**
   * Tournament.gamesession
   */
  export type Tournament$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    where?: GamesessionWhereInput
    orderBy?: GamesessionOrderByWithRelationInput | GamesessionOrderByWithRelationInput[]
    cursor?: GamesessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * Tournament.tournamententry
   */
  export type Tournament$tournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    where?: TournamententryWhereInput
    orderBy?: TournamententryOrderByWithRelationInput | TournamententryOrderByWithRelationInput[]
    cursor?: TournamententryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * Tournament.tournamentgame
   */
  export type Tournament$tournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    where?: TournamentgameWhereInput
    orderBy?: TournamentgameOrderByWithRelationInput | TournamentgameOrderByWithRelationInput[]
    cursor?: TournamentgameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * Tournament without action
   */
  export type TournamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
  }


  /**
   * Model Tournamententry
   */

  export type AggregateTournamententry = {
    _count: TournamententryCountAggregateOutputType | null
    _avg: TournamententryAvgAggregateOutputType | null
    _sum: TournamententrySumAggregateOutputType | null
    _min: TournamententryMinAggregateOutputType | null
    _max: TournamententryMaxAggregateOutputType | null
  }

  export type TournamententryAvgAggregateOutputType = {
    score: number | null
    wagered: number | null
    won: number | null
  }

  export type TournamententrySumAggregateOutputType = {
    score: number | null
    wagered: number | null
    won: number | null
  }

  export type TournamententryMinAggregateOutputType = {
    id: string | null
    score: number | null
    wagered: number | null
    won: number | null
    joinedAt: Date | null
    userId: string | null
    tournamentId: string | null
    profileId: string | null
  }

  export type TournamententryMaxAggregateOutputType = {
    id: string | null
    score: number | null
    wagered: number | null
    won: number | null
    joinedAt: Date | null
    userId: string | null
    tournamentId: string | null
    profileId: string | null
  }

  export type TournamententryCountAggregateOutputType = {
    id: number
    score: number
    wagered: number
    won: number
    joinedAt: number
    userId: number
    tournamentId: number
    profileId: number
    _all: number
  }


  export type TournamententryAvgAggregateInputType = {
    score?: true
    wagered?: true
    won?: true
  }

  export type TournamententrySumAggregateInputType = {
    score?: true
    wagered?: true
    won?: true
  }

  export type TournamententryMinAggregateInputType = {
    id?: true
    score?: true
    wagered?: true
    won?: true
    joinedAt?: true
    userId?: true
    tournamentId?: true
    profileId?: true
  }

  export type TournamententryMaxAggregateInputType = {
    id?: true
    score?: true
    wagered?: true
    won?: true
    joinedAt?: true
    userId?: true
    tournamentId?: true
    profileId?: true
  }

  export type TournamententryCountAggregateInputType = {
    id?: true
    score?: true
    wagered?: true
    won?: true
    joinedAt?: true
    userId?: true
    tournamentId?: true
    profileId?: true
    _all?: true
  }

  export type TournamententryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournamententry to aggregate.
     */
    where?: TournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournamententries to fetch.
     */
    orderBy?: TournamententryOrderByWithRelationInput | TournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournamententries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tournamententries
    **/
    _count?: true | TournamententryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamententryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamententrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamententryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamententryMaxAggregateInputType
  }

  export type GetTournamententryAggregateType<T extends TournamententryAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamententry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamententry[P]>
      : GetScalarType<T[P], AggregateTournamententry[P]>
  }




  export type TournamententryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamententryWhereInput
    orderBy?: TournamententryOrderByWithAggregationInput | TournamententryOrderByWithAggregationInput[]
    by: TournamententryScalarFieldEnum[] | TournamententryScalarFieldEnum
    having?: TournamententryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamententryCountAggregateInputType | true
    _avg?: TournamententryAvgAggregateInputType
    _sum?: TournamententrySumAggregateInputType
    _min?: TournamententryMinAggregateInputType
    _max?: TournamententryMaxAggregateInputType
  }

  export type TournamententryGroupByOutputType = {
    id: string
    score: number
    wagered: number
    won: number
    joinedAt: Date
    userId: string
    tournamentId: string
    profileId: string
    _count: TournamententryCountAggregateOutputType | null
    _avg: TournamententryAvgAggregateOutputType | null
    _sum: TournamententrySumAggregateOutputType | null
    _min: TournamententryMinAggregateOutputType | null
    _max: TournamententryMaxAggregateOutputType | null
  }

  type GetTournamententryGroupByPayload<T extends TournamententryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamententryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamententryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamententryGroupByOutputType[P]>
            : GetScalarType<T[P], TournamententryGroupByOutputType[P]>
        }
      >
    >


  export type TournamententrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamententry"]>

  export type TournamententrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamententry"]>

  export type TournamententrySelectScalar = {
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
  }

  export type TournamententryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TournamententryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TournamententryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tournamententry"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      tournament: Prisma.$TournamentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      score: number
      wagered: number
      won: number
      joinedAt: Date
      userId: string
      tournamentId: string
      profileId: string
    }, ExtArgs["result"]["tournamententry"]>
    composites: {}
  }

  type TournamententryGetPayload<S extends boolean | null | undefined | TournamententryDefaultArgs> = $Result.GetResult<Prisma.$TournamententryPayload, S>

  type TournamententryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TournamententryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TournamententryCountAggregateInputType | true
    }

  export interface TournamententryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tournamententry'], meta: { name: 'Tournamententry' } }
    /**
     * Find zero or one Tournamententry that matches the filter.
     * @param {TournamententryFindUniqueArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamententryFindUniqueArgs>(args: SelectSubset<T, TournamententryFindUniqueArgs<ExtArgs>>): Prisma__TournamententryClient<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tournamententry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TournamententryFindUniqueOrThrowArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamententryFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamententryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamententryClient<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tournamententry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamententryFindFirstArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamententryFindFirstArgs>(args?: SelectSubset<T, TournamententryFindFirstArgs<ExtArgs>>): Prisma__TournamententryClient<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tournamententry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamententryFindFirstOrThrowArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamententryFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamententryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamententryClient<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tournamententries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamententryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournamententries
     * const tournamententries = await prisma.tournamententry.findMany()
     * 
     * // Get first 10 Tournamententries
     * const tournamententries = await prisma.tournamententry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamententryWithIdOnly = await prisma.tournamententry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TournamententryFindManyArgs>(args?: SelectSubset<T, TournamententryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tournamententry.
     * @param {TournamententryCreateArgs} args - Arguments to create a Tournamententry.
     * @example
     * // Create one Tournamententry
     * const Tournamententry = await prisma.tournamententry.create({
     *   data: {
     *     // ... data to create a Tournamententry
     *   }
     * })
     * 
     */
    create<T extends TournamententryCreateArgs>(args: SelectSubset<T, TournamententryCreateArgs<ExtArgs>>): Prisma__TournamententryClient<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tournamententries.
     * @param {TournamententryCreateManyArgs} args - Arguments to create many Tournamententries.
     * @example
     * // Create many Tournamententries
     * const tournamententry = await prisma.tournamententry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamententryCreateManyArgs>(args?: SelectSubset<T, TournamententryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournamententries and returns the data saved in the database.
     * @param {TournamententryCreateManyAndReturnArgs} args - Arguments to create many Tournamententries.
     * @example
     * // Create many Tournamententries
     * const tournamententry = await prisma.tournamententry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournamententries and only return the `id`
     * const tournamententryWithIdOnly = await prisma.tournamententry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamententryCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamententryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tournamententry.
     * @param {TournamententryDeleteArgs} args - Arguments to delete one Tournamententry.
     * @example
     * // Delete one Tournamententry
     * const Tournamententry = await prisma.tournamententry.delete({
     *   where: {
     *     // ... filter to delete one Tournamententry
     *   }
     * })
     * 
     */
    delete<T extends TournamententryDeleteArgs>(args: SelectSubset<T, TournamententryDeleteArgs<ExtArgs>>): Prisma__TournamententryClient<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tournamententry.
     * @param {TournamententryUpdateArgs} args - Arguments to update one Tournamententry.
     * @example
     * // Update one Tournamententry
     * const tournamententry = await prisma.tournamententry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamententryUpdateArgs>(args: SelectSubset<T, TournamententryUpdateArgs<ExtArgs>>): Prisma__TournamententryClient<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tournamententries.
     * @param {TournamententryDeleteManyArgs} args - Arguments to filter Tournamententries to delete.
     * @example
     * // Delete a few Tournamententries
     * const { count } = await prisma.tournamententry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamententryDeleteManyArgs>(args?: SelectSubset<T, TournamententryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournamententries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamententryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournamententries
     * const tournamententry = await prisma.tournamententry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamententryUpdateManyArgs>(args: SelectSubset<T, TournamententryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tournamententry.
     * @param {TournamententryUpsertArgs} args - Arguments to update or create a Tournamententry.
     * @example
     * // Update or create a Tournamententry
     * const tournamententry = await prisma.tournamententry.upsert({
     *   create: {
     *     // ... data to create a Tournamententry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournamententry we want to update
     *   }
     * })
     */
    upsert<T extends TournamententryUpsertArgs>(args: SelectSubset<T, TournamententryUpsertArgs<ExtArgs>>): Prisma__TournamententryClient<$Result.GetResult<Prisma.$TournamententryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tournamententries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamententryCountArgs} args - Arguments to filter Tournamententries to count.
     * @example
     * // Count the number of Tournamententries
     * const count = await prisma.tournamententry.count({
     *   where: {
     *     // ... the filter for the Tournamententries we want to count
     *   }
     * })
    **/
    count<T extends TournamententryCountArgs>(
      args?: Subset<T, TournamententryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamententryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournamententry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamententryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamententryAggregateArgs>(args: Subset<T, TournamententryAggregateArgs>): Prisma.PrismaPromise<GetTournamententryAggregateType<T>>

    /**
     * Group by Tournamententry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamententryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamententryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamententryGroupByArgs['orderBy'] }
        : { orderBy?: TournamententryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamententryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamententryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tournamententry model
   */
  readonly fields: TournamententryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tournamententry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamententryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tournament<T extends TournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TournamentDefaultArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tournamententry model
   */ 
  interface TournamententryFieldRefs {
    readonly id: FieldRef<"Tournamententry", 'String'>
    readonly score: FieldRef<"Tournamententry", 'Int'>
    readonly wagered: FieldRef<"Tournamententry", 'Int'>
    readonly won: FieldRef<"Tournamententry", 'Int'>
    readonly joinedAt: FieldRef<"Tournamententry", 'DateTime'>
    readonly userId: FieldRef<"Tournamententry", 'String'>
    readonly tournamentId: FieldRef<"Tournamententry", 'String'>
    readonly profileId: FieldRef<"Tournamententry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tournamententry findUnique
   */
  export type TournamententryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    /**
     * Filter, which Tournamententry to fetch.
     */
    where: TournamententryWhereUniqueInput
  }

  /**
   * Tournamententry findUniqueOrThrow
   */
  export type TournamententryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    /**
     * Filter, which Tournamententry to fetch.
     */
    where: TournamententryWhereUniqueInput
  }

  /**
   * Tournamententry findFirst
   */
  export type TournamententryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    /**
     * Filter, which Tournamententry to fetch.
     */
    where?: TournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournamententries to fetch.
     */
    orderBy?: TournamententryOrderByWithRelationInput | TournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournamententries.
     */
    cursor?: TournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournamententries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournamententries.
     */
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * Tournamententry findFirstOrThrow
   */
  export type TournamententryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    /**
     * Filter, which Tournamententry to fetch.
     */
    where?: TournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournamententries to fetch.
     */
    orderBy?: TournamententryOrderByWithRelationInput | TournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournamententries.
     */
    cursor?: TournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournamententries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournamententries.
     */
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * Tournamententry findMany
   */
  export type TournamententryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    /**
     * Filter, which Tournamententries to fetch.
     */
    where?: TournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournamententries to fetch.
     */
    orderBy?: TournamententryOrderByWithRelationInput | TournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tournamententries.
     */
    cursor?: TournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournamententries.
     */
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * Tournamententry create
   */
  export type TournamententryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    /**
     * The data needed to create a Tournamententry.
     */
    data: XOR<TournamententryCreateInput, TournamententryUncheckedCreateInput>
  }

  /**
   * Tournamententry createMany
   */
  export type TournamententryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tournamententries.
     */
    data: TournamententryCreateManyInput | TournamententryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tournamententry createManyAndReturn
   */
  export type TournamententryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tournamententries.
     */
    data: TournamententryCreateManyInput | TournamententryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tournamententry update
   */
  export type TournamententryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    /**
     * The data needed to update a Tournamententry.
     */
    data: XOR<TournamententryUpdateInput, TournamententryUncheckedUpdateInput>
    /**
     * Choose, which Tournamententry to update.
     */
    where: TournamententryWhereUniqueInput
  }

  /**
   * Tournamententry updateMany
   */
  export type TournamententryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tournamententries.
     */
    data: XOR<TournamententryUpdateManyMutationInput, TournamententryUncheckedUpdateManyInput>
    /**
     * Filter which Tournamententries to update
     */
    where?: TournamententryWhereInput
  }

  /**
   * Tournamententry upsert
   */
  export type TournamententryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    /**
     * The filter to search for the Tournamententry to update in case it exists.
     */
    where: TournamententryWhereUniqueInput
    /**
     * In case the Tournamententry found by the `where` argument doesn't exist, create a new Tournamententry with this data.
     */
    create: XOR<TournamententryCreateInput, TournamententryUncheckedCreateInput>
    /**
     * In case the Tournamententry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamententryUpdateInput, TournamententryUncheckedUpdateInput>
  }

  /**
   * Tournamententry delete
   */
  export type TournamententryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
    /**
     * Filter which Tournamententry to delete.
     */
    where: TournamententryWhereUniqueInput
  }

  /**
   * Tournamententry deleteMany
   */
  export type TournamententryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournamententries to delete
     */
    where?: TournamententryWhereInput
  }

  /**
   * Tournamententry without action
   */
  export type TournamententryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamententry
     */
    select?: TournamententrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamententryInclude<ExtArgs> | null
  }


  /**
   * Model Tournamentgame
   */

  export type AggregateTournamentgame = {
    _count: TournamentgameCountAggregateOutputType | null
    _avg: TournamentgameAvgAggregateOutputType | null
    _sum: TournamentgameSumAggregateOutputType | null
    _min: TournamentgameMinAggregateOutputType | null
    _max: TournamentgameMaxAggregateOutputType | null
  }

  export type TournamentgameAvgAggregateOutputType = {
    multiplier: number | null
  }

  export type TournamentgameSumAggregateOutputType = {
    multiplier: number | null
  }

  export type TournamentgameMinAggregateOutputType = {
    id: string | null
    multiplier: number | null
    tournamentId: string | null
    gameId: string | null
  }

  export type TournamentgameMaxAggregateOutputType = {
    id: string | null
    multiplier: number | null
    tournamentId: string | null
    gameId: string | null
  }

  export type TournamentgameCountAggregateOutputType = {
    id: number
    multiplier: number
    tournamentId: number
    gameId: number
    _all: number
  }


  export type TournamentgameAvgAggregateInputType = {
    multiplier?: true
  }

  export type TournamentgameSumAggregateInputType = {
    multiplier?: true
  }

  export type TournamentgameMinAggregateInputType = {
    id?: true
    multiplier?: true
    tournamentId?: true
    gameId?: true
  }

  export type TournamentgameMaxAggregateInputType = {
    id?: true
    multiplier?: true
    tournamentId?: true
    gameId?: true
  }

  export type TournamentgameCountAggregateInputType = {
    id?: true
    multiplier?: true
    tournamentId?: true
    gameId?: true
    _all?: true
  }

  export type TournamentgameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournamentgame to aggregate.
     */
    where?: TournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournamentgames to fetch.
     */
    orderBy?: TournamentgameOrderByWithRelationInput | TournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournamentgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tournamentgames
    **/
    _count?: true | TournamentgameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentgameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentgameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentgameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentgameMaxAggregateInputType
  }

  export type GetTournamentgameAggregateType<T extends TournamentgameAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamentgame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentgame[P]>
      : GetScalarType<T[P], AggregateTournamentgame[P]>
  }




  export type TournamentgameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentgameWhereInput
    orderBy?: TournamentgameOrderByWithAggregationInput | TournamentgameOrderByWithAggregationInput[]
    by: TournamentgameScalarFieldEnum[] | TournamentgameScalarFieldEnum
    having?: TournamentgameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentgameCountAggregateInputType | true
    _avg?: TournamentgameAvgAggregateInputType
    _sum?: TournamentgameSumAggregateInputType
    _min?: TournamentgameMinAggregateInputType
    _max?: TournamentgameMaxAggregateInputType
  }

  export type TournamentgameGroupByOutputType = {
    id: string
    multiplier: number
    tournamentId: string
    gameId: string
    _count: TournamentgameCountAggregateOutputType | null
    _avg: TournamentgameAvgAggregateOutputType | null
    _sum: TournamentgameSumAggregateOutputType | null
    _min: TournamentgameMinAggregateOutputType | null
    _max: TournamentgameMaxAggregateOutputType | null
  }

  type GetTournamentgameGroupByPayload<T extends TournamentgameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentgameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentgameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentgameGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentgameGroupByOutputType[P]>
        }
      >
    >


  export type TournamentgameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentgame"]>

  export type TournamentgameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentgame"]>

  export type TournamentgameSelectScalar = {
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
  }

  export type TournamentgameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
  }
  export type TournamentgameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
  }

  export type $TournamentgamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tournamentgame"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      tournament: Prisma.$TournamentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      multiplier: number
      tournamentId: string
      gameId: string
    }, ExtArgs["result"]["tournamentgame"]>
    composites: {}
  }

  type TournamentgameGetPayload<S extends boolean | null | undefined | TournamentgameDefaultArgs> = $Result.GetResult<Prisma.$TournamentgamePayload, S>

  type TournamentgameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TournamentgameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TournamentgameCountAggregateInputType | true
    }

  export interface TournamentgameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tournamentgame'], meta: { name: 'Tournamentgame' } }
    /**
     * Find zero or one Tournamentgame that matches the filter.
     * @param {TournamentgameFindUniqueArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentgameFindUniqueArgs>(args: SelectSubset<T, TournamentgameFindUniqueArgs<ExtArgs>>): Prisma__TournamentgameClient<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tournamentgame that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TournamentgameFindUniqueOrThrowArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentgameFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentgameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentgameClient<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tournamentgame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentgameFindFirstArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentgameFindFirstArgs>(args?: SelectSubset<T, TournamentgameFindFirstArgs<ExtArgs>>): Prisma__TournamentgameClient<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tournamentgame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentgameFindFirstOrThrowArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentgameFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentgameFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentgameClient<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tournamentgames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentgameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournamentgames
     * const tournamentgames = await prisma.tournamentgame.findMany()
     * 
     * // Get first 10 Tournamentgames
     * const tournamentgames = await prisma.tournamentgame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentgameWithIdOnly = await prisma.tournamentgame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TournamentgameFindManyArgs>(args?: SelectSubset<T, TournamentgameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tournamentgame.
     * @param {TournamentgameCreateArgs} args - Arguments to create a Tournamentgame.
     * @example
     * // Create one Tournamentgame
     * const Tournamentgame = await prisma.tournamentgame.create({
     *   data: {
     *     // ... data to create a Tournamentgame
     *   }
     * })
     * 
     */
    create<T extends TournamentgameCreateArgs>(args: SelectSubset<T, TournamentgameCreateArgs<ExtArgs>>): Prisma__TournamentgameClient<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tournamentgames.
     * @param {TournamentgameCreateManyArgs} args - Arguments to create many Tournamentgames.
     * @example
     * // Create many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentgameCreateManyArgs>(args?: SelectSubset<T, TournamentgameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournamentgames and returns the data saved in the database.
     * @param {TournamentgameCreateManyAndReturnArgs} args - Arguments to create many Tournamentgames.
     * @example
     * // Create many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournamentgames and only return the `id`
     * const tournamentgameWithIdOnly = await prisma.tournamentgame.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentgameCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentgameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tournamentgame.
     * @param {TournamentgameDeleteArgs} args - Arguments to delete one Tournamentgame.
     * @example
     * // Delete one Tournamentgame
     * const Tournamentgame = await prisma.tournamentgame.delete({
     *   where: {
     *     // ... filter to delete one Tournamentgame
     *   }
     * })
     * 
     */
    delete<T extends TournamentgameDeleteArgs>(args: SelectSubset<T, TournamentgameDeleteArgs<ExtArgs>>): Prisma__TournamentgameClient<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tournamentgame.
     * @param {TournamentgameUpdateArgs} args - Arguments to update one Tournamentgame.
     * @example
     * // Update one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentgameUpdateArgs>(args: SelectSubset<T, TournamentgameUpdateArgs<ExtArgs>>): Prisma__TournamentgameClient<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tournamentgames.
     * @param {TournamentgameDeleteManyArgs} args - Arguments to filter Tournamentgames to delete.
     * @example
     * // Delete a few Tournamentgames
     * const { count } = await prisma.tournamentgame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentgameDeleteManyArgs>(args?: SelectSubset<T, TournamentgameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournamentgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentgameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentgameUpdateManyArgs>(args: SelectSubset<T, TournamentgameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tournamentgame.
     * @param {TournamentgameUpsertArgs} args - Arguments to update or create a Tournamentgame.
     * @example
     * // Update or create a Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.upsert({
     *   create: {
     *     // ... data to create a Tournamentgame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournamentgame we want to update
     *   }
     * })
     */
    upsert<T extends TournamentgameUpsertArgs>(args: SelectSubset<T, TournamentgameUpsertArgs<ExtArgs>>): Prisma__TournamentgameClient<$Result.GetResult<Prisma.$TournamentgamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tournamentgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentgameCountArgs} args - Arguments to filter Tournamentgames to count.
     * @example
     * // Count the number of Tournamentgames
     * const count = await prisma.tournamentgame.count({
     *   where: {
     *     // ... the filter for the Tournamentgames we want to count
     *   }
     * })
    **/
    count<T extends TournamentgameCountArgs>(
      args?: Subset<T, TournamentgameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentgameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournamentgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentgameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentgameAggregateArgs>(args: Subset<T, TournamentgameAggregateArgs>): Prisma.PrismaPromise<GetTournamentgameAggregateType<T>>

    /**
     * Group by Tournamentgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentgameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentgameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentgameGroupByArgs['orderBy'] }
        : { orderBy?: TournamentgameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentgameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentgameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tournamentgame model
   */
  readonly fields: TournamentgameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tournamentgame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentgameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tournament<T extends TournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TournamentDefaultArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tournamentgame model
   */ 
  interface TournamentgameFieldRefs {
    readonly id: FieldRef<"Tournamentgame", 'String'>
    readonly multiplier: FieldRef<"Tournamentgame", 'Float'>
    readonly tournamentId: FieldRef<"Tournamentgame", 'String'>
    readonly gameId: FieldRef<"Tournamentgame", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tournamentgame findUnique
   */
  export type TournamentgameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which Tournamentgame to fetch.
     */
    where: TournamentgameWhereUniqueInput
  }

  /**
   * Tournamentgame findUniqueOrThrow
   */
  export type TournamentgameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which Tournamentgame to fetch.
     */
    where: TournamentgameWhereUniqueInput
  }

  /**
   * Tournamentgame findFirst
   */
  export type TournamentgameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which Tournamentgame to fetch.
     */
    where?: TournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournamentgames to fetch.
     */
    orderBy?: TournamentgameOrderByWithRelationInput | TournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournamentgames.
     */
    cursor?: TournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournamentgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournamentgames.
     */
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * Tournamentgame findFirstOrThrow
   */
  export type TournamentgameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which Tournamentgame to fetch.
     */
    where?: TournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournamentgames to fetch.
     */
    orderBy?: TournamentgameOrderByWithRelationInput | TournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournamentgames.
     */
    cursor?: TournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournamentgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournamentgames.
     */
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * Tournamentgame findMany
   */
  export type TournamentgameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which Tournamentgames to fetch.
     */
    where?: TournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournamentgames to fetch.
     */
    orderBy?: TournamentgameOrderByWithRelationInput | TournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tournamentgames.
     */
    cursor?: TournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournamentgames.
     */
    skip?: number
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * Tournamentgame create
   */
  export type TournamentgameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    /**
     * The data needed to create a Tournamentgame.
     */
    data: XOR<TournamentgameCreateInput, TournamentgameUncheckedCreateInput>
  }

  /**
   * Tournamentgame createMany
   */
  export type TournamentgameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tournamentgames.
     */
    data: TournamentgameCreateManyInput | TournamentgameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tournamentgame createManyAndReturn
   */
  export type TournamentgameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tournamentgames.
     */
    data: TournamentgameCreateManyInput | TournamentgameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tournamentgame update
   */
  export type TournamentgameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    /**
     * The data needed to update a Tournamentgame.
     */
    data: XOR<TournamentgameUpdateInput, TournamentgameUncheckedUpdateInput>
    /**
     * Choose, which Tournamentgame to update.
     */
    where: TournamentgameWhereUniqueInput
  }

  /**
   * Tournamentgame updateMany
   */
  export type TournamentgameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tournamentgames.
     */
    data: XOR<TournamentgameUpdateManyMutationInput, TournamentgameUncheckedUpdateManyInput>
    /**
     * Filter which Tournamentgames to update
     */
    where?: TournamentgameWhereInput
  }

  /**
   * Tournamentgame upsert
   */
  export type TournamentgameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    /**
     * The filter to search for the Tournamentgame to update in case it exists.
     */
    where: TournamentgameWhereUniqueInput
    /**
     * In case the Tournamentgame found by the `where` argument doesn't exist, create a new Tournamentgame with this data.
     */
    create: XOR<TournamentgameCreateInput, TournamentgameUncheckedCreateInput>
    /**
     * In case the Tournamentgame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentgameUpdateInput, TournamentgameUncheckedUpdateInput>
  }

  /**
   * Tournamentgame delete
   */
  export type TournamentgameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
    /**
     * Filter which Tournamentgame to delete.
     */
    where: TournamentgameWhereUniqueInput
  }

  /**
   * Tournamentgame deleteMany
   */
  export type TournamentgameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournamentgames to delete
     */
    where?: TournamentgameWhereInput
  }

  /**
   * Tournamentgame without action
   */
  export type TournamentgameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournamentgame
     */
    select?: TournamentgameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentgameInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
    amountCredits: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
    amountCredits: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    amountCredits: number | null
    buyerCashtag: string | null
    buyerUserId: string | null
    username: string | null
    cashiername: string | null
    cashierAvatar: string | null
    cashierId: string | null
    reference: string | null
    status: $Enums.TransactionStatus | null
    isRealMoney: boolean | null
    paymentMethod: string | null
    createdAt: Date | null
    processedAt: Date | null
    gameSessionId: string | null
    profileId: string | null
    cashtag: string | null
    productid: string | null
    vipInfoId: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    amountCredits: number | null
    buyerCashtag: string | null
    buyerUserId: string | null
    username: string | null
    cashiername: string | null
    cashierAvatar: string | null
    cashierId: string | null
    reference: string | null
    status: $Enums.TransactionStatus | null
    isRealMoney: boolean | null
    paymentMethod: string | null
    createdAt: Date | null
    processedAt: Date | null
    gameSessionId: string | null
    profileId: string | null
    cashtag: string | null
    productid: string | null
    vipInfoId: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    amountCredits: number
    buyerCashtag: number
    buyerUserId: number
    username: number
    cashiername: number
    cashierAvatar: number
    cashierId: number
    reference: number
    status: number
    metadata: number
    isRealMoney: number
    paymentMethod: number
    paymentDetails: number
    createdAt: number
    processedAt: number
    gameSessionId: number
    profileId: number
    cashtag: number
    productid: number
    vipInfoId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    amountCredits?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    amountCredits?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    amountCredits?: true
    buyerCashtag?: true
    buyerUserId?: true
    username?: true
    cashiername?: true
    cashierAvatar?: true
    cashierId?: true
    reference?: true
    status?: true
    isRealMoney?: true
    paymentMethod?: true
    createdAt?: true
    processedAt?: true
    gameSessionId?: true
    profileId?: true
    cashtag?: true
    productid?: true
    vipInfoId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    amountCredits?: true
    buyerCashtag?: true
    buyerUserId?: true
    username?: true
    cashiername?: true
    cashierAvatar?: true
    cashierId?: true
    reference?: true
    status?: true
    isRealMoney?: true
    paymentMethod?: true
    createdAt?: true
    processedAt?: true
    gameSessionId?: true
    profileId?: true
    cashtag?: true
    productid?: true
    vipInfoId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    amountCredits?: true
    buyerCashtag?: true
    buyerUserId?: true
    username?: true
    cashiername?: true
    cashierAvatar?: true
    cashierId?: true
    reference?: true
    status?: true
    metadata?: true
    isRealMoney?: true
    paymentMethod?: true
    paymentDetails?: true
    createdAt?: true
    processedAt?: true
    gameSessionId?: true
    profileId?: true
    cashtag?: true
    productid?: true
    vipInfoId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    type: $Enums.TransactionType
    amount: number
    amountCredits: number
    buyerCashtag: string | null
    buyerUserId: string | null
    username: string | null
    cashiername: string | null
    cashierAvatar: string | null
    cashierId: string | null
    reference: string | null
    status: $Enums.TransactionStatus
    metadata: JsonValue | null
    isRealMoney: boolean
    paymentMethod: string | null
    paymentDetails: JsonValue | null
    createdAt: Date
    processedAt: Date | null
    gameSessionId: string | null
    profileId: string | null
    cashtag: string | null
    productid: string | null
    vipInfoId: string | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    amountCredits?: boolean
    buyerCashtag?: boolean
    buyerUserId?: boolean
    username?: boolean
    cashiername?: boolean
    cashierAvatar?: boolean
    cashierId?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
    cashtag?: boolean
    productid?: boolean
    vipInfoId?: boolean
    gamesession?: boolean | Transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | Transaction$profileArgs<ExtArgs>
    product?: boolean | Transaction$productArgs<ExtArgs>
    vipInfo?: boolean | Transaction$vipInfoArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    amountCredits?: boolean
    buyerCashtag?: boolean
    buyerUserId?: boolean
    username?: boolean
    cashiername?: boolean
    cashierAvatar?: boolean
    cashierId?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
    cashtag?: boolean
    productid?: boolean
    vipInfoId?: boolean
    gamesession?: boolean | Transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | Transaction$profileArgs<ExtArgs>
    product?: boolean | Transaction$productArgs<ExtArgs>
    vipInfo?: boolean | Transaction$vipInfoArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    amountCredits?: boolean
    buyerCashtag?: boolean
    buyerUserId?: boolean
    username?: boolean
    cashiername?: boolean
    cashierAvatar?: boolean
    cashierId?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
    cashtag?: boolean
    productid?: boolean
    vipInfoId?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | Transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | Transaction$profileArgs<ExtArgs>
    product?: boolean | Transaction$productArgs<ExtArgs>
    vipInfo?: boolean | Transaction$vipInfoArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | Transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | Transaction$profileArgs<ExtArgs>
    product?: boolean | Transaction$productArgs<ExtArgs>
    vipInfo?: boolean | Transaction$vipInfoArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      gamesession: Prisma.$GamesessionPayload<ExtArgs> | null
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
      vipInfo: Prisma.$VipInfoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.TransactionType
      amount: number
      amountCredits: number
      buyerCashtag: string | null
      buyerUserId: string | null
      username: string | null
      cashiername: string | null
      cashierAvatar: string | null
      cashierId: string | null
      reference: string | null
      status: $Enums.TransactionStatus
      metadata: Prisma.JsonValue | null
      isRealMoney: boolean
      paymentMethod: string | null
      paymentDetails: Prisma.JsonValue | null
      createdAt: Date
      processedAt: Date | null
      gameSessionId: string | null
      profileId: string | null
      cashtag: string | null
      productid: string | null
      vipInfoId: string | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamesession<T extends Transaction$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$gamesessionArgs<ExtArgs>>): Prisma__GamesessionClient<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    profile<T extends Transaction$profileArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    product<T extends Transaction$productArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vipInfo<T extends Transaction$vipInfoArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$vipInfoArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly amount: FieldRef<"Transaction", 'Int'>
    readonly amountCredits: FieldRef<"Transaction", 'Int'>
    readonly buyerCashtag: FieldRef<"Transaction", 'String'>
    readonly buyerUserId: FieldRef<"Transaction", 'String'>
    readonly username: FieldRef<"Transaction", 'String'>
    readonly cashiername: FieldRef<"Transaction", 'String'>
    readonly cashierAvatar: FieldRef<"Transaction", 'String'>
    readonly cashierId: FieldRef<"Transaction", 'String'>
    readonly reference: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly metadata: FieldRef<"Transaction", 'Json'>
    readonly isRealMoney: FieldRef<"Transaction", 'Boolean'>
    readonly paymentMethod: FieldRef<"Transaction", 'String'>
    readonly paymentDetails: FieldRef<"Transaction", 'Json'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly processedAt: FieldRef<"Transaction", 'DateTime'>
    readonly gameSessionId: FieldRef<"Transaction", 'String'>
    readonly profileId: FieldRef<"Transaction", 'String'>
    readonly cashtag: FieldRef<"Transaction", 'String'>
    readonly productid: FieldRef<"Transaction", 'String'>
    readonly vipInfoId: FieldRef<"Transaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data?: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.gamesession
   */
  export type Transaction$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    where?: GamesessionWhereInput
  }

  /**
   * Transaction.profile
   */
  export type Transaction$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Transaction.product
   */
  export type Transaction$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Transaction.vipInfo
   */
  export type Transaction$vipInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    where?: VipInfoWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Userachievement
   */

  export type AggregateUserachievement = {
    _count: UserachievementCountAggregateOutputType | null
    _avg: UserachievementAvgAggregateOutputType | null
    _sum: UserachievementSumAggregateOutputType | null
    _min: UserachievementMinAggregateOutputType | null
    _max: UserachievementMaxAggregateOutputType | null
  }

  export type UserachievementAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserachievementSumAggregateOutputType = {
    progress: number | null
  }

  export type UserachievementMinAggregateOutputType = {
    id: string | null
    progress: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    achievementId: string | null
  }

  export type UserachievementMaxAggregateOutputType = {
    id: string | null
    progress: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    achievementId: string | null
  }

  export type UserachievementCountAggregateOutputType = {
    id: number
    progress: number
    isUnlocked: number
    unlockedAt: number
    createdAt: number
    updatedAt: number
    userId: number
    achievementId: number
    _all: number
  }


  export type UserachievementAvgAggregateInputType = {
    progress?: true
  }

  export type UserachievementSumAggregateInputType = {
    progress?: true
  }

  export type UserachievementMinAggregateInputType = {
    id?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    achievementId?: true
  }

  export type UserachievementMaxAggregateInputType = {
    id?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    achievementId?: true
  }

  export type UserachievementCountAggregateInputType = {
    id?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    achievementId?: true
    _all?: true
  }

  export type UserachievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Userachievement to aggregate.
     */
    where?: UserachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userachievements to fetch.
     */
    orderBy?: UserachievementOrderByWithRelationInput | UserachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userachievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Userachievements
    **/
    _count?: true | UserachievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserachievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserachievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserachievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserachievementMaxAggregateInputType
  }

  export type GetUserachievementAggregateType<T extends UserachievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserachievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserachievement[P]>
      : GetScalarType<T[P], AggregateUserachievement[P]>
  }




  export type UserachievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserachievementWhereInput
    orderBy?: UserachievementOrderByWithAggregationInput | UserachievementOrderByWithAggregationInput[]
    by: UserachievementScalarFieldEnum[] | UserachievementScalarFieldEnum
    having?: UserachievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserachievementCountAggregateInputType | true
    _avg?: UserachievementAvgAggregateInputType
    _sum?: UserachievementSumAggregateInputType
    _min?: UserachievementMinAggregateInputType
    _max?: UserachievementMaxAggregateInputType
  }

  export type UserachievementGroupByOutputType = {
    id: string
    progress: number
    isUnlocked: boolean
    unlockedAt: Date | null
    createdAt: Date
    updatedAt: Date | null
    userId: string
    achievementId: string
    _count: UserachievementCountAggregateOutputType | null
    _avg: UserachievementAvgAggregateOutputType | null
    _sum: UserachievementSumAggregateOutputType | null
    _min: UserachievementMinAggregateOutputType | null
    _max: UserachievementMaxAggregateOutputType | null
  }

  type GetUserachievementGroupByPayload<T extends UserachievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserachievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserachievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserachievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserachievementGroupByOutputType[P]>
        }
      >
    >


  export type UserachievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userachievement"]>

  export type UserachievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userachievement"]>

  export type UserachievementSelectScalar = {
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
  }

  export type UserachievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserachievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserachievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Userachievement"
    objects: {
      achievement: Prisma.$AchievementPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      progress: number
      isUnlocked: boolean
      unlockedAt: Date | null
      createdAt: Date
      updatedAt: Date | null
      userId: string
      achievementId: string
    }, ExtArgs["result"]["userachievement"]>
    composites: {}
  }

  type UserachievementGetPayload<S extends boolean | null | undefined | UserachievementDefaultArgs> = $Result.GetResult<Prisma.$UserachievementPayload, S>

  type UserachievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserachievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserachievementCountAggregateInputType | true
    }

  export interface UserachievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Userachievement'], meta: { name: 'Userachievement' } }
    /**
     * Find zero or one Userachievement that matches the filter.
     * @param {UserachievementFindUniqueArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserachievementFindUniqueArgs>(args: SelectSubset<T, UserachievementFindUniqueArgs<ExtArgs>>): Prisma__UserachievementClient<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Userachievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserachievementFindUniqueOrThrowArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserachievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserachievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserachievementClient<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Userachievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserachievementFindFirstArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserachievementFindFirstArgs>(args?: SelectSubset<T, UserachievementFindFirstArgs<ExtArgs>>): Prisma__UserachievementClient<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Userachievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserachievementFindFirstOrThrowArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserachievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserachievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserachievementClient<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Userachievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserachievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userachievements
     * const userachievements = await prisma.userachievement.findMany()
     * 
     * // Get first 10 Userachievements
     * const userachievements = await prisma.userachievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userachievementWithIdOnly = await prisma.userachievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserachievementFindManyArgs>(args?: SelectSubset<T, UserachievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Userachievement.
     * @param {UserachievementCreateArgs} args - Arguments to create a Userachievement.
     * @example
     * // Create one Userachievement
     * const Userachievement = await prisma.userachievement.create({
     *   data: {
     *     // ... data to create a Userachievement
     *   }
     * })
     * 
     */
    create<T extends UserachievementCreateArgs>(args: SelectSubset<T, UserachievementCreateArgs<ExtArgs>>): Prisma__UserachievementClient<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Userachievements.
     * @param {UserachievementCreateManyArgs} args - Arguments to create many Userachievements.
     * @example
     * // Create many Userachievements
     * const userachievement = await prisma.userachievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserachievementCreateManyArgs>(args?: SelectSubset<T, UserachievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userachievements and returns the data saved in the database.
     * @param {UserachievementCreateManyAndReturnArgs} args - Arguments to create many Userachievements.
     * @example
     * // Create many Userachievements
     * const userachievement = await prisma.userachievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userachievements and only return the `id`
     * const userachievementWithIdOnly = await prisma.userachievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserachievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserachievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Userachievement.
     * @param {UserachievementDeleteArgs} args - Arguments to delete one Userachievement.
     * @example
     * // Delete one Userachievement
     * const Userachievement = await prisma.userachievement.delete({
     *   where: {
     *     // ... filter to delete one Userachievement
     *   }
     * })
     * 
     */
    delete<T extends UserachievementDeleteArgs>(args: SelectSubset<T, UserachievementDeleteArgs<ExtArgs>>): Prisma__UserachievementClient<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Userachievement.
     * @param {UserachievementUpdateArgs} args - Arguments to update one Userachievement.
     * @example
     * // Update one Userachievement
     * const userachievement = await prisma.userachievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserachievementUpdateArgs>(args: SelectSubset<T, UserachievementUpdateArgs<ExtArgs>>): Prisma__UserachievementClient<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Userachievements.
     * @param {UserachievementDeleteManyArgs} args - Arguments to filter Userachievements to delete.
     * @example
     * // Delete a few Userachievements
     * const { count } = await prisma.userachievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserachievementDeleteManyArgs>(args?: SelectSubset<T, UserachievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userachievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserachievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userachievements
     * const userachievement = await prisma.userachievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserachievementUpdateManyArgs>(args: SelectSubset<T, UserachievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userachievement.
     * @param {UserachievementUpsertArgs} args - Arguments to update or create a Userachievement.
     * @example
     * // Update or create a Userachievement
     * const userachievement = await prisma.userachievement.upsert({
     *   create: {
     *     // ... data to create a Userachievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userachievement we want to update
     *   }
     * })
     */
    upsert<T extends UserachievementUpsertArgs>(args: SelectSubset<T, UserachievementUpsertArgs<ExtArgs>>): Prisma__UserachievementClient<$Result.GetResult<Prisma.$UserachievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Userachievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserachievementCountArgs} args - Arguments to filter Userachievements to count.
     * @example
     * // Count the number of Userachievements
     * const count = await prisma.userachievement.count({
     *   where: {
     *     // ... the filter for the Userachievements we want to count
     *   }
     * })
    **/
    count<T extends UserachievementCountArgs>(
      args?: Subset<T, UserachievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserachievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userachievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserachievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserachievementAggregateArgs>(args: Subset<T, UserachievementAggregateArgs>): Prisma.PrismaPromise<GetUserachievementAggregateType<T>>

    /**
     * Group by Userachievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserachievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserachievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserachievementGroupByArgs['orderBy'] }
        : { orderBy?: UserachievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserachievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserachievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Userachievement model
   */
  readonly fields: UserachievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Userachievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserachievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Userachievement model
   */ 
  interface UserachievementFieldRefs {
    readonly id: FieldRef<"Userachievement", 'String'>
    readonly progress: FieldRef<"Userachievement", 'Int'>
    readonly isUnlocked: FieldRef<"Userachievement", 'Boolean'>
    readonly unlockedAt: FieldRef<"Userachievement", 'DateTime'>
    readonly createdAt: FieldRef<"Userachievement", 'DateTime'>
    readonly updatedAt: FieldRef<"Userachievement", 'DateTime'>
    readonly userId: FieldRef<"Userachievement", 'String'>
    readonly achievementId: FieldRef<"Userachievement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Userachievement findUnique
   */
  export type UserachievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    /**
     * Filter, which Userachievement to fetch.
     */
    where: UserachievementWhereUniqueInput
  }

  /**
   * Userachievement findUniqueOrThrow
   */
  export type UserachievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    /**
     * Filter, which Userachievement to fetch.
     */
    where: UserachievementWhereUniqueInput
  }

  /**
   * Userachievement findFirst
   */
  export type UserachievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    /**
     * Filter, which Userachievement to fetch.
     */
    where?: UserachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userachievements to fetch.
     */
    orderBy?: UserachievementOrderByWithRelationInput | UserachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Userachievements.
     */
    cursor?: UserachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userachievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Userachievements.
     */
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * Userachievement findFirstOrThrow
   */
  export type UserachievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    /**
     * Filter, which Userachievement to fetch.
     */
    where?: UserachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userachievements to fetch.
     */
    orderBy?: UserachievementOrderByWithRelationInput | UserachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Userachievements.
     */
    cursor?: UserachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userachievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Userachievements.
     */
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * Userachievement findMany
   */
  export type UserachievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    /**
     * Filter, which Userachievements to fetch.
     */
    where?: UserachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Userachievements to fetch.
     */
    orderBy?: UserachievementOrderByWithRelationInput | UserachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Userachievements.
     */
    cursor?: UserachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Userachievements.
     */
    skip?: number
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * Userachievement create
   */
  export type UserachievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Userachievement.
     */
    data: XOR<UserachievementCreateInput, UserachievementUncheckedCreateInput>
  }

  /**
   * Userachievement createMany
   */
  export type UserachievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Userachievements.
     */
    data: UserachievementCreateManyInput | UserachievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Userachievement createManyAndReturn
   */
  export type UserachievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Userachievements.
     */
    data: UserachievementCreateManyInput | UserachievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Userachievement update
   */
  export type UserachievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Userachievement.
     */
    data: XOR<UserachievementUpdateInput, UserachievementUncheckedUpdateInput>
    /**
     * Choose, which Userachievement to update.
     */
    where: UserachievementWhereUniqueInput
  }

  /**
   * Userachievement updateMany
   */
  export type UserachievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Userachievements.
     */
    data: XOR<UserachievementUpdateManyMutationInput, UserachievementUncheckedUpdateManyInput>
    /**
     * Filter which Userachievements to update
     */
    where?: UserachievementWhereInput
  }

  /**
   * Userachievement upsert
   */
  export type UserachievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Userachievement to update in case it exists.
     */
    where: UserachievementWhereUniqueInput
    /**
     * In case the Userachievement found by the `where` argument doesn't exist, create a new Userachievement with this data.
     */
    create: XOR<UserachievementCreateInput, UserachievementUncheckedCreateInput>
    /**
     * In case the Userachievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserachievementUpdateInput, UserachievementUncheckedUpdateInput>
  }

  /**
   * Userachievement delete
   */
  export type UserachievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
    /**
     * Filter which Userachievement to delete.
     */
    where: UserachievementWhereUniqueInput
  }

  /**
   * Userachievement deleteMany
   */
  export type UserachievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Userachievements to delete
     */
    where?: UserachievementWhereInput
  }

  /**
   * Userachievement without action
   */
  export type UserachievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Userachievement
     */
    select?: UserachievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserachievementInclude<ExtArgs> | null
  }


  /**
   * Model RainBet
   */

  export type AggregateRainBet = {
    _count: RainBetCountAggregateOutputType | null
    _avg: RainBetAvgAggregateOutputType | null
    _sum: RainBetSumAggregateOutputType | null
    _min: RainBetMinAggregateOutputType | null
    _max: RainBetMaxAggregateOutputType | null
  }

  export type RainBetAvgAggregateOutputType = {
    betAmount: number | null
    odds: number | null
  }

  export type RainBetSumAggregateOutputType = {
    betAmount: number | null
    odds: number | null
  }

  export type RainBetMinAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    betAmount: number | null
    odds: number | null
    outcome: string | null
    settledAt: Date | null
  }

  export type RainBetMaxAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    betAmount: number | null
    odds: number | null
    outcome: string | null
    settledAt: Date | null
  }

  export type RainBetCountAggregateOutputType = {
    id: number
    rainHistoryId: number
    userId: number
    betAmount: number
    odds: number
    outcome: number
    settledAt: number
    _all: number
  }


  export type RainBetAvgAggregateInputType = {
    betAmount?: true
    odds?: true
  }

  export type RainBetSumAggregateInputType = {
    betAmount?: true
    odds?: true
  }

  export type RainBetMinAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    betAmount?: true
    odds?: true
    outcome?: true
    settledAt?: true
  }

  export type RainBetMaxAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    betAmount?: true
    odds?: true
    outcome?: true
    settledAt?: true
  }

  export type RainBetCountAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    betAmount?: true
    odds?: true
    outcome?: true
    settledAt?: true
    _all?: true
  }

  export type RainBetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainBet to aggregate.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainBets
    **/
    _count?: true | RainBetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainBetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainBetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainBetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainBetMaxAggregateInputType
  }

  export type GetRainBetAggregateType<T extends RainBetAggregateArgs> = {
        [P in keyof T & keyof AggregateRainBet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainBet[P]>
      : GetScalarType<T[P], AggregateRainBet[P]>
  }




  export type RainBetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainBetWhereInput
    orderBy?: RainBetOrderByWithAggregationInput | RainBetOrderByWithAggregationInput[]
    by: RainBetScalarFieldEnum[] | RainBetScalarFieldEnum
    having?: RainBetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainBetCountAggregateInputType | true
    _avg?: RainBetAvgAggregateInputType
    _sum?: RainBetSumAggregateInputType
    _min?: RainBetMinAggregateInputType
    _max?: RainBetMaxAggregateInputType
  }

  export type RainBetGroupByOutputType = {
    id: string
    rainHistoryId: string
    userId: string
    betAmount: number
    odds: number
    outcome: string | null
    settledAt: Date | null
    _count: RainBetCountAggregateOutputType | null
    _avg: RainBetAvgAggregateOutputType | null
    _sum: RainBetSumAggregateOutputType | null
    _min: RainBetMinAggregateOutputType | null
    _max: RainBetMaxAggregateOutputType | null
  }

  type GetRainBetGroupByPayload<T extends RainBetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainBetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainBetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainBetGroupByOutputType[P]>
            : GetScalarType<T[P], RainBetGroupByOutputType[P]>
        }
      >
    >


  export type RainBetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainBet"]>

  export type RainBetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainBet"]>

  export type RainBetSelectScalar = {
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
  }

  export type RainBetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RainBetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RainBetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainBet"
    objects: {
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rainHistoryId: string
      userId: string
      betAmount: number
      odds: number
      outcome: string | null
      settledAt: Date | null
    }, ExtArgs["result"]["rainBet"]>
    composites: {}
  }

  type RainBetGetPayload<S extends boolean | null | undefined | RainBetDefaultArgs> = $Result.GetResult<Prisma.$RainBetPayload, S>

  type RainBetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RainBetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RainBetCountAggregateInputType | true
    }

  export interface RainBetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainBet'], meta: { name: 'RainBet' } }
    /**
     * Find zero or one RainBet that matches the filter.
     * @param {RainBetFindUniqueArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainBetFindUniqueArgs>(args: SelectSubset<T, RainBetFindUniqueArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RainBet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RainBetFindUniqueOrThrowArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainBetFindUniqueOrThrowArgs>(args: SelectSubset<T, RainBetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RainBet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetFindFirstArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainBetFindFirstArgs>(args?: SelectSubset<T, RainBetFindFirstArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RainBet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetFindFirstOrThrowArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainBetFindFirstOrThrowArgs>(args?: SelectSubset<T, RainBetFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RainBets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainBets
     * const rainBets = await prisma.rainBet.findMany()
     * 
     * // Get first 10 RainBets
     * const rainBets = await prisma.rainBet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainBetWithIdOnly = await prisma.rainBet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainBetFindManyArgs>(args?: SelectSubset<T, RainBetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RainBet.
     * @param {RainBetCreateArgs} args - Arguments to create a RainBet.
     * @example
     * // Create one RainBet
     * const RainBet = await prisma.rainBet.create({
     *   data: {
     *     // ... data to create a RainBet
     *   }
     * })
     * 
     */
    create<T extends RainBetCreateArgs>(args: SelectSubset<T, RainBetCreateArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RainBets.
     * @param {RainBetCreateManyArgs} args - Arguments to create many RainBets.
     * @example
     * // Create many RainBets
     * const rainBet = await prisma.rainBet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainBetCreateManyArgs>(args?: SelectSubset<T, RainBetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainBets and returns the data saved in the database.
     * @param {RainBetCreateManyAndReturnArgs} args - Arguments to create many RainBets.
     * @example
     * // Create many RainBets
     * const rainBet = await prisma.rainBet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainBets and only return the `id`
     * const rainBetWithIdOnly = await prisma.rainBet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainBetCreateManyAndReturnArgs>(args?: SelectSubset<T, RainBetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RainBet.
     * @param {RainBetDeleteArgs} args - Arguments to delete one RainBet.
     * @example
     * // Delete one RainBet
     * const RainBet = await prisma.rainBet.delete({
     *   where: {
     *     // ... filter to delete one RainBet
     *   }
     * })
     * 
     */
    delete<T extends RainBetDeleteArgs>(args: SelectSubset<T, RainBetDeleteArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RainBet.
     * @param {RainBetUpdateArgs} args - Arguments to update one RainBet.
     * @example
     * // Update one RainBet
     * const rainBet = await prisma.rainBet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainBetUpdateArgs>(args: SelectSubset<T, RainBetUpdateArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RainBets.
     * @param {RainBetDeleteManyArgs} args - Arguments to filter RainBets to delete.
     * @example
     * // Delete a few RainBets
     * const { count } = await prisma.rainBet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainBetDeleteManyArgs>(args?: SelectSubset<T, RainBetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainBets
     * const rainBet = await prisma.rainBet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainBetUpdateManyArgs>(args: SelectSubset<T, RainBetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RainBet.
     * @param {RainBetUpsertArgs} args - Arguments to update or create a RainBet.
     * @example
     * // Update or create a RainBet
     * const rainBet = await prisma.rainBet.upsert({
     *   create: {
     *     // ... data to create a RainBet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainBet we want to update
     *   }
     * })
     */
    upsert<T extends RainBetUpsertArgs>(args: SelectSubset<T, RainBetUpsertArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RainBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetCountArgs} args - Arguments to filter RainBets to count.
     * @example
     * // Count the number of RainBets
     * const count = await prisma.rainBet.count({
     *   where: {
     *     // ... the filter for the RainBets we want to count
     *   }
     * })
    **/
    count<T extends RainBetCountArgs>(
      args?: Subset<T, RainBetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainBetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainBetAggregateArgs>(args: Subset<T, RainBetAggregateArgs>): Prisma.PrismaPromise<GetRainBetAggregateType<T>>

    /**
     * Group by RainBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainBetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainBetGroupByArgs['orderBy'] }
        : { orderBy?: RainBetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainBetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainBetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainBet model
   */
  readonly fields: RainBetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainBet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainBetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainHistory<T extends RainHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RainHistoryDefaultArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainBet model
   */ 
  interface RainBetFieldRefs {
    readonly id: FieldRef<"RainBet", 'String'>
    readonly rainHistoryId: FieldRef<"RainBet", 'String'>
    readonly userId: FieldRef<"RainBet", 'String'>
    readonly betAmount: FieldRef<"RainBet", 'Int'>
    readonly odds: FieldRef<"RainBet", 'Int'>
    readonly outcome: FieldRef<"RainBet", 'String'>
    readonly settledAt: FieldRef<"RainBet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainBet findUnique
   */
  export type RainBetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet findUniqueOrThrow
   */
  export type RainBetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet findFirst
   */
  export type RainBetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainBets.
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainBets.
     */
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainBet findFirstOrThrow
   */
  export type RainBetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainBets.
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainBets.
     */
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainBet findMany
   */
  export type RainBetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBets to fetch.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainBets.
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainBet create
   */
  export type RainBetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * The data needed to create a RainBet.
     */
    data: XOR<RainBetCreateInput, RainBetUncheckedCreateInput>
  }

  /**
   * RainBet createMany
   */
  export type RainBetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainBets.
     */
    data: RainBetCreateManyInput | RainBetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainBet createManyAndReturn
   */
  export type RainBetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RainBets.
     */
    data: RainBetCreateManyInput | RainBetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainBet update
   */
  export type RainBetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * The data needed to update a RainBet.
     */
    data: XOR<RainBetUpdateInput, RainBetUncheckedUpdateInput>
    /**
     * Choose, which RainBet to update.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet updateMany
   */
  export type RainBetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainBets.
     */
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyInput>
    /**
     * Filter which RainBets to update
     */
    where?: RainBetWhereInput
  }

  /**
   * RainBet upsert
   */
  export type RainBetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * The filter to search for the RainBet to update in case it exists.
     */
    where: RainBetWhereUniqueInput
    /**
     * In case the RainBet found by the `where` argument doesn't exist, create a new RainBet with this data.
     */
    create: XOR<RainBetCreateInput, RainBetUncheckedCreateInput>
    /**
     * In case the RainBet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainBetUpdateInput, RainBetUncheckedUpdateInput>
  }

  /**
   * RainBet delete
   */
  export type RainBetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter which RainBet to delete.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet deleteMany
   */
  export type RainBetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainBets to delete
     */
    where?: RainBetWhereInput
  }

  /**
   * RainBet without action
   */
  export type RainBetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
  }


  /**
   * Model RainHistory
   */

  export type AggregateRainHistory = {
    _count: RainHistoryCountAggregateOutputType | null
    _avg: RainHistoryAvgAggregateOutputType | null
    _sum: RainHistorySumAggregateOutputType | null
    _min: RainHistoryMinAggregateOutputType | null
    _max: RainHistoryMaxAggregateOutputType | null
  }

  export type RainHistoryAvgAggregateOutputType = {
    amount: number | null
  }

  export type RainHistorySumAggregateOutputType = {
    amount: number | null
  }

  export type RainHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    rainType: string | null
    createdAt: Date | null
  }

  export type RainHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    rainType: string | null
    createdAt: Date | null
  }

  export type RainHistoryCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    rainType: number
    createdAt: number
    _all: number
  }


  export type RainHistoryAvgAggregateInputType = {
    amount?: true
  }

  export type RainHistorySumAggregateInputType = {
    amount?: true
  }

  export type RainHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    rainType?: true
    createdAt?: true
  }

  export type RainHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    rainType?: true
    createdAt?: true
  }

  export type RainHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    rainType?: true
    createdAt?: true
    _all?: true
  }

  export type RainHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainHistory to aggregate.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainHistories
    **/
    _count?: true | RainHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainHistoryMaxAggregateInputType
  }

  export type GetRainHistoryAggregateType<T extends RainHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRainHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainHistory[P]>
      : GetScalarType<T[P], AggregateRainHistory[P]>
  }




  export type RainHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainHistoryWhereInput
    orderBy?: RainHistoryOrderByWithAggregationInput | RainHistoryOrderByWithAggregationInput[]
    by: RainHistoryScalarFieldEnum[] | RainHistoryScalarFieldEnum
    having?: RainHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainHistoryCountAggregateInputType | true
    _avg?: RainHistoryAvgAggregateInputType
    _sum?: RainHistorySumAggregateInputType
    _min?: RainHistoryMinAggregateInputType
    _max?: RainHistoryMaxAggregateInputType
  }

  export type RainHistoryGroupByOutputType = {
    id: string
    userId: string
    amount: number
    rainType: string
    createdAt: Date
    _count: RainHistoryCountAggregateOutputType | null
    _avg: RainHistoryAvgAggregateOutputType | null
    _sum: RainHistorySumAggregateOutputType | null
    _min: RainHistoryMinAggregateOutputType | null
    _max: RainHistoryMaxAggregateOutputType | null
  }

  type GetRainHistoryGroupByPayload<T extends RainHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], RainHistoryGroupByOutputType[P]>
        }
      >
    >


  export type RainHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
    RainBet?: boolean | RainHistory$RainBetArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    RainTip?: boolean | RainHistory$RainTipArgs<ExtArgs>
    RainWinner?: boolean | RainHistory$RainWinnerArgs<ExtArgs>
    _count?: boolean | RainHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainHistory"]>

  export type RainHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainHistory"]>

  export type RainHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
  }

  export type RainHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainBet?: boolean | RainHistory$RainBetArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    RainTip?: boolean | RainHistory$RainTipArgs<ExtArgs>
    RainWinner?: boolean | RainHistory$RainWinnerArgs<ExtArgs>
    _count?: boolean | RainHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RainHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RainHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainHistory"
    objects: {
      RainBet: Prisma.$RainBetPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      RainTip: Prisma.$RainTipPayload<ExtArgs>[]
      RainWinner: Prisma.$RainWinnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      rainType: string
      createdAt: Date
    }, ExtArgs["result"]["rainHistory"]>
    composites: {}
  }

  type RainHistoryGetPayload<S extends boolean | null | undefined | RainHistoryDefaultArgs> = $Result.GetResult<Prisma.$RainHistoryPayload, S>

  type RainHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RainHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RainHistoryCountAggregateInputType | true
    }

  export interface RainHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainHistory'], meta: { name: 'RainHistory' } }
    /**
     * Find zero or one RainHistory that matches the filter.
     * @param {RainHistoryFindUniqueArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainHistoryFindUniqueArgs>(args: SelectSubset<T, RainHistoryFindUniqueArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RainHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RainHistoryFindUniqueOrThrowArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, RainHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RainHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryFindFirstArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainHistoryFindFirstArgs>(args?: SelectSubset<T, RainHistoryFindFirstArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RainHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryFindFirstOrThrowArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, RainHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RainHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainHistories
     * const rainHistories = await prisma.rainHistory.findMany()
     * 
     * // Get first 10 RainHistories
     * const rainHistories = await prisma.rainHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainHistoryWithIdOnly = await prisma.rainHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainHistoryFindManyArgs>(args?: SelectSubset<T, RainHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RainHistory.
     * @param {RainHistoryCreateArgs} args - Arguments to create a RainHistory.
     * @example
     * // Create one RainHistory
     * const RainHistory = await prisma.rainHistory.create({
     *   data: {
     *     // ... data to create a RainHistory
     *   }
     * })
     * 
     */
    create<T extends RainHistoryCreateArgs>(args: SelectSubset<T, RainHistoryCreateArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RainHistories.
     * @param {RainHistoryCreateManyArgs} args - Arguments to create many RainHistories.
     * @example
     * // Create many RainHistories
     * const rainHistory = await prisma.rainHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainHistoryCreateManyArgs>(args?: SelectSubset<T, RainHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainHistories and returns the data saved in the database.
     * @param {RainHistoryCreateManyAndReturnArgs} args - Arguments to create many RainHistories.
     * @example
     * // Create many RainHistories
     * const rainHistory = await prisma.rainHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainHistories and only return the `id`
     * const rainHistoryWithIdOnly = await prisma.rainHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, RainHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RainHistory.
     * @param {RainHistoryDeleteArgs} args - Arguments to delete one RainHistory.
     * @example
     * // Delete one RainHistory
     * const RainHistory = await prisma.rainHistory.delete({
     *   where: {
     *     // ... filter to delete one RainHistory
     *   }
     * })
     * 
     */
    delete<T extends RainHistoryDeleteArgs>(args: SelectSubset<T, RainHistoryDeleteArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RainHistory.
     * @param {RainHistoryUpdateArgs} args - Arguments to update one RainHistory.
     * @example
     * // Update one RainHistory
     * const rainHistory = await prisma.rainHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainHistoryUpdateArgs>(args: SelectSubset<T, RainHistoryUpdateArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RainHistories.
     * @param {RainHistoryDeleteManyArgs} args - Arguments to filter RainHistories to delete.
     * @example
     * // Delete a few RainHistories
     * const { count } = await prisma.rainHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainHistoryDeleteManyArgs>(args?: SelectSubset<T, RainHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainHistories
     * const rainHistory = await prisma.rainHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainHistoryUpdateManyArgs>(args: SelectSubset<T, RainHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RainHistory.
     * @param {RainHistoryUpsertArgs} args - Arguments to update or create a RainHistory.
     * @example
     * // Update or create a RainHistory
     * const rainHistory = await prisma.rainHistory.upsert({
     *   create: {
     *     // ... data to create a RainHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainHistory we want to update
     *   }
     * })
     */
    upsert<T extends RainHistoryUpsertArgs>(args: SelectSubset<T, RainHistoryUpsertArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RainHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryCountArgs} args - Arguments to filter RainHistories to count.
     * @example
     * // Count the number of RainHistories
     * const count = await prisma.rainHistory.count({
     *   where: {
     *     // ... the filter for the RainHistories we want to count
     *   }
     * })
    **/
    count<T extends RainHistoryCountArgs>(
      args?: Subset<T, RainHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainHistoryAggregateArgs>(args: Subset<T, RainHistoryAggregateArgs>): Prisma.PrismaPromise<GetRainHistoryAggregateType<T>>

    /**
     * Group by RainHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainHistoryGroupByArgs['orderBy'] }
        : { orderBy?: RainHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainHistory model
   */
  readonly fields: RainHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainBet<T extends RainHistory$RainBetArgs<ExtArgs> = {}>(args?: Subset<T, RainHistory$RainBetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    RainTip<T extends RainHistory$RainTipArgs<ExtArgs> = {}>(args?: Subset<T, RainHistory$RainTipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findMany"> | Null>
    RainWinner<T extends RainHistory$RainWinnerArgs<ExtArgs> = {}>(args?: Subset<T, RainHistory$RainWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainHistory model
   */ 
  interface RainHistoryFieldRefs {
    readonly id: FieldRef<"RainHistory", 'String'>
    readonly userId: FieldRef<"RainHistory", 'String'>
    readonly amount: FieldRef<"RainHistory", 'Int'>
    readonly rainType: FieldRef<"RainHistory", 'String'>
    readonly createdAt: FieldRef<"RainHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainHistory findUnique
   */
  export type RainHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory findUniqueOrThrow
   */
  export type RainHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory findFirst
   */
  export type RainHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainHistories.
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainHistories.
     */
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * RainHistory findFirstOrThrow
   */
  export type RainHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainHistories.
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainHistories.
     */
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * RainHistory findMany
   */
  export type RainHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistories to fetch.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainHistories.
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * RainHistory create
   */
  export type RainHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RainHistory.
     */
    data: XOR<RainHistoryCreateInput, RainHistoryUncheckedCreateInput>
  }

  /**
   * RainHistory createMany
   */
  export type RainHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainHistories.
     */
    data: RainHistoryCreateManyInput | RainHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainHistory createManyAndReturn
   */
  export type RainHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RainHistories.
     */
    data: RainHistoryCreateManyInput | RainHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainHistory update
   */
  export type RainHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RainHistory.
     */
    data: XOR<RainHistoryUpdateInput, RainHistoryUncheckedUpdateInput>
    /**
     * Choose, which RainHistory to update.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory updateMany
   */
  export type RainHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainHistories.
     */
    data: XOR<RainHistoryUpdateManyMutationInput, RainHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RainHistories to update
     */
    where?: RainHistoryWhereInput
  }

  /**
   * RainHistory upsert
   */
  export type RainHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RainHistory to update in case it exists.
     */
    where: RainHistoryWhereUniqueInput
    /**
     * In case the RainHistory found by the `where` argument doesn't exist, create a new RainHistory with this data.
     */
    create: XOR<RainHistoryCreateInput, RainHistoryUncheckedCreateInput>
    /**
     * In case the RainHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainHistoryUpdateInput, RainHistoryUncheckedUpdateInput>
  }

  /**
   * RainHistory delete
   */
  export type RainHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter which RainHistory to delete.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory deleteMany
   */
  export type RainHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainHistories to delete
     */
    where?: RainHistoryWhereInput
  }

  /**
   * RainHistory.RainBet
   */
  export type RainHistory$RainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    where?: RainBetWhereInput
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    cursor?: RainBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainHistory.RainTip
   */
  export type RainHistory$RainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    where?: RainTipWhereInput
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    cursor?: RainTipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainHistory.RainWinner
   */
  export type RainHistory$RainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    where?: RainWinnerWhereInput
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    cursor?: RainWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainHistory without action
   */
  export type RainHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
  }


  /**
   * Model RainTip
   */

  export type AggregateRainTip = {
    _count: RainTipCountAggregateOutputType | null
    _avg: RainTipAvgAggregateOutputType | null
    _sum: RainTipSumAggregateOutputType | null
    _min: RainTipMinAggregateOutputType | null
    _max: RainTipMaxAggregateOutputType | null
  }

  export type RainTipAvgAggregateOutputType = {
    tipAmount: number | null
  }

  export type RainTipSumAggregateOutputType = {
    tipAmount: number | null
  }

  export type RainTipMinAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    tipAmount: number | null
    tippedAt: Date | null
  }

  export type RainTipMaxAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    tipAmount: number | null
    tippedAt: Date | null
  }

  export type RainTipCountAggregateOutputType = {
    id: number
    rainHistoryId: number
    userId: number
    tipAmount: number
    tippedAt: number
    _all: number
  }


  export type RainTipAvgAggregateInputType = {
    tipAmount?: true
  }

  export type RainTipSumAggregateInputType = {
    tipAmount?: true
  }

  export type RainTipMinAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    tipAmount?: true
    tippedAt?: true
  }

  export type RainTipMaxAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    tipAmount?: true
    tippedAt?: true
  }

  export type RainTipCountAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    tipAmount?: true
    tippedAt?: true
    _all?: true
  }

  export type RainTipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainTip to aggregate.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainTips
    **/
    _count?: true | RainTipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainTipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainTipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainTipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainTipMaxAggregateInputType
  }

  export type GetRainTipAggregateType<T extends RainTipAggregateArgs> = {
        [P in keyof T & keyof AggregateRainTip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainTip[P]>
      : GetScalarType<T[P], AggregateRainTip[P]>
  }




  export type RainTipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainTipWhereInput
    orderBy?: RainTipOrderByWithAggregationInput | RainTipOrderByWithAggregationInput[]
    by: RainTipScalarFieldEnum[] | RainTipScalarFieldEnum
    having?: RainTipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainTipCountAggregateInputType | true
    _avg?: RainTipAvgAggregateInputType
    _sum?: RainTipSumAggregateInputType
    _min?: RainTipMinAggregateInputType
    _max?: RainTipMaxAggregateInputType
  }

  export type RainTipGroupByOutputType = {
    id: string
    rainHistoryId: string
    userId: string
    tipAmount: number
    tippedAt: Date
    _count: RainTipCountAggregateOutputType | null
    _avg: RainTipAvgAggregateOutputType | null
    _sum: RainTipSumAggregateOutputType | null
    _min: RainTipMinAggregateOutputType | null
    _max: RainTipMaxAggregateOutputType | null
  }

  type GetRainTipGroupByPayload<T extends RainTipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainTipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainTipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainTipGroupByOutputType[P]>
            : GetScalarType<T[P], RainTipGroupByOutputType[P]>
        }
      >
    >


  export type RainTipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainTip"]>

  export type RainTipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainTip"]>

  export type RainTipSelectScalar = {
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
  }

  export type RainTipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RainTipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RainTipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainTip"
    objects: {
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rainHistoryId: string
      userId: string
      tipAmount: number
      tippedAt: Date
    }, ExtArgs["result"]["rainTip"]>
    composites: {}
  }

  type RainTipGetPayload<S extends boolean | null | undefined | RainTipDefaultArgs> = $Result.GetResult<Prisma.$RainTipPayload, S>

  type RainTipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RainTipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RainTipCountAggregateInputType | true
    }

  export interface RainTipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainTip'], meta: { name: 'RainTip' } }
    /**
     * Find zero or one RainTip that matches the filter.
     * @param {RainTipFindUniqueArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainTipFindUniqueArgs>(args: SelectSubset<T, RainTipFindUniqueArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RainTip that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RainTipFindUniqueOrThrowArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainTipFindUniqueOrThrowArgs>(args: SelectSubset<T, RainTipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RainTip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipFindFirstArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainTipFindFirstArgs>(args?: SelectSubset<T, RainTipFindFirstArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RainTip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipFindFirstOrThrowArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainTipFindFirstOrThrowArgs>(args?: SelectSubset<T, RainTipFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RainTips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainTips
     * const rainTips = await prisma.rainTip.findMany()
     * 
     * // Get first 10 RainTips
     * const rainTips = await prisma.rainTip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainTipWithIdOnly = await prisma.rainTip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainTipFindManyArgs>(args?: SelectSubset<T, RainTipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RainTip.
     * @param {RainTipCreateArgs} args - Arguments to create a RainTip.
     * @example
     * // Create one RainTip
     * const RainTip = await prisma.rainTip.create({
     *   data: {
     *     // ... data to create a RainTip
     *   }
     * })
     * 
     */
    create<T extends RainTipCreateArgs>(args: SelectSubset<T, RainTipCreateArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RainTips.
     * @param {RainTipCreateManyArgs} args - Arguments to create many RainTips.
     * @example
     * // Create many RainTips
     * const rainTip = await prisma.rainTip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainTipCreateManyArgs>(args?: SelectSubset<T, RainTipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainTips and returns the data saved in the database.
     * @param {RainTipCreateManyAndReturnArgs} args - Arguments to create many RainTips.
     * @example
     * // Create many RainTips
     * const rainTip = await prisma.rainTip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainTips and only return the `id`
     * const rainTipWithIdOnly = await prisma.rainTip.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainTipCreateManyAndReturnArgs>(args?: SelectSubset<T, RainTipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RainTip.
     * @param {RainTipDeleteArgs} args - Arguments to delete one RainTip.
     * @example
     * // Delete one RainTip
     * const RainTip = await prisma.rainTip.delete({
     *   where: {
     *     // ... filter to delete one RainTip
     *   }
     * })
     * 
     */
    delete<T extends RainTipDeleteArgs>(args: SelectSubset<T, RainTipDeleteArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RainTip.
     * @param {RainTipUpdateArgs} args - Arguments to update one RainTip.
     * @example
     * // Update one RainTip
     * const rainTip = await prisma.rainTip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainTipUpdateArgs>(args: SelectSubset<T, RainTipUpdateArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RainTips.
     * @param {RainTipDeleteManyArgs} args - Arguments to filter RainTips to delete.
     * @example
     * // Delete a few RainTips
     * const { count } = await prisma.rainTip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainTipDeleteManyArgs>(args?: SelectSubset<T, RainTipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainTips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainTips
     * const rainTip = await prisma.rainTip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainTipUpdateManyArgs>(args: SelectSubset<T, RainTipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RainTip.
     * @param {RainTipUpsertArgs} args - Arguments to update or create a RainTip.
     * @example
     * // Update or create a RainTip
     * const rainTip = await prisma.rainTip.upsert({
     *   create: {
     *     // ... data to create a RainTip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainTip we want to update
     *   }
     * })
     */
    upsert<T extends RainTipUpsertArgs>(args: SelectSubset<T, RainTipUpsertArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RainTips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipCountArgs} args - Arguments to filter RainTips to count.
     * @example
     * // Count the number of RainTips
     * const count = await prisma.rainTip.count({
     *   where: {
     *     // ... the filter for the RainTips we want to count
     *   }
     * })
    **/
    count<T extends RainTipCountArgs>(
      args?: Subset<T, RainTipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainTipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainTip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainTipAggregateArgs>(args: Subset<T, RainTipAggregateArgs>): Prisma.PrismaPromise<GetRainTipAggregateType<T>>

    /**
     * Group by RainTip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainTipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainTipGroupByArgs['orderBy'] }
        : { orderBy?: RainTipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainTipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainTipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainTip model
   */
  readonly fields: RainTipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainTip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainTipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainHistory<T extends RainHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RainHistoryDefaultArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainTip model
   */ 
  interface RainTipFieldRefs {
    readonly id: FieldRef<"RainTip", 'String'>
    readonly rainHistoryId: FieldRef<"RainTip", 'String'>
    readonly userId: FieldRef<"RainTip", 'String'>
    readonly tipAmount: FieldRef<"RainTip", 'Int'>
    readonly tippedAt: FieldRef<"RainTip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainTip findUnique
   */
  export type RainTipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip findUniqueOrThrow
   */
  export type RainTipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip findFirst
   */
  export type RainTipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainTips.
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainTips.
     */
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainTip findFirstOrThrow
   */
  export type RainTipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainTips.
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainTips.
     */
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainTip findMany
   */
  export type RainTipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTips to fetch.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainTips.
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainTip create
   */
  export type RainTipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * The data needed to create a RainTip.
     */
    data: XOR<RainTipCreateInput, RainTipUncheckedCreateInput>
  }

  /**
   * RainTip createMany
   */
  export type RainTipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainTips.
     */
    data: RainTipCreateManyInput | RainTipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainTip createManyAndReturn
   */
  export type RainTipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RainTips.
     */
    data: RainTipCreateManyInput | RainTipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainTip update
   */
  export type RainTipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * The data needed to update a RainTip.
     */
    data: XOR<RainTipUpdateInput, RainTipUncheckedUpdateInput>
    /**
     * Choose, which RainTip to update.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip updateMany
   */
  export type RainTipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainTips.
     */
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyInput>
    /**
     * Filter which RainTips to update
     */
    where?: RainTipWhereInput
  }

  /**
   * RainTip upsert
   */
  export type RainTipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * The filter to search for the RainTip to update in case it exists.
     */
    where: RainTipWhereUniqueInput
    /**
     * In case the RainTip found by the `where` argument doesn't exist, create a new RainTip with this data.
     */
    create: XOR<RainTipCreateInput, RainTipUncheckedCreateInput>
    /**
     * In case the RainTip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainTipUpdateInput, RainTipUncheckedUpdateInput>
  }

  /**
   * RainTip delete
   */
  export type RainTipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter which RainTip to delete.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip deleteMany
   */
  export type RainTipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainTips to delete
     */
    where?: RainTipWhereInput
  }

  /**
   * RainTip without action
   */
  export type RainTipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
  }


  /**
   * Model RainWinner
   */

  export type AggregateRainWinner = {
    _count: RainWinnerCountAggregateOutputType | null
    _avg: RainWinnerAvgAggregateOutputType | null
    _sum: RainWinnerSumAggregateOutputType | null
    _min: RainWinnerMinAggregateOutputType | null
    _max: RainWinnerMaxAggregateOutputType | null
  }

  export type RainWinnerAvgAggregateOutputType = {
    wonAmount: number | null
  }

  export type RainWinnerSumAggregateOutputType = {
    wonAmount: number | null
  }

  export type RainWinnerMinAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    wonAmount: number | null
    wonAt: Date | null
  }

  export type RainWinnerMaxAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    wonAmount: number | null
    wonAt: Date | null
  }

  export type RainWinnerCountAggregateOutputType = {
    id: number
    rainHistoryId: number
    userId: number
    wonAmount: number
    wonAt: number
    _all: number
  }


  export type RainWinnerAvgAggregateInputType = {
    wonAmount?: true
  }

  export type RainWinnerSumAggregateInputType = {
    wonAmount?: true
  }

  export type RainWinnerMinAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    wonAmount?: true
    wonAt?: true
  }

  export type RainWinnerMaxAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    wonAmount?: true
    wonAt?: true
  }

  export type RainWinnerCountAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    wonAmount?: true
    wonAt?: true
    _all?: true
  }

  export type RainWinnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainWinner to aggregate.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainWinners
    **/
    _count?: true | RainWinnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainWinnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainWinnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainWinnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainWinnerMaxAggregateInputType
  }

  export type GetRainWinnerAggregateType<T extends RainWinnerAggregateArgs> = {
        [P in keyof T & keyof AggregateRainWinner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainWinner[P]>
      : GetScalarType<T[P], AggregateRainWinner[P]>
  }




  export type RainWinnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainWinnerWhereInput
    orderBy?: RainWinnerOrderByWithAggregationInput | RainWinnerOrderByWithAggregationInput[]
    by: RainWinnerScalarFieldEnum[] | RainWinnerScalarFieldEnum
    having?: RainWinnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainWinnerCountAggregateInputType | true
    _avg?: RainWinnerAvgAggregateInputType
    _sum?: RainWinnerSumAggregateInputType
    _min?: RainWinnerMinAggregateInputType
    _max?: RainWinnerMaxAggregateInputType
  }

  export type RainWinnerGroupByOutputType = {
    id: string
    rainHistoryId: string
    userId: string
    wonAmount: number
    wonAt: Date
    _count: RainWinnerCountAggregateOutputType | null
    _avg: RainWinnerAvgAggregateOutputType | null
    _sum: RainWinnerSumAggregateOutputType | null
    _min: RainWinnerMinAggregateOutputType | null
    _max: RainWinnerMaxAggregateOutputType | null
  }

  type GetRainWinnerGroupByPayload<T extends RainWinnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainWinnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainWinnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainWinnerGroupByOutputType[P]>
            : GetScalarType<T[P], RainWinnerGroupByOutputType[P]>
        }
      >
    >


  export type RainWinnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainWinner"]>

  export type RainWinnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainWinner"]>

  export type RainWinnerSelectScalar = {
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
  }

  export type RainWinnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RainWinnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RainWinnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainWinner"
    objects: {
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rainHistoryId: string
      userId: string
      wonAmount: number
      wonAt: Date
    }, ExtArgs["result"]["rainWinner"]>
    composites: {}
  }

  type RainWinnerGetPayload<S extends boolean | null | undefined | RainWinnerDefaultArgs> = $Result.GetResult<Prisma.$RainWinnerPayload, S>

  type RainWinnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RainWinnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RainWinnerCountAggregateInputType | true
    }

  export interface RainWinnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainWinner'], meta: { name: 'RainWinner' } }
    /**
     * Find zero or one RainWinner that matches the filter.
     * @param {RainWinnerFindUniqueArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainWinnerFindUniqueArgs>(args: SelectSubset<T, RainWinnerFindUniqueArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RainWinner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RainWinnerFindUniqueOrThrowArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainWinnerFindUniqueOrThrowArgs>(args: SelectSubset<T, RainWinnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RainWinner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerFindFirstArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainWinnerFindFirstArgs>(args?: SelectSubset<T, RainWinnerFindFirstArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RainWinner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerFindFirstOrThrowArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainWinnerFindFirstOrThrowArgs>(args?: SelectSubset<T, RainWinnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RainWinners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainWinners
     * const rainWinners = await prisma.rainWinner.findMany()
     * 
     * // Get first 10 RainWinners
     * const rainWinners = await prisma.rainWinner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainWinnerWithIdOnly = await prisma.rainWinner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainWinnerFindManyArgs>(args?: SelectSubset<T, RainWinnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RainWinner.
     * @param {RainWinnerCreateArgs} args - Arguments to create a RainWinner.
     * @example
     * // Create one RainWinner
     * const RainWinner = await prisma.rainWinner.create({
     *   data: {
     *     // ... data to create a RainWinner
     *   }
     * })
     * 
     */
    create<T extends RainWinnerCreateArgs>(args: SelectSubset<T, RainWinnerCreateArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RainWinners.
     * @param {RainWinnerCreateManyArgs} args - Arguments to create many RainWinners.
     * @example
     * // Create many RainWinners
     * const rainWinner = await prisma.rainWinner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainWinnerCreateManyArgs>(args?: SelectSubset<T, RainWinnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainWinners and returns the data saved in the database.
     * @param {RainWinnerCreateManyAndReturnArgs} args - Arguments to create many RainWinners.
     * @example
     * // Create many RainWinners
     * const rainWinner = await prisma.rainWinner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainWinners and only return the `id`
     * const rainWinnerWithIdOnly = await prisma.rainWinner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainWinnerCreateManyAndReturnArgs>(args?: SelectSubset<T, RainWinnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RainWinner.
     * @param {RainWinnerDeleteArgs} args - Arguments to delete one RainWinner.
     * @example
     * // Delete one RainWinner
     * const RainWinner = await prisma.rainWinner.delete({
     *   where: {
     *     // ... filter to delete one RainWinner
     *   }
     * })
     * 
     */
    delete<T extends RainWinnerDeleteArgs>(args: SelectSubset<T, RainWinnerDeleteArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RainWinner.
     * @param {RainWinnerUpdateArgs} args - Arguments to update one RainWinner.
     * @example
     * // Update one RainWinner
     * const rainWinner = await prisma.rainWinner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainWinnerUpdateArgs>(args: SelectSubset<T, RainWinnerUpdateArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RainWinners.
     * @param {RainWinnerDeleteManyArgs} args - Arguments to filter RainWinners to delete.
     * @example
     * // Delete a few RainWinners
     * const { count } = await prisma.rainWinner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainWinnerDeleteManyArgs>(args?: SelectSubset<T, RainWinnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainWinners
     * const rainWinner = await prisma.rainWinner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainWinnerUpdateManyArgs>(args: SelectSubset<T, RainWinnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RainWinner.
     * @param {RainWinnerUpsertArgs} args - Arguments to update or create a RainWinner.
     * @example
     * // Update or create a RainWinner
     * const rainWinner = await prisma.rainWinner.upsert({
     *   create: {
     *     // ... data to create a RainWinner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainWinner we want to update
     *   }
     * })
     */
    upsert<T extends RainWinnerUpsertArgs>(args: SelectSubset<T, RainWinnerUpsertArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RainWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerCountArgs} args - Arguments to filter RainWinners to count.
     * @example
     * // Count the number of RainWinners
     * const count = await prisma.rainWinner.count({
     *   where: {
     *     // ... the filter for the RainWinners we want to count
     *   }
     * })
    **/
    count<T extends RainWinnerCountArgs>(
      args?: Subset<T, RainWinnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainWinnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainWinnerAggregateArgs>(args: Subset<T, RainWinnerAggregateArgs>): Prisma.PrismaPromise<GetRainWinnerAggregateType<T>>

    /**
     * Group by RainWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainWinnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainWinnerGroupByArgs['orderBy'] }
        : { orderBy?: RainWinnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainWinnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainWinnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainWinner model
   */
  readonly fields: RainWinnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainWinner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainWinnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainHistory<T extends RainHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RainHistoryDefaultArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainWinner model
   */ 
  interface RainWinnerFieldRefs {
    readonly id: FieldRef<"RainWinner", 'String'>
    readonly rainHistoryId: FieldRef<"RainWinner", 'String'>
    readonly userId: FieldRef<"RainWinner", 'String'>
    readonly wonAmount: FieldRef<"RainWinner", 'Int'>
    readonly wonAt: FieldRef<"RainWinner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainWinner findUnique
   */
  export type RainWinnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner findUniqueOrThrow
   */
  export type RainWinnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner findFirst
   */
  export type RainWinnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainWinners.
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainWinners.
     */
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainWinner findFirstOrThrow
   */
  export type RainWinnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainWinners.
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainWinners.
     */
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainWinner findMany
   */
  export type RainWinnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinners to fetch.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainWinners.
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainWinner create
   */
  export type RainWinnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * The data needed to create a RainWinner.
     */
    data: XOR<RainWinnerCreateInput, RainWinnerUncheckedCreateInput>
  }

  /**
   * RainWinner createMany
   */
  export type RainWinnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainWinners.
     */
    data: RainWinnerCreateManyInput | RainWinnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainWinner createManyAndReturn
   */
  export type RainWinnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RainWinners.
     */
    data: RainWinnerCreateManyInput | RainWinnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainWinner update
   */
  export type RainWinnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * The data needed to update a RainWinner.
     */
    data: XOR<RainWinnerUpdateInput, RainWinnerUncheckedUpdateInput>
    /**
     * Choose, which RainWinner to update.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner updateMany
   */
  export type RainWinnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainWinners.
     */
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyInput>
    /**
     * Filter which RainWinners to update
     */
    where?: RainWinnerWhereInput
  }

  /**
   * RainWinner upsert
   */
  export type RainWinnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * The filter to search for the RainWinner to update in case it exists.
     */
    where: RainWinnerWhereUniqueInput
    /**
     * In case the RainWinner found by the `where` argument doesn't exist, create a new RainWinner with this data.
     */
    create: XOR<RainWinnerCreateInput, RainWinnerUncheckedCreateInput>
    /**
     * In case the RainWinner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainWinnerUpdateInput, RainWinnerUncheckedUpdateInput>
  }

  /**
   * RainWinner delete
   */
  export type RainWinnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter which RainWinner to delete.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner deleteMany
   */
  export type RainWinnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainWinners to delete
     */
    where?: RainWinnerWhereInput
  }

  /**
   * RainWinner without action
   */
  export type RainWinnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
  }


  /**
   * Model VipInfo
   */

  export type AggregateVipInfo = {
    _count: VipInfoCountAggregateOutputType | null
    _avg: VipInfoAvgAggregateOutputType | null
    _sum: VipInfoSumAggregateOutputType | null
    _min: VipInfoMinAggregateOutputType | null
    _max: VipInfoMaxAggregateOutputType | null
  }

  export type VipInfoAvgAggregateOutputType = {
    level: number | null
    deposit_exp: number | null
    bet_exp: number | null
    rank_bet_exp: number | null
    rank_deposit_exp: number | null
    exp_switch_type: number | null
    protection_days: number | null
    protection_switch: number | null
    unprotection_days: number | null
    unprotection_switch: number | null
    free_spin_times: number | null
    week_gift: number | null
    month_gift: number | null
    upgrade_gift: number | null
    now_cash_back: number | null
    yesterday_cash_back: number | null
    history_cash_back: number | null
  }

  export type VipInfoSumAggregateOutputType = {
    level: number | null
    deposit_exp: number | null
    bet_exp: number | null
    rank_bet_exp: number | null
    rank_deposit_exp: number | null
    exp_switch_type: number | null
    protection_days: number | null
    protection_switch: number | null
    unprotection_days: number | null
    unprotection_switch: number | null
    free_spin_times: number | null
    week_gift: number | null
    month_gift: number | null
    upgrade_gift: number | null
    now_cash_back: number | null
    yesterday_cash_back: number | null
    history_cash_back: number | null
  }

  export type VipInfoMinAggregateOutputType = {
    id: string | null
    level: number | null
    deposit_exp: number | null
    bet_exp: number | null
    rank_bet_exp: number | null
    rank_deposit_exp: number | null
    rank_name: string | null
    icon: string | null
    exp_switch_type: number | null
    now_deposit_exp: string | null
    level_deposit_exp: string | null
    now_bet_exp: string | null
    level_bet_exp: string | null
    telegram: string | null
    is_protection: boolean | null
    protection_deposit_exp: string | null
    protection_deposit_amount: string | null
    protection_bet_exp: string | null
    protection_bet_amount: string | null
    protection_days: number | null
    protection_switch: number | null
    cycle_award_switch: boolean | null
    level_award_switch: boolean | null
    signin_award_switch: boolean | null
    bet_award_switch: boolean | null
    withdrawal_award_switch: boolean | null
    unprotection_deposit_exp: string | null
    unprotection_deposit_amount: string | null
    unprotection_bet_exp: string | null
    unprotection_bet_amount: string | null
    unprotection_days: number | null
    unprotection_switch: number | null
    main_currency: string | null
    can_receive_level_award: boolean | null
    can_receive_rank_award: boolean | null
    can_receive_day_award: boolean | null
    can_receive_week_award: boolean | null
    can_receive_month_award: boolean | null
    can_receive_signin_award: boolean | null
    can_receive_bet_award: boolean | null
    can_receive_withdrawal_award: boolean | null
    userid: string | null
    free_spin_times: number | null
    week_gift: number | null
    month_gift: number | null
    upgrade_gift: number | null
    now_cash_back: number | null
    yesterday_cash_back: number | null
    history_cash_back: number | null
    operatorId: string | null
  }

  export type VipInfoMaxAggregateOutputType = {
    id: string | null
    level: number | null
    deposit_exp: number | null
    bet_exp: number | null
    rank_bet_exp: number | null
    rank_deposit_exp: number | null
    rank_name: string | null
    icon: string | null
    exp_switch_type: number | null
    now_deposit_exp: string | null
    level_deposit_exp: string | null
    now_bet_exp: string | null
    level_bet_exp: string | null
    telegram: string | null
    is_protection: boolean | null
    protection_deposit_exp: string | null
    protection_deposit_amount: string | null
    protection_bet_exp: string | null
    protection_bet_amount: string | null
    protection_days: number | null
    protection_switch: number | null
    cycle_award_switch: boolean | null
    level_award_switch: boolean | null
    signin_award_switch: boolean | null
    bet_award_switch: boolean | null
    withdrawal_award_switch: boolean | null
    unprotection_deposit_exp: string | null
    unprotection_deposit_amount: string | null
    unprotection_bet_exp: string | null
    unprotection_bet_amount: string | null
    unprotection_days: number | null
    unprotection_switch: number | null
    main_currency: string | null
    can_receive_level_award: boolean | null
    can_receive_rank_award: boolean | null
    can_receive_day_award: boolean | null
    can_receive_week_award: boolean | null
    can_receive_month_award: boolean | null
    can_receive_signin_award: boolean | null
    can_receive_bet_award: boolean | null
    can_receive_withdrawal_award: boolean | null
    userid: string | null
    free_spin_times: number | null
    week_gift: number | null
    month_gift: number | null
    upgrade_gift: number | null
    now_cash_back: number | null
    yesterday_cash_back: number | null
    history_cash_back: number | null
    operatorId: string | null
  }

  export type VipInfoCountAggregateOutputType = {
    id: number
    level: number
    deposit_exp: number
    bet_exp: number
    rank_bet_exp: number
    rank_deposit_exp: number
    rank_name: number
    icon: number
    exp_switch_type: number
    now_deposit_exp: number
    level_deposit_exp: number
    now_bet_exp: number
    level_bet_exp: number
    telegram: number
    is_protection: number
    protection_deposit_exp: number
    protection_deposit_amount: number
    protection_bet_exp: number
    protection_bet_amount: number
    protection_days: number
    protection_switch: number
    cycle_award_switch: number
    level_award_switch: number
    signin_award_switch: number
    bet_award_switch: number
    withdrawal_award_switch: number
    unprotection_deposit_exp: number
    unprotection_deposit_amount: number
    unprotection_bet_exp: number
    unprotection_bet_amount: number
    unprotection_days: number
    unprotection_switch: number
    main_currency: number
    can_receive_level_award: number
    can_receive_rank_award: number
    can_receive_day_award: number
    can_receive_week_award: number
    can_receive_month_award: number
    can_receive_signin_award: number
    can_receive_bet_award: number
    can_receive_withdrawal_award: number
    userid: number
    free_spin_times: number
    week_gift: number
    month_gift: number
    upgrade_gift: number
    now_cash_back: number
    yesterday_cash_back: number
    history_cash_back: number
    operatorId: number
    _all: number
  }


  export type VipInfoAvgAggregateInputType = {
    level?: true
    deposit_exp?: true
    bet_exp?: true
    rank_bet_exp?: true
    rank_deposit_exp?: true
    exp_switch_type?: true
    protection_days?: true
    protection_switch?: true
    unprotection_days?: true
    unprotection_switch?: true
    free_spin_times?: true
    week_gift?: true
    month_gift?: true
    upgrade_gift?: true
    now_cash_back?: true
    yesterday_cash_back?: true
    history_cash_back?: true
  }

  export type VipInfoSumAggregateInputType = {
    level?: true
    deposit_exp?: true
    bet_exp?: true
    rank_bet_exp?: true
    rank_deposit_exp?: true
    exp_switch_type?: true
    protection_days?: true
    protection_switch?: true
    unprotection_days?: true
    unprotection_switch?: true
    free_spin_times?: true
    week_gift?: true
    month_gift?: true
    upgrade_gift?: true
    now_cash_back?: true
    yesterday_cash_back?: true
    history_cash_back?: true
  }

  export type VipInfoMinAggregateInputType = {
    id?: true
    level?: true
    deposit_exp?: true
    bet_exp?: true
    rank_bet_exp?: true
    rank_deposit_exp?: true
    rank_name?: true
    icon?: true
    exp_switch_type?: true
    now_deposit_exp?: true
    level_deposit_exp?: true
    now_bet_exp?: true
    level_bet_exp?: true
    telegram?: true
    is_protection?: true
    protection_deposit_exp?: true
    protection_deposit_amount?: true
    protection_bet_exp?: true
    protection_bet_amount?: true
    protection_days?: true
    protection_switch?: true
    cycle_award_switch?: true
    level_award_switch?: true
    signin_award_switch?: true
    bet_award_switch?: true
    withdrawal_award_switch?: true
    unprotection_deposit_exp?: true
    unprotection_deposit_amount?: true
    unprotection_bet_exp?: true
    unprotection_bet_amount?: true
    unprotection_days?: true
    unprotection_switch?: true
    main_currency?: true
    can_receive_level_award?: true
    can_receive_rank_award?: true
    can_receive_day_award?: true
    can_receive_week_award?: true
    can_receive_month_award?: true
    can_receive_signin_award?: true
    can_receive_bet_award?: true
    can_receive_withdrawal_award?: true
    userid?: true
    free_spin_times?: true
    week_gift?: true
    month_gift?: true
    upgrade_gift?: true
    now_cash_back?: true
    yesterday_cash_back?: true
    history_cash_back?: true
    operatorId?: true
  }

  export type VipInfoMaxAggregateInputType = {
    id?: true
    level?: true
    deposit_exp?: true
    bet_exp?: true
    rank_bet_exp?: true
    rank_deposit_exp?: true
    rank_name?: true
    icon?: true
    exp_switch_type?: true
    now_deposit_exp?: true
    level_deposit_exp?: true
    now_bet_exp?: true
    level_bet_exp?: true
    telegram?: true
    is_protection?: true
    protection_deposit_exp?: true
    protection_deposit_amount?: true
    protection_bet_exp?: true
    protection_bet_amount?: true
    protection_days?: true
    protection_switch?: true
    cycle_award_switch?: true
    level_award_switch?: true
    signin_award_switch?: true
    bet_award_switch?: true
    withdrawal_award_switch?: true
    unprotection_deposit_exp?: true
    unprotection_deposit_amount?: true
    unprotection_bet_exp?: true
    unprotection_bet_amount?: true
    unprotection_days?: true
    unprotection_switch?: true
    main_currency?: true
    can_receive_level_award?: true
    can_receive_rank_award?: true
    can_receive_day_award?: true
    can_receive_week_award?: true
    can_receive_month_award?: true
    can_receive_signin_award?: true
    can_receive_bet_award?: true
    can_receive_withdrawal_award?: true
    userid?: true
    free_spin_times?: true
    week_gift?: true
    month_gift?: true
    upgrade_gift?: true
    now_cash_back?: true
    yesterday_cash_back?: true
    history_cash_back?: true
    operatorId?: true
  }

  export type VipInfoCountAggregateInputType = {
    id?: true
    level?: true
    deposit_exp?: true
    bet_exp?: true
    rank_bet_exp?: true
    rank_deposit_exp?: true
    rank_name?: true
    icon?: true
    exp_switch_type?: true
    now_deposit_exp?: true
    level_deposit_exp?: true
    now_bet_exp?: true
    level_bet_exp?: true
    telegram?: true
    is_protection?: true
    protection_deposit_exp?: true
    protection_deposit_amount?: true
    protection_bet_exp?: true
    protection_bet_amount?: true
    protection_days?: true
    protection_switch?: true
    cycle_award_switch?: true
    level_award_switch?: true
    signin_award_switch?: true
    bet_award_switch?: true
    withdrawal_award_switch?: true
    unprotection_deposit_exp?: true
    unprotection_deposit_amount?: true
    unprotection_bet_exp?: true
    unprotection_bet_amount?: true
    unprotection_days?: true
    unprotection_switch?: true
    main_currency?: true
    can_receive_level_award?: true
    can_receive_rank_award?: true
    can_receive_day_award?: true
    can_receive_week_award?: true
    can_receive_month_award?: true
    can_receive_signin_award?: true
    can_receive_bet_award?: true
    can_receive_withdrawal_award?: true
    userid?: true
    free_spin_times?: true
    week_gift?: true
    month_gift?: true
    upgrade_gift?: true
    now_cash_back?: true
    yesterday_cash_back?: true
    history_cash_back?: true
    operatorId?: true
    _all?: true
  }

  export type VipInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VipInfo to aggregate.
     */
    where?: VipInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipInfos to fetch.
     */
    orderBy?: VipInfoOrderByWithRelationInput | VipInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VipInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VipInfos
    **/
    _count?: true | VipInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VipInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VipInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VipInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VipInfoMaxAggregateInputType
  }

  export type GetVipInfoAggregateType<T extends VipInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateVipInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVipInfo[P]>
      : GetScalarType<T[P], AggregateVipInfo[P]>
  }




  export type VipInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VipInfoWhereInput
    orderBy?: VipInfoOrderByWithAggregationInput | VipInfoOrderByWithAggregationInput[]
    by: VipInfoScalarFieldEnum[] | VipInfoScalarFieldEnum
    having?: VipInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VipInfoCountAggregateInputType | true
    _avg?: VipInfoAvgAggregateInputType
    _sum?: VipInfoSumAggregateInputType
    _min?: VipInfoMinAggregateInputType
    _max?: VipInfoMaxAggregateInputType
  }

  export type VipInfoGroupByOutputType = {
    id: string
    level: number
    deposit_exp: number
    bet_exp: number
    rank_bet_exp: number
    rank_deposit_exp: number
    rank_name: string | null
    icon: string | null
    exp_switch_type: number | null
    now_deposit_exp: string | null
    level_deposit_exp: string | null
    now_bet_exp: string | null
    level_bet_exp: string | null
    telegram: string | null
    is_protection: boolean
    protection_deposit_exp: string | null
    protection_deposit_amount: string | null
    protection_bet_exp: string | null
    protection_bet_amount: string | null
    protection_days: number | null
    protection_switch: number | null
    cycle_award_switch: boolean
    level_award_switch: boolean
    signin_award_switch: boolean
    bet_award_switch: boolean
    withdrawal_award_switch: boolean
    unprotection_deposit_exp: string | null
    unprotection_deposit_amount: string | null
    unprotection_bet_exp: string | null
    unprotection_bet_amount: string | null
    unprotection_days: number | null
    unprotection_switch: number | null
    main_currency: string | null
    can_receive_level_award: boolean
    can_receive_rank_award: boolean
    can_receive_day_award: boolean
    can_receive_week_award: boolean
    can_receive_month_award: boolean
    can_receive_signin_award: boolean
    can_receive_bet_award: boolean
    can_receive_withdrawal_award: boolean
    userid: string | null
    free_spin_times: number | null
    week_gift: number | null
    month_gift: number | null
    upgrade_gift: number | null
    now_cash_back: number | null
    yesterday_cash_back: number | null
    history_cash_back: number | null
    operatorId: string | null
    _count: VipInfoCountAggregateOutputType | null
    _avg: VipInfoAvgAggregateOutputType | null
    _sum: VipInfoSumAggregateOutputType | null
    _min: VipInfoMinAggregateOutputType | null
    _max: VipInfoMaxAggregateOutputType | null
  }

  type GetVipInfoGroupByPayload<T extends VipInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VipInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VipInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VipInfoGroupByOutputType[P]>
            : GetScalarType<T[P], VipInfoGroupByOutputType[P]>
        }
      >
    >


  export type VipInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    deposit_exp?: boolean
    bet_exp?: boolean
    rank_bet_exp?: boolean
    rank_deposit_exp?: boolean
    rank_name?: boolean
    icon?: boolean
    exp_switch_type?: boolean
    now_deposit_exp?: boolean
    level_deposit_exp?: boolean
    now_bet_exp?: boolean
    level_bet_exp?: boolean
    telegram?: boolean
    is_protection?: boolean
    protection_deposit_exp?: boolean
    protection_deposit_amount?: boolean
    protection_bet_exp?: boolean
    protection_bet_amount?: boolean
    protection_days?: boolean
    protection_switch?: boolean
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: boolean
    unprotection_deposit_amount?: boolean
    unprotection_bet_exp?: boolean
    unprotection_bet_amount?: boolean
    unprotection_days?: boolean
    unprotection_switch?: boolean
    main_currency?: boolean
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: boolean
    free_spin_times?: boolean
    week_gift?: boolean
    month_gift?: boolean
    upgrade_gift?: boolean
    now_cash_back?: boolean
    yesterday_cash_back?: boolean
    history_cash_back?: boolean
    operatorId?: boolean
    gamesession?: boolean | VipInfo$gamesessionArgs<ExtArgs>
    operator?: boolean | VipInfo$operatorArgs<ExtArgs>
    transactions?: boolean | VipInfo$transactionsArgs<ExtArgs>
    user?: boolean | VipInfo$userArgs<ExtArgs>
    _count?: boolean | VipInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipInfo"]>

  export type VipInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    deposit_exp?: boolean
    bet_exp?: boolean
    rank_bet_exp?: boolean
    rank_deposit_exp?: boolean
    rank_name?: boolean
    icon?: boolean
    exp_switch_type?: boolean
    now_deposit_exp?: boolean
    level_deposit_exp?: boolean
    now_bet_exp?: boolean
    level_bet_exp?: boolean
    telegram?: boolean
    is_protection?: boolean
    protection_deposit_exp?: boolean
    protection_deposit_amount?: boolean
    protection_bet_exp?: boolean
    protection_bet_amount?: boolean
    protection_days?: boolean
    protection_switch?: boolean
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: boolean
    unprotection_deposit_amount?: boolean
    unprotection_bet_exp?: boolean
    unprotection_bet_amount?: boolean
    unprotection_days?: boolean
    unprotection_switch?: boolean
    main_currency?: boolean
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: boolean
    free_spin_times?: boolean
    week_gift?: boolean
    month_gift?: boolean
    upgrade_gift?: boolean
    now_cash_back?: boolean
    yesterday_cash_back?: boolean
    history_cash_back?: boolean
    operatorId?: boolean
    operator?: boolean | VipInfo$operatorArgs<ExtArgs>
    user?: boolean | VipInfo$userArgs<ExtArgs>
  }, ExtArgs["result"]["vipInfo"]>

  export type VipInfoSelectScalar = {
    id?: boolean
    level?: boolean
    deposit_exp?: boolean
    bet_exp?: boolean
    rank_bet_exp?: boolean
    rank_deposit_exp?: boolean
    rank_name?: boolean
    icon?: boolean
    exp_switch_type?: boolean
    now_deposit_exp?: boolean
    level_deposit_exp?: boolean
    now_bet_exp?: boolean
    level_bet_exp?: boolean
    telegram?: boolean
    is_protection?: boolean
    protection_deposit_exp?: boolean
    protection_deposit_amount?: boolean
    protection_bet_exp?: boolean
    protection_bet_amount?: boolean
    protection_days?: boolean
    protection_switch?: boolean
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: boolean
    unprotection_deposit_amount?: boolean
    unprotection_bet_exp?: boolean
    unprotection_bet_amount?: boolean
    unprotection_days?: boolean
    unprotection_switch?: boolean
    main_currency?: boolean
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: boolean
    free_spin_times?: boolean
    week_gift?: boolean
    month_gift?: boolean
    upgrade_gift?: boolean
    now_cash_back?: boolean
    yesterday_cash_back?: boolean
    history_cash_back?: boolean
    operatorId?: boolean
  }

  export type VipInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | VipInfo$gamesessionArgs<ExtArgs>
    operator?: boolean | VipInfo$operatorArgs<ExtArgs>
    transactions?: boolean | VipInfo$transactionsArgs<ExtArgs>
    user?: boolean | VipInfo$userArgs<ExtArgs>
    _count?: boolean | VipInfoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VipInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | VipInfo$operatorArgs<ExtArgs>
    user?: boolean | VipInfo$userArgs<ExtArgs>
  }

  export type $VipInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VipInfo"
    objects: {
      gamesession: Prisma.$GamesessionPayload<ExtArgs>[]
      operator: Prisma.$OperatorPayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: number
      deposit_exp: number
      bet_exp: number
      rank_bet_exp: number
      rank_deposit_exp: number
      rank_name: string | null
      icon: string | null
      exp_switch_type: number | null
      now_deposit_exp: string | null
      level_deposit_exp: string | null
      now_bet_exp: string | null
      level_bet_exp: string | null
      telegram: string | null
      is_protection: boolean
      protection_deposit_exp: string | null
      protection_deposit_amount: string | null
      protection_bet_exp: string | null
      protection_bet_amount: string | null
      protection_days: number | null
      protection_switch: number | null
      cycle_award_switch: boolean
      level_award_switch: boolean
      signin_award_switch: boolean
      bet_award_switch: boolean
      withdrawal_award_switch: boolean
      unprotection_deposit_exp: string | null
      unprotection_deposit_amount: string | null
      unprotection_bet_exp: string | null
      unprotection_bet_amount: string | null
      unprotection_days: number | null
      unprotection_switch: number | null
      main_currency: string | null
      can_receive_level_award: boolean
      can_receive_rank_award: boolean
      can_receive_day_award: boolean
      can_receive_week_award: boolean
      can_receive_month_award: boolean
      can_receive_signin_award: boolean
      can_receive_bet_award: boolean
      can_receive_withdrawal_award: boolean
      userid: string | null
      free_spin_times: number | null
      week_gift: number | null
      month_gift: number | null
      upgrade_gift: number | null
      now_cash_back: number | null
      yesterday_cash_back: number | null
      history_cash_back: number | null
      operatorId: string | null
    }, ExtArgs["result"]["vipInfo"]>
    composites: {}
  }

  type VipInfoGetPayload<S extends boolean | null | undefined | VipInfoDefaultArgs> = $Result.GetResult<Prisma.$VipInfoPayload, S>

  type VipInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VipInfoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VipInfoCountAggregateInputType | true
    }

  export interface VipInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VipInfo'], meta: { name: 'VipInfo' } }
    /**
     * Find zero or one VipInfo that matches the filter.
     * @param {VipInfoFindUniqueArgs} args - Arguments to find a VipInfo
     * @example
     * // Get one VipInfo
     * const vipInfo = await prisma.vipInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VipInfoFindUniqueArgs>(args: SelectSubset<T, VipInfoFindUniqueArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VipInfo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VipInfoFindUniqueOrThrowArgs} args - Arguments to find a VipInfo
     * @example
     * // Get one VipInfo
     * const vipInfo = await prisma.vipInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VipInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, VipInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VipInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoFindFirstArgs} args - Arguments to find a VipInfo
     * @example
     * // Get one VipInfo
     * const vipInfo = await prisma.vipInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VipInfoFindFirstArgs>(args?: SelectSubset<T, VipInfoFindFirstArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VipInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoFindFirstOrThrowArgs} args - Arguments to find a VipInfo
     * @example
     * // Get one VipInfo
     * const vipInfo = await prisma.vipInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VipInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, VipInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VipInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VipInfos
     * const vipInfos = await prisma.vipInfo.findMany()
     * 
     * // Get first 10 VipInfos
     * const vipInfos = await prisma.vipInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vipInfoWithIdOnly = await prisma.vipInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VipInfoFindManyArgs>(args?: SelectSubset<T, VipInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VipInfo.
     * @param {VipInfoCreateArgs} args - Arguments to create a VipInfo.
     * @example
     * // Create one VipInfo
     * const VipInfo = await prisma.vipInfo.create({
     *   data: {
     *     // ... data to create a VipInfo
     *   }
     * })
     * 
     */
    create<T extends VipInfoCreateArgs>(args: SelectSubset<T, VipInfoCreateArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VipInfos.
     * @param {VipInfoCreateManyArgs} args - Arguments to create many VipInfos.
     * @example
     * // Create many VipInfos
     * const vipInfo = await prisma.vipInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VipInfoCreateManyArgs>(args?: SelectSubset<T, VipInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VipInfos and returns the data saved in the database.
     * @param {VipInfoCreateManyAndReturnArgs} args - Arguments to create many VipInfos.
     * @example
     * // Create many VipInfos
     * const vipInfo = await prisma.vipInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VipInfos and only return the `id`
     * const vipInfoWithIdOnly = await prisma.vipInfo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VipInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, VipInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VipInfo.
     * @param {VipInfoDeleteArgs} args - Arguments to delete one VipInfo.
     * @example
     * // Delete one VipInfo
     * const VipInfo = await prisma.vipInfo.delete({
     *   where: {
     *     // ... filter to delete one VipInfo
     *   }
     * })
     * 
     */
    delete<T extends VipInfoDeleteArgs>(args: SelectSubset<T, VipInfoDeleteArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VipInfo.
     * @param {VipInfoUpdateArgs} args - Arguments to update one VipInfo.
     * @example
     * // Update one VipInfo
     * const vipInfo = await prisma.vipInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VipInfoUpdateArgs>(args: SelectSubset<T, VipInfoUpdateArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VipInfos.
     * @param {VipInfoDeleteManyArgs} args - Arguments to filter VipInfos to delete.
     * @example
     * // Delete a few VipInfos
     * const { count } = await prisma.vipInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VipInfoDeleteManyArgs>(args?: SelectSubset<T, VipInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VipInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VipInfos
     * const vipInfo = await prisma.vipInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VipInfoUpdateManyArgs>(args: SelectSubset<T, VipInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VipInfo.
     * @param {VipInfoUpsertArgs} args - Arguments to update or create a VipInfo.
     * @example
     * // Update or create a VipInfo
     * const vipInfo = await prisma.vipInfo.upsert({
     *   create: {
     *     // ... data to create a VipInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VipInfo we want to update
     *   }
     * })
     */
    upsert<T extends VipInfoUpsertArgs>(args: SelectSubset<T, VipInfoUpsertArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VipInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoCountArgs} args - Arguments to filter VipInfos to count.
     * @example
     * // Count the number of VipInfos
     * const count = await prisma.vipInfo.count({
     *   where: {
     *     // ... the filter for the VipInfos we want to count
     *   }
     * })
    **/
    count<T extends VipInfoCountArgs>(
      args?: Subset<T, VipInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VipInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VipInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VipInfoAggregateArgs>(args: Subset<T, VipInfoAggregateArgs>): Prisma.PrismaPromise<GetVipInfoAggregateType<T>>

    /**
     * Group by VipInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VipInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VipInfoGroupByArgs['orderBy'] }
        : { orderBy?: VipInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VipInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVipInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VipInfo model
   */
  readonly fields: VipInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VipInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VipInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamesession<T extends VipInfo$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, VipInfo$gamesessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamesessionPayload<ExtArgs>, T, "findMany"> | Null>
    operator<T extends VipInfo$operatorArgs<ExtArgs> = {}>(args?: Subset<T, VipInfo$operatorArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transactions<T extends VipInfo$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, VipInfo$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends VipInfo$userArgs<ExtArgs> = {}>(args?: Subset<T, VipInfo$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VipInfo model
   */ 
  interface VipInfoFieldRefs {
    readonly id: FieldRef<"VipInfo", 'String'>
    readonly level: FieldRef<"VipInfo", 'Int'>
    readonly deposit_exp: FieldRef<"VipInfo", 'Int'>
    readonly bet_exp: FieldRef<"VipInfo", 'Int'>
    readonly rank_bet_exp: FieldRef<"VipInfo", 'Int'>
    readonly rank_deposit_exp: FieldRef<"VipInfo", 'Int'>
    readonly rank_name: FieldRef<"VipInfo", 'String'>
    readonly icon: FieldRef<"VipInfo", 'String'>
    readonly exp_switch_type: FieldRef<"VipInfo", 'Int'>
    readonly now_deposit_exp: FieldRef<"VipInfo", 'String'>
    readonly level_deposit_exp: FieldRef<"VipInfo", 'String'>
    readonly now_bet_exp: FieldRef<"VipInfo", 'String'>
    readonly level_bet_exp: FieldRef<"VipInfo", 'String'>
    readonly telegram: FieldRef<"VipInfo", 'String'>
    readonly is_protection: FieldRef<"VipInfo", 'Boolean'>
    readonly protection_deposit_exp: FieldRef<"VipInfo", 'String'>
    readonly protection_deposit_amount: FieldRef<"VipInfo", 'String'>
    readonly protection_bet_exp: FieldRef<"VipInfo", 'String'>
    readonly protection_bet_amount: FieldRef<"VipInfo", 'String'>
    readonly protection_days: FieldRef<"VipInfo", 'Int'>
    readonly protection_switch: FieldRef<"VipInfo", 'Int'>
    readonly cycle_award_switch: FieldRef<"VipInfo", 'Boolean'>
    readonly level_award_switch: FieldRef<"VipInfo", 'Boolean'>
    readonly signin_award_switch: FieldRef<"VipInfo", 'Boolean'>
    readonly bet_award_switch: FieldRef<"VipInfo", 'Boolean'>
    readonly withdrawal_award_switch: FieldRef<"VipInfo", 'Boolean'>
    readonly unprotection_deposit_exp: FieldRef<"VipInfo", 'String'>
    readonly unprotection_deposit_amount: FieldRef<"VipInfo", 'String'>
    readonly unprotection_bet_exp: FieldRef<"VipInfo", 'String'>
    readonly unprotection_bet_amount: FieldRef<"VipInfo", 'String'>
    readonly unprotection_days: FieldRef<"VipInfo", 'Int'>
    readonly unprotection_switch: FieldRef<"VipInfo", 'Int'>
    readonly main_currency: FieldRef<"VipInfo", 'String'>
    readonly can_receive_level_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_rank_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_day_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_week_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_month_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_signin_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_bet_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_withdrawal_award: FieldRef<"VipInfo", 'Boolean'>
    readonly userid: FieldRef<"VipInfo", 'String'>
    readonly free_spin_times: FieldRef<"VipInfo", 'Int'>
    readonly week_gift: FieldRef<"VipInfo", 'Int'>
    readonly month_gift: FieldRef<"VipInfo", 'Int'>
    readonly upgrade_gift: FieldRef<"VipInfo", 'Int'>
    readonly now_cash_back: FieldRef<"VipInfo", 'Int'>
    readonly yesterday_cash_back: FieldRef<"VipInfo", 'Int'>
    readonly history_cash_back: FieldRef<"VipInfo", 'Int'>
    readonly operatorId: FieldRef<"VipInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VipInfo findUnique
   */
  export type VipInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter, which VipInfo to fetch.
     */
    where: VipInfoWhereUniqueInput
  }

  /**
   * VipInfo findUniqueOrThrow
   */
  export type VipInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter, which VipInfo to fetch.
     */
    where: VipInfoWhereUniqueInput
  }

  /**
   * VipInfo findFirst
   */
  export type VipInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter, which VipInfo to fetch.
     */
    where?: VipInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipInfos to fetch.
     */
    orderBy?: VipInfoOrderByWithRelationInput | VipInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VipInfos.
     */
    cursor?: VipInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VipInfos.
     */
    distinct?: VipInfoScalarFieldEnum | VipInfoScalarFieldEnum[]
  }

  /**
   * VipInfo findFirstOrThrow
   */
  export type VipInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter, which VipInfo to fetch.
     */
    where?: VipInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipInfos to fetch.
     */
    orderBy?: VipInfoOrderByWithRelationInput | VipInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VipInfos.
     */
    cursor?: VipInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VipInfos.
     */
    distinct?: VipInfoScalarFieldEnum | VipInfoScalarFieldEnum[]
  }

  /**
   * VipInfo findMany
   */
  export type VipInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter, which VipInfos to fetch.
     */
    where?: VipInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipInfos to fetch.
     */
    orderBy?: VipInfoOrderByWithRelationInput | VipInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VipInfos.
     */
    cursor?: VipInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipInfos.
     */
    skip?: number
    distinct?: VipInfoScalarFieldEnum | VipInfoScalarFieldEnum[]
  }

  /**
   * VipInfo create
   */
  export type VipInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a VipInfo.
     */
    data?: XOR<VipInfoCreateInput, VipInfoUncheckedCreateInput>
  }

  /**
   * VipInfo createMany
   */
  export type VipInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VipInfos.
     */
    data: VipInfoCreateManyInput | VipInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VipInfo createManyAndReturn
   */
  export type VipInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VipInfos.
     */
    data: VipInfoCreateManyInput | VipInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VipInfo update
   */
  export type VipInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a VipInfo.
     */
    data: XOR<VipInfoUpdateInput, VipInfoUncheckedUpdateInput>
    /**
     * Choose, which VipInfo to update.
     */
    where: VipInfoWhereUniqueInput
  }

  /**
   * VipInfo updateMany
   */
  export type VipInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VipInfos.
     */
    data: XOR<VipInfoUpdateManyMutationInput, VipInfoUncheckedUpdateManyInput>
    /**
     * Filter which VipInfos to update
     */
    where?: VipInfoWhereInput
  }

  /**
   * VipInfo upsert
   */
  export type VipInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the VipInfo to update in case it exists.
     */
    where: VipInfoWhereUniqueInput
    /**
     * In case the VipInfo found by the `where` argument doesn't exist, create a new VipInfo with this data.
     */
    create: XOR<VipInfoCreateInput, VipInfoUncheckedCreateInput>
    /**
     * In case the VipInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VipInfoUpdateInput, VipInfoUncheckedUpdateInput>
  }

  /**
   * VipInfo delete
   */
  export type VipInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter which VipInfo to delete.
     */
    where: VipInfoWhereUniqueInput
  }

  /**
   * VipInfo deleteMany
   */
  export type VipInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VipInfos to delete
     */
    where?: VipInfoWhereInput
  }

  /**
   * VipInfo.gamesession
   */
  export type VipInfo$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamesession
     */
    select?: GamesessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamesessionInclude<ExtArgs> | null
    where?: GamesessionWhereInput
    orderBy?: GamesessionOrderByWithRelationInput | GamesessionOrderByWithRelationInput[]
    cursor?: GamesessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * VipInfo.operator
   */
  export type VipInfo$operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    where?: OperatorWhereInput
  }

  /**
   * VipInfo.transactions
   */
  export type VipInfo$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * VipInfo.user
   */
  export type VipInfo$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * VipInfo without action
   */
  export type VipInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
  }


  /**
   * Model EventLog
   */

  export type AggregateEventLog = {
    _count: EventLogCountAggregateOutputType | null
    _avg: EventLogAvgAggregateOutputType | null
    _sum: EventLogSumAggregateOutputType | null
    _min: EventLogMinAggregateOutputType | null
    _max: EventLogMaxAggregateOutputType | null
  }

  export type EventLogAvgAggregateOutputType = {
    id: number | null
  }

  export type EventLogSumAggregateOutputType = {
    id: bigint | null
  }

  export type EventLogMinAggregateOutputType = {
    id: bigint | null
    tableName: string | null
    rowId: string | null
    operation: string | null
    createdAt: Date | null
  }

  export type EventLogMaxAggregateOutputType = {
    id: bigint | null
    tableName: string | null
    rowId: string | null
    operation: string | null
    createdAt: Date | null
  }

  export type EventLogCountAggregateOutputType = {
    id: number
    tableName: number
    rowId: number
    operation: number
    payload: number
    createdAt: number
    _all: number
  }


  export type EventLogAvgAggregateInputType = {
    id?: true
  }

  export type EventLogSumAggregateInputType = {
    id?: true
  }

  export type EventLogMinAggregateInputType = {
    id?: true
    tableName?: true
    rowId?: true
    operation?: true
    createdAt?: true
  }

  export type EventLogMaxAggregateInputType = {
    id?: true
    tableName?: true
    rowId?: true
    operation?: true
    createdAt?: true
  }

  export type EventLogCountAggregateInputType = {
    id?: true
    tableName?: true
    rowId?: true
    operation?: true
    payload?: true
    createdAt?: true
    _all?: true
  }

  export type EventLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventLog to aggregate.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventLogs
    **/
    _count?: true | EventLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventLogMaxAggregateInputType
  }

  export type GetEventLogAggregateType<T extends EventLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEventLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventLog[P]>
      : GetScalarType<T[P], AggregateEventLog[P]>
  }




  export type EventLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventLogWhereInput
    orderBy?: EventLogOrderByWithAggregationInput | EventLogOrderByWithAggregationInput[]
    by: EventLogScalarFieldEnum[] | EventLogScalarFieldEnum
    having?: EventLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventLogCountAggregateInputType | true
    _avg?: EventLogAvgAggregateInputType
    _sum?: EventLogSumAggregateInputType
    _min?: EventLogMinAggregateInputType
    _max?: EventLogMaxAggregateInputType
  }

  export type EventLogGroupByOutputType = {
    id: bigint
    tableName: string
    rowId: string | null
    operation: string
    payload: JsonValue | null
    createdAt: Date | null
    _count: EventLogCountAggregateOutputType | null
    _avg: EventLogAvgAggregateOutputType | null
    _sum: EventLogSumAggregateOutputType | null
    _min: EventLogMinAggregateOutputType | null
    _max: EventLogMaxAggregateOutputType | null
  }

  type GetEventLogGroupByPayload<T extends EventLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventLogGroupByOutputType[P]>
            : GetScalarType<T[P], EventLogGroupByOutputType[P]>
        }
      >
    >


  export type EventLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    rowId?: boolean
    operation?: boolean
    payload?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["eventLog"]>

  export type EventLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    rowId?: boolean
    operation?: boolean
    payload?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["eventLog"]>

  export type EventLogSelectScalar = {
    id?: boolean
    tableName?: boolean
    rowId?: boolean
    operation?: boolean
    payload?: boolean
    createdAt?: boolean
  }


  export type $EventLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tableName: string
      rowId: string | null
      operation: string
      payload: Prisma.JsonValue | null
      createdAt: Date | null
    }, ExtArgs["result"]["eventLog"]>
    composites: {}
  }

  type EventLogGetPayload<S extends boolean | null | undefined | EventLogDefaultArgs> = $Result.GetResult<Prisma.$EventLogPayload, S>

  type EventLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventLogCountAggregateInputType | true
    }

  export interface EventLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventLog'], meta: { name: 'EventLog' } }
    /**
     * Find zero or one EventLog that matches the filter.
     * @param {EventLogFindUniqueArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventLogFindUniqueArgs>(args: SelectSubset<T, EventLogFindUniqueArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventLogFindUniqueOrThrowArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EventLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogFindFirstArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventLogFindFirstArgs>(args?: SelectSubset<T, EventLogFindFirstArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogFindFirstOrThrowArgs} args - Arguments to find a EventLog
     * @example
     * // Get one EventLog
     * const eventLog = await prisma.eventLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EventLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventLogs
     * const eventLogs = await prisma.eventLog.findMany()
     * 
     * // Get first 10 EventLogs
     * const eventLogs = await prisma.eventLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventLogWithIdOnly = await prisma.eventLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventLogFindManyArgs>(args?: SelectSubset<T, EventLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventLog.
     * @param {EventLogCreateArgs} args - Arguments to create a EventLog.
     * @example
     * // Create one EventLog
     * const EventLog = await prisma.eventLog.create({
     *   data: {
     *     // ... data to create a EventLog
     *   }
     * })
     * 
     */
    create<T extends EventLogCreateArgs>(args: SelectSubset<T, EventLogCreateArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventLogs.
     * @param {EventLogCreateManyArgs} args - Arguments to create many EventLogs.
     * @example
     * // Create many EventLogs
     * const eventLog = await prisma.eventLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventLogCreateManyArgs>(args?: SelectSubset<T, EventLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventLogs and returns the data saved in the database.
     * @param {EventLogCreateManyAndReturnArgs} args - Arguments to create many EventLogs.
     * @example
     * // Create many EventLogs
     * const eventLog = await prisma.eventLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventLogs and only return the `id`
     * const eventLogWithIdOnly = await prisma.eventLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EventLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventLog.
     * @param {EventLogDeleteArgs} args - Arguments to delete one EventLog.
     * @example
     * // Delete one EventLog
     * const EventLog = await prisma.eventLog.delete({
     *   where: {
     *     // ... filter to delete one EventLog
     *   }
     * })
     * 
     */
    delete<T extends EventLogDeleteArgs>(args: SelectSubset<T, EventLogDeleteArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventLog.
     * @param {EventLogUpdateArgs} args - Arguments to update one EventLog.
     * @example
     * // Update one EventLog
     * const eventLog = await prisma.eventLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventLogUpdateArgs>(args: SelectSubset<T, EventLogUpdateArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventLogs.
     * @param {EventLogDeleteManyArgs} args - Arguments to filter EventLogs to delete.
     * @example
     * // Delete a few EventLogs
     * const { count } = await prisma.eventLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventLogDeleteManyArgs>(args?: SelectSubset<T, EventLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventLogs
     * const eventLog = await prisma.eventLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventLogUpdateManyArgs>(args: SelectSubset<T, EventLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventLog.
     * @param {EventLogUpsertArgs} args - Arguments to update or create a EventLog.
     * @example
     * // Update or create a EventLog
     * const eventLog = await prisma.eventLog.upsert({
     *   create: {
     *     // ... data to create a EventLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventLog we want to update
     *   }
     * })
     */
    upsert<T extends EventLogUpsertArgs>(args: SelectSubset<T, EventLogUpsertArgs<ExtArgs>>): Prisma__EventLogClient<$Result.GetResult<Prisma.$EventLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogCountArgs} args - Arguments to filter EventLogs to count.
     * @example
     * // Count the number of EventLogs
     * const count = await prisma.eventLog.count({
     *   where: {
     *     // ... the filter for the EventLogs we want to count
     *   }
     * })
    **/
    count<T extends EventLogCountArgs>(
      args?: Subset<T, EventLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventLogAggregateArgs>(args: Subset<T, EventLogAggregateArgs>): Prisma.PrismaPromise<GetEventLogAggregateType<T>>

    /**
     * Group by EventLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventLogGroupByArgs['orderBy'] }
        : { orderBy?: EventLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventLog model
   */
  readonly fields: EventLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventLog model
   */ 
  interface EventLogFieldRefs {
    readonly id: FieldRef<"EventLog", 'BigInt'>
    readonly tableName: FieldRef<"EventLog", 'String'>
    readonly rowId: FieldRef<"EventLog", 'String'>
    readonly operation: FieldRef<"EventLog", 'String'>
    readonly payload: FieldRef<"EventLog", 'Json'>
    readonly createdAt: FieldRef<"EventLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventLog findUnique
   */
  export type EventLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog findUniqueOrThrow
   */
  export type EventLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog findFirst
   */
  export type EventLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventLogs.
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventLogs.
     */
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * EventLog findFirstOrThrow
   */
  export type EventLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Filter, which EventLog to fetch.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventLogs.
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventLogs.
     */
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * EventLog findMany
   */
  export type EventLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Filter, which EventLogs to fetch.
     */
    where?: EventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLogs to fetch.
     */
    orderBy?: EventLogOrderByWithRelationInput | EventLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventLogs.
     */
    cursor?: EventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLogs.
     */
    skip?: number
    distinct?: EventLogScalarFieldEnum | EventLogScalarFieldEnum[]
  }

  /**
   * EventLog create
   */
  export type EventLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * The data needed to create a EventLog.
     */
    data: XOR<EventLogCreateInput, EventLogUncheckedCreateInput>
  }

  /**
   * EventLog createMany
   */
  export type EventLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventLogs.
     */
    data: EventLogCreateManyInput | EventLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventLog createManyAndReturn
   */
  export type EventLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventLogs.
     */
    data: EventLogCreateManyInput | EventLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventLog update
   */
  export type EventLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * The data needed to update a EventLog.
     */
    data: XOR<EventLogUpdateInput, EventLogUncheckedUpdateInput>
    /**
     * Choose, which EventLog to update.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog updateMany
   */
  export type EventLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventLogs.
     */
    data: XOR<EventLogUpdateManyMutationInput, EventLogUncheckedUpdateManyInput>
    /**
     * Filter which EventLogs to update
     */
    where?: EventLogWhereInput
  }

  /**
   * EventLog upsert
   */
  export type EventLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * The filter to search for the EventLog to update in case it exists.
     */
    where: EventLogWhereUniqueInput
    /**
     * In case the EventLog found by the `where` argument doesn't exist, create a new EventLog with this data.
     */
    create: XOR<EventLogCreateInput, EventLogUncheckedCreateInput>
    /**
     * In case the EventLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventLogUpdateInput, EventLogUncheckedUpdateInput>
  }

  /**
   * EventLog delete
   */
  export type EventLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
    /**
     * Filter which EventLog to delete.
     */
    where: EventLogWhereUniqueInput
  }

  /**
   * EventLog deleteMany
   */
  export type EventLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventLogs to delete
     */
    where?: EventLogWhereInput
  }

  /**
   * EventLog without action
   */
  export type EventLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLog
     */
    select?: EventLogSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    targetXp: 'targetXp',
    reward: 'reward',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    sbId: 'sbId',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    isOnline: 'isOnline',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    twoFactorEnabled: 'twoFactorEnabled',
    role: 'role',
    banned: 'banned',
    banReason: 'banReason',
    banExpires: 'banExpires',
    username: 'username',
    displayUsername: 'displayUsername',
    passwordHash: 'passwordHash',
    totalXp: 'totalXp',
    balance: 'balance',
    isVerified: 'isVerified',
    active: 'active',
    lastLogin: 'lastLogin',
    verificationToken: 'verificationToken',
    avatar: 'avatar',
    activeProfileId: 'activeProfileId',
    gender: 'gender',
    status: 'status',
    cashtag: 'cashtag',
    phpId: 'phpId',
    accessToken: 'accessToken',
    vipInfoId: 'vipInfoId',
    lastDailySpin: 'lastDailySpin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const PlatformSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    activeGameId: 'activeGameId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    refreshToken: 'refreshToken',
    active: 'active',
    token: 'token',
    updatedAt: 'updatedAt'
  };

  export type PlatformSessionScalarFieldEnum = (typeof PlatformSessionScalarFieldEnum)[keyof typeof PlatformSessionScalarFieldEnum]


  export const OperatorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    acceptedPayments: 'acceptedPayments',
    ownerId: 'ownerId',
    balance: 'balance'
  };

  export type OperatorScalarFieldEnum = (typeof OperatorScalarFieldEnum)[keyof typeof OperatorScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    xpEarned: 'xpEarned',
    isActive: 'isActive',
    lastPlayed: 'lastPlayed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phpId: 'phpId',
    userId: 'userId',
    currency: 'currency',
    shopId: 'shopId'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    title: 'title',
    temperature: 'temperature',
    developer: 'developer',
    vipLevel: 'vipLevel',
    isActive: 'isActive',
    device: 'device',
    featured: 'featured',
    gamebank: 'gamebank',
    bet: 'bet',
    denomination: 'denomination',
    categoryTemp: 'categoryTemp',
    originalId: 'originalId',
    bids: 'bids',
    statIn: 'statIn',
    statOut: 'statOut',
    currentRtp: 'currentRtp',
    rtpStatIn: 'rtpStatIn',
    rtpStatOut: 'rtpStatOut',
    standardRtp: 'standardRtp',
    popularity: 'popularity',
    chanceFirepot1: 'chanceFirepot1',
    chanceFirepot2: 'chanceFirepot2',
    chanceFirepot3: 'chanceFirepot3',
    fireCount1: 'fireCount1',
    fireCount2: 'fireCount2',
    fireCount3: 'fireCount3',
    linesPercentConfigSpin: 'linesPercentConfigSpin',
    linesPercentConfigSpinBonus: 'linesPercentConfigSpinBonus',
    linesPercentConfigBonus: 'linesPercentConfigBonus',
    linesPercentConfigBonusBonus: 'linesPercentConfigBonusBonus',
    rezerv: 'rezerv',
    cask: 'cask',
    advanced: 'advanced',
    scaleMode: 'scaleMode',
    slotViewState: 'slotViewState',
    view: 'view',
    categoryId: 'categoryId',
    operatorId: 'operatorId',
    providerId: 'providerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    jackpotGroupId: 'jackpotGroupId',
    active: 'active',
    password: 'password',
    category: 'category'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const OperatorgameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    thumbnail: 'thumbnail',
    minBet: 'minBet',
    maxBet: 'maxBet',
    xpMultiplier: 'xpMultiplier',
    isActive: 'isActive',
    isPromoted: 'isPromoted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    operatorId: 'operatorId'
  };

  export type OperatorgameScalarFieldEnum = (typeof OperatorgameScalarFieldEnum)[keyof typeof OperatorgameScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    createdAt: 'createdAt',
    metadata: 'metadata'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    email: 'email',
    role: 'role',
    status: 'status',
    expiresAt: 'expiresAt',
    inviterId: 'inviterId'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const TwoFactorScalarFieldEnum: {
    id: 'id',
    secret: 'secret',
    backupCodes: 'backupCodes',
    userId: 'userId'
  };

  export type TwoFactorScalarFieldEnum = (typeof TwoFactorScalarFieldEnum)[keyof typeof TwoFactorScalarFieldEnum]


  export const ChatmessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    channel: 'channel',
    metadata: 'metadata',
    createdAt: 'createdAt',
    userId: 'userId',
    roomId: 'roomId'
  };

  export type ChatmessageScalarFieldEnum = (typeof ChatmessageScalarFieldEnum)[keyof typeof ChatmessageScalarFieldEnum]


  export const ChatroomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isGameRoom: 'isGameRoom',
    createdAt: 'createdAt',
    gameSessionId: 'gameSessionId'
  };

  export type ChatroomScalarFieldEnum = (typeof ChatroomScalarFieldEnum)[keyof typeof ChatroomScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    friendId: 'friendId'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const GamesessionScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    betAmount: 'betAmount',
    winAmount: 'winAmount',
    xpEarned: 'xpEarned',
    metadata: 'metadata',
    gameId: 'gameId',
    tournamentId: 'tournamentId',
    active: 'active',
    profileId: 'profileId',
    vipInfoId: 'vipInfoId'
  };

  export type GamesessionScalarFieldEnum = (typeof GamesessionScalarFieldEnum)[keyof typeof GamesessionScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    url: 'url',
    type: 'type',
    bonusCode: 'bonusCode',
    bonusTotalInCredits: 'bonusTotalInCredits',
    priceInCents: 'priceInCents',
    amountToReceiveInCredits: 'amountToReceiveInCredits',
    bestValue: 'bestValue',
    discountInCents: 'discountInCents',
    bonusSpins: 'bonusSpins',
    isPromo: 'isPromo',
    totalDiscountInCents: 'totalDiscountInCents',
    shopId: 'shopId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    readAt: 'readAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const TournamentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    entryFee: 'entryFee',
    prizePool: 'prizePool',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    operatorId: 'operatorId',
    leaderboard: 'leaderboard'
  };

  export type TournamentScalarFieldEnum = (typeof TournamentScalarFieldEnum)[keyof typeof TournamentScalarFieldEnum]


  export const TournamententryScalarFieldEnum: {
    id: 'id',
    score: 'score',
    wagered: 'wagered',
    won: 'won',
    joinedAt: 'joinedAt',
    userId: 'userId',
    tournamentId: 'tournamentId',
    profileId: 'profileId'
  };

  export type TournamententryScalarFieldEnum = (typeof TournamententryScalarFieldEnum)[keyof typeof TournamententryScalarFieldEnum]


  export const TournamentgameScalarFieldEnum: {
    id: 'id',
    multiplier: 'multiplier',
    tournamentId: 'tournamentId',
    gameId: 'gameId'
  };

  export type TournamentgameScalarFieldEnum = (typeof TournamentgameScalarFieldEnum)[keyof typeof TournamentgameScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    amountCredits: 'amountCredits',
    buyerCashtag: 'buyerCashtag',
    buyerUserId: 'buyerUserId',
    username: 'username',
    cashiername: 'cashiername',
    cashierAvatar: 'cashierAvatar',
    cashierId: 'cashierId',
    reference: 'reference',
    status: 'status',
    metadata: 'metadata',
    isRealMoney: 'isRealMoney',
    paymentMethod: 'paymentMethod',
    paymentDetails: 'paymentDetails',
    createdAt: 'createdAt',
    processedAt: 'processedAt',
    gameSessionId: 'gameSessionId',
    profileId: 'profileId',
    cashtag: 'cashtag',
    productid: 'productid',
    vipInfoId: 'vipInfoId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const UserachievementScalarFieldEnum: {
    id: 'id',
    progress: 'progress',
    isUnlocked: 'isUnlocked',
    unlockedAt: 'unlockedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    achievementId: 'achievementId'
  };

  export type UserachievementScalarFieldEnum = (typeof UserachievementScalarFieldEnum)[keyof typeof UserachievementScalarFieldEnum]


  export const RainBetScalarFieldEnum: {
    id: 'id',
    rainHistoryId: 'rainHistoryId',
    userId: 'userId',
    betAmount: 'betAmount',
    odds: 'odds',
    outcome: 'outcome',
    settledAt: 'settledAt'
  };

  export type RainBetScalarFieldEnum = (typeof RainBetScalarFieldEnum)[keyof typeof RainBetScalarFieldEnum]


  export const RainHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    rainType: 'rainType',
    createdAt: 'createdAt'
  };

  export type RainHistoryScalarFieldEnum = (typeof RainHistoryScalarFieldEnum)[keyof typeof RainHistoryScalarFieldEnum]


  export const RainTipScalarFieldEnum: {
    id: 'id',
    rainHistoryId: 'rainHistoryId',
    userId: 'userId',
    tipAmount: 'tipAmount',
    tippedAt: 'tippedAt'
  };

  export type RainTipScalarFieldEnum = (typeof RainTipScalarFieldEnum)[keyof typeof RainTipScalarFieldEnum]


  export const RainWinnerScalarFieldEnum: {
    id: 'id',
    rainHistoryId: 'rainHistoryId',
    userId: 'userId',
    wonAmount: 'wonAmount',
    wonAt: 'wonAt'
  };

  export type RainWinnerScalarFieldEnum = (typeof RainWinnerScalarFieldEnum)[keyof typeof RainWinnerScalarFieldEnum]


  export const VipInfoScalarFieldEnum: {
    id: 'id',
    level: 'level',
    deposit_exp: 'deposit_exp',
    bet_exp: 'bet_exp',
    rank_bet_exp: 'rank_bet_exp',
    rank_deposit_exp: 'rank_deposit_exp',
    rank_name: 'rank_name',
    icon: 'icon',
    exp_switch_type: 'exp_switch_type',
    now_deposit_exp: 'now_deposit_exp',
    level_deposit_exp: 'level_deposit_exp',
    now_bet_exp: 'now_bet_exp',
    level_bet_exp: 'level_bet_exp',
    telegram: 'telegram',
    is_protection: 'is_protection',
    protection_deposit_exp: 'protection_deposit_exp',
    protection_deposit_amount: 'protection_deposit_amount',
    protection_bet_exp: 'protection_bet_exp',
    protection_bet_amount: 'protection_bet_amount',
    protection_days: 'protection_days',
    protection_switch: 'protection_switch',
    cycle_award_switch: 'cycle_award_switch',
    level_award_switch: 'level_award_switch',
    signin_award_switch: 'signin_award_switch',
    bet_award_switch: 'bet_award_switch',
    withdrawal_award_switch: 'withdrawal_award_switch',
    unprotection_deposit_exp: 'unprotection_deposit_exp',
    unprotection_deposit_amount: 'unprotection_deposit_amount',
    unprotection_bet_exp: 'unprotection_bet_exp',
    unprotection_bet_amount: 'unprotection_bet_amount',
    unprotection_days: 'unprotection_days',
    unprotection_switch: 'unprotection_switch',
    main_currency: 'main_currency',
    can_receive_level_award: 'can_receive_level_award',
    can_receive_rank_award: 'can_receive_rank_award',
    can_receive_day_award: 'can_receive_day_award',
    can_receive_week_award: 'can_receive_week_award',
    can_receive_month_award: 'can_receive_month_award',
    can_receive_signin_award: 'can_receive_signin_award',
    can_receive_bet_award: 'can_receive_bet_award',
    can_receive_withdrawal_award: 'can_receive_withdrawal_award',
    userid: 'userid',
    free_spin_times: 'free_spin_times',
    week_gift: 'week_gift',
    month_gift: 'month_gift',
    upgrade_gift: 'upgrade_gift',
    now_cash_back: 'now_cash_back',
    yesterday_cash_back: 'yesterday_cash_back',
    history_cash_back: 'history_cash_back',
    operatorId: 'operatorId'
  };

  export type VipInfoScalarFieldEnum = (typeof VipInfoScalarFieldEnum)[keyof typeof VipInfoScalarFieldEnum]


  export const EventLogScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    rowId: 'rowId',
    operation: 'operation',
    payload: 'payload',
    createdAt: 'createdAt'
  };

  export type EventLogScalarFieldEnum = (typeof EventLogScalarFieldEnum)[keyof typeof EventLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'GameCategory'
   */
  export type EnumGameCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameCategory'>
    


  /**
   * Reference to a field of type 'GameCategory[]'
   */
  export type ListEnumGameCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameCategory[]'>
    


  /**
   * Reference to a field of type 'ChatChannel'
   */
  export type EnumChatChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatChannel'>
    


  /**
   * Reference to a field of type 'ChatChannel[]'
   */
  export type ListEnumChatChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatChannel[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'FriendshipStatus'
   */
  export type EnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus'>
    


  /**
   * Reference to a field of type 'FriendshipStatus[]'
   */
  export type ListEnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    
  /**
   * Deep Input Types
   */


  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    targetXp?: IntFilter<"Achievement"> | number
    reward?: IntNullableFilter<"Achievement"> | number | null
    isActive?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Achievement"> | Date | string | null
    userachievement?: UserachievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userachievement?: UserachievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    targetXp?: IntFilter<"Achievement"> | number
    reward?: IntNullableFilter<"Achievement"> | number | null
    isActive?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Achievement"> | Date | string | null
    userachievement?: UserachievementListRelationFilter
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    targetXp?: IntWithAggregatesFilter<"Achievement"> | number
    reward?: IntNullableWithAggregatesFilter<"Achievement"> | number | null
    isActive?: BoolWithAggregatesFilter<"Achievement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Achievement"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    sbId?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    isOnline?: BoolNullableFilter<"User"> | boolean | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolNullableFilter<"User"> | boolean | null
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    username?: StringFilter<"User"> | string
    displayUsername?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    totalXp?: IntFilter<"User"> | number
    balance?: IntFilter<"User"> | number
    isVerified?: BoolFilter<"User"> | boolean
    active?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    verificationToken?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    activeProfileId?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    status?: EnumUserStatusNullableFilter<"User"> | $Enums.UserStatus | null
    cashtag?: StringNullableFilter<"User"> | string | null
    phpId?: IntNullableFilter<"User"> | number | null
    accessToken?: StringNullableFilter<"User"> | string | null
    vipInfoId?: StringNullableFilter<"User"> | string | null
    lastDailySpin?: DateTimeNullableFilter<"User"> | Date | string | null
    operator?: OperatorListRelationFilter
    activeProfile?: ProfileListRelationFilter
    RainBet?: RainBetListRelationFilter
    RainHistory?: RainHistoryListRelationFilter
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
    sessions?: PlatformSessionListRelationFilter
    accounts?: AccountListRelationFilter
    chatmessage?: ChatmessageListRelationFilter
    friendshipFriendshipFriendidtouser?: FriendshipListRelationFilter
    friendshipFriendshipUseridtouser?: FriendshipListRelationFilter
    invitations?: InvitationListRelationFilter
    members?: MemberListRelationFilter
    notification?: NotificationListRelationFilter
    tournamententry?: TournamententryListRelationFilter
    twofactors?: TwoFactorListRelationFilter
    userachievement?: UserachievementListRelationFilter
    vipInfo?: XOR<VipInfoNullableRelationFilter, VipInfoWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    sbId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    isOnline?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    username?: SortOrder
    displayUsername?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    isVerified?: SortOrder
    active?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    activeProfileId?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    cashtag?: SortOrderInput | SortOrder
    phpId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    vipInfoId?: SortOrderInput | SortOrder
    lastDailySpin?: SortOrderInput | SortOrder
    operator?: OperatorOrderByRelationAggregateInput
    activeProfile?: ProfileOrderByRelationAggregateInput
    RainBet?: RainBetOrderByRelationAggregateInput
    RainHistory?: RainHistoryOrderByRelationAggregateInput
    RainTip?: RainTipOrderByRelationAggregateInput
    RainWinner?: RainWinnerOrderByRelationAggregateInput
    sessions?: PlatformSessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    chatmessage?: ChatmessageOrderByRelationAggregateInput
    friendshipFriendshipFriendidtouser?: FriendshipOrderByRelationAggregateInput
    friendshipFriendshipUseridtouser?: FriendshipOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
    members?: MemberOrderByRelationAggregateInput
    notification?: NotificationOrderByRelationAggregateInput
    tournamententry?: TournamententryOrderByRelationAggregateInput
    twofactors?: TwoFactorOrderByRelationAggregateInput
    userachievement?: UserachievementOrderByRelationAggregateInput
    vipInfo?: VipInfoOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    activeProfileId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    sbId?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    isOnline?: BoolNullableFilter<"User"> | boolean | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolNullableFilter<"User"> | boolean | null
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    displayUsername?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    totalXp?: IntFilter<"User"> | number
    balance?: IntFilter<"User"> | number
    isVerified?: BoolFilter<"User"> | boolean
    active?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    verificationToken?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    status?: EnumUserStatusNullableFilter<"User"> | $Enums.UserStatus | null
    cashtag?: StringNullableFilter<"User"> | string | null
    phpId?: IntNullableFilter<"User"> | number | null
    accessToken?: StringNullableFilter<"User"> | string | null
    vipInfoId?: StringNullableFilter<"User"> | string | null
    lastDailySpin?: DateTimeNullableFilter<"User"> | Date | string | null
    operator?: OperatorListRelationFilter
    activeProfile?: ProfileListRelationFilter
    RainBet?: RainBetListRelationFilter
    RainHistory?: RainHistoryListRelationFilter
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
    sessions?: PlatformSessionListRelationFilter
    accounts?: AccountListRelationFilter
    chatmessage?: ChatmessageListRelationFilter
    friendshipFriendshipFriendidtouser?: FriendshipListRelationFilter
    friendshipFriendshipUseridtouser?: FriendshipListRelationFilter
    invitations?: InvitationListRelationFilter
    members?: MemberListRelationFilter
    notification?: NotificationListRelationFilter
    tournamententry?: TournamententryListRelationFilter
    twofactors?: TwoFactorListRelationFilter
    userachievement?: UserachievementListRelationFilter
    vipInfo?: XOR<VipInfoNullableRelationFilter, VipInfoWhereInput> | null
  }, "id" | "email" | "username" | "activeProfileId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    sbId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    isOnline?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    username?: SortOrder
    displayUsername?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    isVerified?: SortOrder
    active?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    activeProfileId?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    cashtag?: SortOrderInput | SortOrder
    phpId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    vipInfoId?: SortOrderInput | SortOrder
    lastDailySpin?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    sbId?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    isOnline?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    role?: StringNullableWithAggregatesFilter<"User"> | string | null
    banned?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    banReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    banExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    displayUsername?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    totalXp?: IntWithAggregatesFilter<"User"> | number
    balance?: IntWithAggregatesFilter<"User"> | number
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    active?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    activeProfileId?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
    status?: EnumUserStatusNullableWithAggregatesFilter<"User"> | $Enums.UserStatus | null
    cashtag?: StringNullableWithAggregatesFilter<"User"> | string | null
    phpId?: IntNullableWithAggregatesFilter<"User"> | number | null
    accessToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    vipInfoId?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastDailySpin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
  }

  export type PlatformSessionWhereInput = {
    AND?: PlatformSessionWhereInput | PlatformSessionWhereInput[]
    OR?: PlatformSessionWhereInput[]
    NOT?: PlatformSessionWhereInput | PlatformSessionWhereInput[]
    id?: StringFilter<"PlatformSession"> | string
    userId?: StringFilter<"PlatformSession"> | string
    activeGameId?: StringNullableFilter<"PlatformSession"> | string | null
    ipAddress?: StringNullableFilter<"PlatformSession"> | string | null
    userAgent?: StringNullableFilter<"PlatformSession"> | string | null
    expiresAt?: DateTimeFilter<"PlatformSession"> | Date | string
    createdAt?: DateTimeFilter<"PlatformSession"> | Date | string
    refreshToken?: StringNullableFilter<"PlatformSession"> | string | null
    active?: BoolFilter<"PlatformSession"> | boolean
    token?: StringFilter<"PlatformSession"> | string
    updatedAt?: DateTimeNullableFilter<"PlatformSession"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PlatformSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    active?: SortOrder
    token?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PlatformSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    token?: string
    AND?: PlatformSessionWhereInput | PlatformSessionWhereInput[]
    OR?: PlatformSessionWhereInput[]
    NOT?: PlatformSessionWhereInput | PlatformSessionWhereInput[]
    userId?: StringFilter<"PlatformSession"> | string
    activeGameId?: StringNullableFilter<"PlatformSession"> | string | null
    ipAddress?: StringNullableFilter<"PlatformSession"> | string | null
    userAgent?: StringNullableFilter<"PlatformSession"> | string | null
    expiresAt?: DateTimeFilter<"PlatformSession"> | Date | string
    createdAt?: DateTimeFilter<"PlatformSession"> | Date | string
    active?: BoolFilter<"PlatformSession"> | boolean
    updatedAt?: DateTimeNullableFilter<"PlatformSession"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "refreshToken" | "token">

  export type PlatformSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    active?: SortOrder
    token?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PlatformSessionCountOrderByAggregateInput
    _max?: PlatformSessionMaxOrderByAggregateInput
    _min?: PlatformSessionMinOrderByAggregateInput
  }

  export type PlatformSessionScalarWhereWithAggregatesInput = {
    AND?: PlatformSessionScalarWhereWithAggregatesInput | PlatformSessionScalarWhereWithAggregatesInput[]
    OR?: PlatformSessionScalarWhereWithAggregatesInput[]
    NOT?: PlatformSessionScalarWhereWithAggregatesInput | PlatformSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlatformSession"> | string
    userId?: StringWithAggregatesFilter<"PlatformSession"> | string
    activeGameId?: StringNullableWithAggregatesFilter<"PlatformSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"PlatformSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PlatformSession"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"PlatformSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PlatformSession"> | Date | string
    refreshToken?: StringNullableWithAggregatesFilter<"PlatformSession"> | string | null
    active?: BoolWithAggregatesFilter<"PlatformSession"> | boolean
    token?: StringWithAggregatesFilter<"PlatformSession"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PlatformSession"> | Date | string | null
  }

  export type OperatorWhereInput = {
    AND?: OperatorWhereInput | OperatorWhereInput[]
    OR?: OperatorWhereInput[]
    NOT?: OperatorWhereInput | OperatorWhereInput[]
    id?: StringFilter<"Operator"> | string
    name?: StringFilter<"Operator"> | string
    slug?: StringFilter<"Operator"> | string
    logo?: StringNullableFilter<"Operator"> | string | null
    description?: StringNullableFilter<"Operator"> | string | null
    isActive?: BoolFilter<"Operator"> | boolean
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Operator"> | Date | string | null
    acceptedPayments?: StringNullableListFilter<"Operator">
    ownerId?: StringFilter<"Operator"> | string
    balance?: IntFilter<"Operator"> | number
    owner?: XOR<UserRelationFilter, UserWhereInput>
    profiles?: ProfileListRelationFilter
    games?: GameListRelationFilter
    products?: ProductListRelationFilter
    tournaments?: TournamentListRelationFilter
    VipInfo?: VipInfoListRelationFilter
  }

  export type OperatorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    acceptedPayments?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
    owner?: UserOrderByWithRelationInput
    profiles?: ProfileOrderByRelationAggregateInput
    games?: GameOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    tournaments?: TournamentOrderByRelationAggregateInput
    VipInfo?: VipInfoOrderByRelationAggregateInput
  }

  export type OperatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OperatorWhereInput | OperatorWhereInput[]
    OR?: OperatorWhereInput[]
    NOT?: OperatorWhereInput | OperatorWhereInput[]
    name?: StringFilter<"Operator"> | string
    logo?: StringNullableFilter<"Operator"> | string | null
    description?: StringNullableFilter<"Operator"> | string | null
    isActive?: BoolFilter<"Operator"> | boolean
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Operator"> | Date | string | null
    acceptedPayments?: StringNullableListFilter<"Operator">
    ownerId?: StringFilter<"Operator"> | string
    balance?: IntFilter<"Operator"> | number
    owner?: XOR<UserRelationFilter, UserWhereInput>
    profiles?: ProfileListRelationFilter
    games?: GameListRelationFilter
    products?: ProductListRelationFilter
    tournaments?: TournamentListRelationFilter
    VipInfo?: VipInfoListRelationFilter
  }, "id" | "slug">

  export type OperatorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    acceptedPayments?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
    _count?: OperatorCountOrderByAggregateInput
    _avg?: OperatorAvgOrderByAggregateInput
    _max?: OperatorMaxOrderByAggregateInput
    _min?: OperatorMinOrderByAggregateInput
    _sum?: OperatorSumOrderByAggregateInput
  }

  export type OperatorScalarWhereWithAggregatesInput = {
    AND?: OperatorScalarWhereWithAggregatesInput | OperatorScalarWhereWithAggregatesInput[]
    OR?: OperatorScalarWhereWithAggregatesInput[]
    NOT?: OperatorScalarWhereWithAggregatesInput | OperatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Operator"> | string
    name?: StringWithAggregatesFilter<"Operator"> | string
    slug?: StringWithAggregatesFilter<"Operator"> | string
    logo?: StringNullableWithAggregatesFilter<"Operator"> | string | null
    description?: StringNullableWithAggregatesFilter<"Operator"> | string | null
    isActive?: BoolWithAggregatesFilter<"Operator"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Operator"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Operator"> | Date | string | null
    acceptedPayments?: StringNullableListFilter<"Operator">
    ownerId?: StringWithAggregatesFilter<"Operator"> | string
    balance?: IntWithAggregatesFilter<"Operator"> | number
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    authorId?: StringNullableFilter<"Message"> | string | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    authorId?: StringNullableFilter<"Message"> | string | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    authorId?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    balance?: IntFilter<"Profile"> | number
    xpEarned?: IntFilter<"Profile"> | number
    isActive?: BoolFilter<"Profile"> | boolean
    lastPlayed?: DateTimeNullableFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    phpId?: IntNullableFilter<"Profile"> | number | null
    userId?: StringFilter<"Profile"> | string
    currency?: StringFilter<"Profile"> | string
    shopId?: StringFilter<"Profile"> | string
    operator?: XOR<OperatorRelationFilter, OperatorWhereInput>
    userProfileUseridtouser?: XOR<UserRelationFilter, UserWhereInput>
    gamesession?: GamesessionListRelationFilter
    tournamententry?: TournamententryListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    phpId?: SortOrderInput | SortOrder
    userId?: SortOrder
    currency?: SortOrder
    shopId?: SortOrder
    operator?: OperatorOrderByWithRelationInput
    userProfileUseridtouser?: UserOrderByWithRelationInput
    gamesession?: GamesessionOrderByRelationAggregateInput
    tournamententry?: TournamententryOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phpId?: number
    userId_shopId?: ProfileUserIdShopIdCompoundUniqueInput
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    balance?: IntFilter<"Profile"> | number
    xpEarned?: IntFilter<"Profile"> | number
    isActive?: BoolFilter<"Profile"> | boolean
    lastPlayed?: DateTimeNullableFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    userId?: StringFilter<"Profile"> | string
    currency?: StringFilter<"Profile"> | string
    shopId?: StringFilter<"Profile"> | string
    operator?: XOR<OperatorRelationFilter, OperatorWhereInput>
    userProfileUseridtouser?: XOR<UserRelationFilter, UserWhereInput>
    gamesession?: GamesessionListRelationFilter
    tournamententry?: TournamententryListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id" | "phpId" | "userId_shopId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    phpId?: SortOrderInput | SortOrder
    userId?: SortOrder
    currency?: SortOrder
    shopId?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    balance?: IntWithAggregatesFilter<"Profile"> | number
    xpEarned?: IntWithAggregatesFilter<"Profile"> | number
    isActive?: BoolWithAggregatesFilter<"Profile"> | boolean
    lastPlayed?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    phpId?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    userId?: StringWithAggregatesFilter<"Profile"> | string
    currency?: StringWithAggregatesFilter<"Profile"> | string
    shopId?: StringWithAggregatesFilter<"Profile"> | string
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    name?: StringFilter<"Game"> | string
    title?: StringFilter<"Game"> | string
    temperature?: StringNullableFilter<"Game"> | string | null
    developer?: StringNullableFilter<"Game"> | string | null
    vipLevel?: IntNullableFilter<"Game"> | number | null
    isActive?: BoolNullableFilter<"Game"> | boolean | null
    device?: IntNullableFilter<"Game"> | number | null
    featured?: BoolNullableFilter<"Game"> | boolean | null
    gamebank?: StringNullableFilter<"Game"> | string | null
    bet?: FloatNullableFilter<"Game"> | number | null
    denomination?: FloatNullableFilter<"Game"> | number | null
    categoryTemp?: FloatNullableFilter<"Game"> | number | null
    originalId?: IntNullableFilter<"Game"> | number | null
    bids?: IntNullableFilter<"Game"> | number | null
    statIn?: FloatNullableFilter<"Game"> | number | null
    statOut?: FloatNullableFilter<"Game"> | number | null
    currentRtp?: FloatNullableFilter<"Game"> | number | null
    rtpStatIn?: FloatNullableFilter<"Game"> | number | null
    rtpStatOut?: FloatNullableFilter<"Game"> | number | null
    standardRtp?: FloatNullableFilter<"Game"> | number | null
    popularity?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot1?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot2?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot3?: FloatNullableFilter<"Game"> | number | null
    fireCount1?: FloatNullableFilter<"Game"> | number | null
    fireCount2?: FloatNullableFilter<"Game"> | number | null
    fireCount3?: FloatNullableFilter<"Game"> | number | null
    linesPercentConfigSpin?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigSpinBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonusBonus?: StringNullableFilter<"Game"> | string | null
    rezerv?: FloatNullableFilter<"Game"> | number | null
    cask?: FloatNullableFilter<"Game"> | number | null
    advanced?: StringNullableFilter<"Game"> | string | null
    scaleMode?: StringFilter<"Game"> | string
    slotViewState?: StringFilter<"Game"> | string
    view?: IntNullableFilter<"Game"> | number | null
    categoryId?: StringNullableFilter<"Game"> | string | null
    operatorId?: StringNullableFilter<"Game"> | string | null
    providerId?: StringNullableFilter<"Game"> | string | null
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    jackpotGroupId?: StringNullableFilter<"Game"> | string | null
    active?: BoolFilter<"Game"> | boolean
    password?: StringNullableFilter<"Game"> | string | null
    category?: EnumGameCategoryFilter<"Game"> | $Enums.GameCategory
    operator?: XOR<OperatorNullableRelationFilter, OperatorWhereInput> | null
    gamesession?: GamesessionListRelationFilter
    tournamentgame?: TournamentgameListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    temperature?: SortOrderInput | SortOrder
    developer?: SortOrderInput | SortOrder
    vipLevel?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    featured?: SortOrderInput | SortOrder
    gamebank?: SortOrderInput | SortOrder
    bet?: SortOrderInput | SortOrder
    denomination?: SortOrderInput | SortOrder
    categoryTemp?: SortOrderInput | SortOrder
    originalId?: SortOrderInput | SortOrder
    bids?: SortOrderInput | SortOrder
    statIn?: SortOrderInput | SortOrder
    statOut?: SortOrderInput | SortOrder
    currentRtp?: SortOrderInput | SortOrder
    rtpStatIn?: SortOrderInput | SortOrder
    rtpStatOut?: SortOrderInput | SortOrder
    standardRtp?: SortOrderInput | SortOrder
    popularity?: SortOrderInput | SortOrder
    chanceFirepot1?: SortOrderInput | SortOrder
    chanceFirepot2?: SortOrderInput | SortOrder
    chanceFirepot3?: SortOrderInput | SortOrder
    fireCount1?: SortOrderInput | SortOrder
    fireCount2?: SortOrderInput | SortOrder
    fireCount3?: SortOrderInput | SortOrder
    linesPercentConfigSpin?: SortOrderInput | SortOrder
    linesPercentConfigSpinBonus?: SortOrderInput | SortOrder
    linesPercentConfigBonus?: SortOrderInput | SortOrder
    linesPercentConfigBonusBonus?: SortOrderInput | SortOrder
    rezerv?: SortOrderInput | SortOrder
    cask?: SortOrderInput | SortOrder
    advanced?: SortOrderInput | SortOrder
    scaleMode?: SortOrder
    slotViewState?: SortOrder
    view?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    operatorId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    jackpotGroupId?: SortOrderInput | SortOrder
    active?: SortOrder
    password?: SortOrderInput | SortOrder
    category?: SortOrder
    operator?: OperatorOrderByWithRelationInput
    gamesession?: GamesessionOrderByRelationAggregateInput
    tournamentgame?: TournamentgameOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    name?: StringFilter<"Game"> | string
    title?: StringFilter<"Game"> | string
    temperature?: StringNullableFilter<"Game"> | string | null
    developer?: StringNullableFilter<"Game"> | string | null
    vipLevel?: IntNullableFilter<"Game"> | number | null
    isActive?: BoolNullableFilter<"Game"> | boolean | null
    device?: IntNullableFilter<"Game"> | number | null
    featured?: BoolNullableFilter<"Game"> | boolean | null
    gamebank?: StringNullableFilter<"Game"> | string | null
    bet?: FloatNullableFilter<"Game"> | number | null
    denomination?: FloatNullableFilter<"Game"> | number | null
    categoryTemp?: FloatNullableFilter<"Game"> | number | null
    originalId?: IntNullableFilter<"Game"> | number | null
    bids?: IntNullableFilter<"Game"> | number | null
    statIn?: FloatNullableFilter<"Game"> | number | null
    statOut?: FloatNullableFilter<"Game"> | number | null
    currentRtp?: FloatNullableFilter<"Game"> | number | null
    rtpStatIn?: FloatNullableFilter<"Game"> | number | null
    rtpStatOut?: FloatNullableFilter<"Game"> | number | null
    standardRtp?: FloatNullableFilter<"Game"> | number | null
    popularity?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot1?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot2?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot3?: FloatNullableFilter<"Game"> | number | null
    fireCount1?: FloatNullableFilter<"Game"> | number | null
    fireCount2?: FloatNullableFilter<"Game"> | number | null
    fireCount3?: FloatNullableFilter<"Game"> | number | null
    linesPercentConfigSpin?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigSpinBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonusBonus?: StringNullableFilter<"Game"> | string | null
    rezerv?: FloatNullableFilter<"Game"> | number | null
    cask?: FloatNullableFilter<"Game"> | number | null
    advanced?: StringNullableFilter<"Game"> | string | null
    scaleMode?: StringFilter<"Game"> | string
    slotViewState?: StringFilter<"Game"> | string
    view?: IntNullableFilter<"Game"> | number | null
    categoryId?: StringNullableFilter<"Game"> | string | null
    operatorId?: StringNullableFilter<"Game"> | string | null
    providerId?: StringNullableFilter<"Game"> | string | null
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    jackpotGroupId?: StringNullableFilter<"Game"> | string | null
    active?: BoolFilter<"Game"> | boolean
    password?: StringNullableFilter<"Game"> | string | null
    category?: EnumGameCategoryFilter<"Game"> | $Enums.GameCategory
    operator?: XOR<OperatorNullableRelationFilter, OperatorWhereInput> | null
    gamesession?: GamesessionListRelationFilter
    tournamentgame?: TournamentgameListRelationFilter
  }, "id">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    temperature?: SortOrderInput | SortOrder
    developer?: SortOrderInput | SortOrder
    vipLevel?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    featured?: SortOrderInput | SortOrder
    gamebank?: SortOrderInput | SortOrder
    bet?: SortOrderInput | SortOrder
    denomination?: SortOrderInput | SortOrder
    categoryTemp?: SortOrderInput | SortOrder
    originalId?: SortOrderInput | SortOrder
    bids?: SortOrderInput | SortOrder
    statIn?: SortOrderInput | SortOrder
    statOut?: SortOrderInput | SortOrder
    currentRtp?: SortOrderInput | SortOrder
    rtpStatIn?: SortOrderInput | SortOrder
    rtpStatOut?: SortOrderInput | SortOrder
    standardRtp?: SortOrderInput | SortOrder
    popularity?: SortOrderInput | SortOrder
    chanceFirepot1?: SortOrderInput | SortOrder
    chanceFirepot2?: SortOrderInput | SortOrder
    chanceFirepot3?: SortOrderInput | SortOrder
    fireCount1?: SortOrderInput | SortOrder
    fireCount2?: SortOrderInput | SortOrder
    fireCount3?: SortOrderInput | SortOrder
    linesPercentConfigSpin?: SortOrderInput | SortOrder
    linesPercentConfigSpinBonus?: SortOrderInput | SortOrder
    linesPercentConfigBonus?: SortOrderInput | SortOrder
    linesPercentConfigBonusBonus?: SortOrderInput | SortOrder
    rezerv?: SortOrderInput | SortOrder
    cask?: SortOrderInput | SortOrder
    advanced?: SortOrderInput | SortOrder
    scaleMode?: SortOrder
    slotViewState?: SortOrder
    view?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    operatorId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    jackpotGroupId?: SortOrderInput | SortOrder
    active?: SortOrder
    password?: SortOrderInput | SortOrder
    category?: SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    name?: StringWithAggregatesFilter<"Game"> | string
    title?: StringWithAggregatesFilter<"Game"> | string
    temperature?: StringNullableWithAggregatesFilter<"Game"> | string | null
    developer?: StringNullableWithAggregatesFilter<"Game"> | string | null
    vipLevel?: IntNullableWithAggregatesFilter<"Game"> | number | null
    isActive?: BoolNullableWithAggregatesFilter<"Game"> | boolean | null
    device?: IntNullableWithAggregatesFilter<"Game"> | number | null
    featured?: BoolNullableWithAggregatesFilter<"Game"> | boolean | null
    gamebank?: StringNullableWithAggregatesFilter<"Game"> | string | null
    bet?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    denomination?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    categoryTemp?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    originalId?: IntNullableWithAggregatesFilter<"Game"> | number | null
    bids?: IntNullableWithAggregatesFilter<"Game"> | number | null
    statIn?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    statOut?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    currentRtp?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    rtpStatIn?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    rtpStatOut?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    standardRtp?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    popularity?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    chanceFirepot1?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    chanceFirepot2?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    chanceFirepot3?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    fireCount1?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    fireCount2?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    fireCount3?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    linesPercentConfigSpin?: StringNullableWithAggregatesFilter<"Game"> | string | null
    linesPercentConfigSpinBonus?: StringNullableWithAggregatesFilter<"Game"> | string | null
    linesPercentConfigBonus?: StringNullableWithAggregatesFilter<"Game"> | string | null
    linesPercentConfigBonusBonus?: StringNullableWithAggregatesFilter<"Game"> | string | null
    rezerv?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    cask?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    advanced?: StringNullableWithAggregatesFilter<"Game"> | string | null
    scaleMode?: StringWithAggregatesFilter<"Game"> | string
    slotViewState?: StringWithAggregatesFilter<"Game"> | string
    view?: IntNullableWithAggregatesFilter<"Game"> | number | null
    categoryId?: StringNullableWithAggregatesFilter<"Game"> | string | null
    operatorId?: StringNullableWithAggregatesFilter<"Game"> | string | null
    providerId?: StringNullableWithAggregatesFilter<"Game"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Game"> | Date | string | null
    jackpotGroupId?: StringNullableWithAggregatesFilter<"Game"> | string | null
    active?: BoolWithAggregatesFilter<"Game"> | boolean
    password?: StringNullableWithAggregatesFilter<"Game"> | string | null
    category?: EnumGameCategoryWithAggregatesFilter<"Game"> | $Enums.GameCategory
  }

  export type OperatorgameWhereInput = {
    AND?: OperatorgameWhereInput | OperatorgameWhereInput[]
    OR?: OperatorgameWhereInput[]
    NOT?: OperatorgameWhereInput | OperatorgameWhereInput[]
    id?: StringFilter<"Operatorgame"> | string
    name?: StringFilter<"Operatorgame"> | string
    slug?: StringFilter<"Operatorgame"> | string
    description?: StringNullableFilter<"Operatorgame"> | string | null
    thumbnail?: StringNullableFilter<"Operatorgame"> | string | null
    minBet?: IntNullableFilter<"Operatorgame"> | number | null
    maxBet?: IntNullableFilter<"Operatorgame"> | number | null
    xpMultiplier?: FloatFilter<"Operatorgame"> | number
    isActive?: BoolFilter<"Operatorgame"> | boolean
    isPromoted?: BoolFilter<"Operatorgame"> | boolean
    createdAt?: DateTimeFilter<"Operatorgame"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Operatorgame"> | Date | string | null
    operatorId?: StringFilter<"Operatorgame"> | string
  }

  export type OperatorgameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    minBet?: SortOrderInput | SortOrder
    maxBet?: SortOrderInput | SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    operatorId?: SortOrder
  }

  export type OperatorgameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OperatorgameWhereInput | OperatorgameWhereInput[]
    OR?: OperatorgameWhereInput[]
    NOT?: OperatorgameWhereInput | OperatorgameWhereInput[]
    name?: StringFilter<"Operatorgame"> | string
    description?: StringNullableFilter<"Operatorgame"> | string | null
    thumbnail?: StringNullableFilter<"Operatorgame"> | string | null
    minBet?: IntNullableFilter<"Operatorgame"> | number | null
    maxBet?: IntNullableFilter<"Operatorgame"> | number | null
    xpMultiplier?: FloatFilter<"Operatorgame"> | number
    isActive?: BoolFilter<"Operatorgame"> | boolean
    isPromoted?: BoolFilter<"Operatorgame"> | boolean
    createdAt?: DateTimeFilter<"Operatorgame"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Operatorgame"> | Date | string | null
    operatorId?: StringFilter<"Operatorgame"> | string
  }, "id" | "slug">

  export type OperatorgameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    minBet?: SortOrderInput | SortOrder
    maxBet?: SortOrderInput | SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    operatorId?: SortOrder
    _count?: OperatorgameCountOrderByAggregateInput
    _avg?: OperatorgameAvgOrderByAggregateInput
    _max?: OperatorgameMaxOrderByAggregateInput
    _min?: OperatorgameMinOrderByAggregateInput
    _sum?: OperatorgameSumOrderByAggregateInput
  }

  export type OperatorgameScalarWhereWithAggregatesInput = {
    AND?: OperatorgameScalarWhereWithAggregatesInput | OperatorgameScalarWhereWithAggregatesInput[]
    OR?: OperatorgameScalarWhereWithAggregatesInput[]
    NOT?: OperatorgameScalarWhereWithAggregatesInput | OperatorgameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Operatorgame"> | string
    name?: StringWithAggregatesFilter<"Operatorgame"> | string
    slug?: StringWithAggregatesFilter<"Operatorgame"> | string
    description?: StringNullableWithAggregatesFilter<"Operatorgame"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"Operatorgame"> | string | null
    minBet?: IntNullableWithAggregatesFilter<"Operatorgame"> | number | null
    maxBet?: IntNullableWithAggregatesFilter<"Operatorgame"> | number | null
    xpMultiplier?: FloatWithAggregatesFilter<"Operatorgame"> | number
    isActive?: BoolWithAggregatesFilter<"Operatorgame"> | boolean
    isPromoted?: BoolWithAggregatesFilter<"Operatorgame"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Operatorgame"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Operatorgame"> | Date | string | null
    operatorId?: StringWithAggregatesFilter<"Operatorgame"> | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringNullableFilter<"Organization"> | string | null
    logo?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    metadata?: StringNullableFilter<"Organization"> | string | null
    invitations?: InvitationListRelationFilter
    members?: MemberListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    invitations?: InvitationOrderByRelationAggregateInput
    members?: MemberOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    logo?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    metadata?: StringNullableFilter<"Organization"> | string | null
    invitations?: InvitationListRelationFilter
    members?: MemberListRelationFilter
  }, "id" | "slug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"Organization"> | string | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: StringFilter<"Member"> | string
    organizationId?: StringFilter<"Member"> | string
    userId?: StringFilter<"Member"> | string
    role?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    organizationId?: StringFilter<"Member"> | string
    userId?: StringFilter<"Member"> | string
    role?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Member"> | string
    organizationId?: StringWithAggregatesFilter<"Member"> | string
    userId?: StringWithAggregatesFilter<"Member"> | string
    role?: StringWithAggregatesFilter<"Member"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    organizationId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: StringNullableFilter<"Invitation"> | string | null
    status?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    inviterId?: StringFilter<"Invitation"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    organizationId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: StringNullableFilter<"Invitation"> | string | null
    status?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    inviterId?: StringFilter<"Invitation"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    organizationId?: StringWithAggregatesFilter<"Invitation"> | string
    email?: StringWithAggregatesFilter<"Invitation"> | string
    role?: StringNullableWithAggregatesFilter<"Invitation"> | string | null
    status?: StringWithAggregatesFilter<"Invitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    inviterId?: StringWithAggregatesFilter<"Invitation"> | string
  }

  export type TwoFactorWhereInput = {
    AND?: TwoFactorWhereInput | TwoFactorWhereInput[]
    OR?: TwoFactorWhereInput[]
    NOT?: TwoFactorWhereInput | TwoFactorWhereInput[]
    id?: StringFilter<"TwoFactor"> | string
    secret?: StringFilter<"TwoFactor"> | string
    backupCodes?: StringFilter<"TwoFactor"> | string
    userId?: StringFilter<"TwoFactor"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TwoFactorOrderByWithRelationInput = {
    id?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TwoFactorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TwoFactorWhereInput | TwoFactorWhereInput[]
    OR?: TwoFactorWhereInput[]
    NOT?: TwoFactorWhereInput | TwoFactorWhereInput[]
    secret?: StringFilter<"TwoFactor"> | string
    backupCodes?: StringFilter<"TwoFactor"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type TwoFactorOrderByWithAggregationInput = {
    id?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    userId?: SortOrder
    _count?: TwoFactorCountOrderByAggregateInput
    _max?: TwoFactorMaxOrderByAggregateInput
    _min?: TwoFactorMinOrderByAggregateInput
  }

  export type TwoFactorScalarWhereWithAggregatesInput = {
    AND?: TwoFactorScalarWhereWithAggregatesInput | TwoFactorScalarWhereWithAggregatesInput[]
    OR?: TwoFactorScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorScalarWhereWithAggregatesInput | TwoFactorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwoFactor"> | string
    secret?: StringWithAggregatesFilter<"TwoFactor"> | string
    backupCodes?: StringWithAggregatesFilter<"TwoFactor"> | string
    userId?: StringWithAggregatesFilter<"TwoFactor"> | string
  }

  export type ChatmessageWhereInput = {
    AND?: ChatmessageWhereInput | ChatmessageWhereInput[]
    OR?: ChatmessageWhereInput[]
    NOT?: ChatmessageWhereInput | ChatmessageWhereInput[]
    id?: StringFilter<"Chatmessage"> | string
    content?: StringFilter<"Chatmessage"> | string
    channel?: EnumChatChannelFilter<"Chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableFilter<"Chatmessage">
    createdAt?: DateTimeFilter<"Chatmessage"> | Date | string
    userId?: StringFilter<"Chatmessage"> | string
    roomId?: StringNullableFilter<"Chatmessage"> | string | null
    chatroom?: XOR<ChatroomNullableRelationFilter, ChatroomWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChatmessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    chatroom?: ChatroomOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChatmessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatmessageWhereInput | ChatmessageWhereInput[]
    OR?: ChatmessageWhereInput[]
    NOT?: ChatmessageWhereInput | ChatmessageWhereInput[]
    content?: StringFilter<"Chatmessage"> | string
    channel?: EnumChatChannelFilter<"Chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableFilter<"Chatmessage">
    createdAt?: DateTimeFilter<"Chatmessage"> | Date | string
    userId?: StringFilter<"Chatmessage"> | string
    roomId?: StringNullableFilter<"Chatmessage"> | string | null
    chatroom?: XOR<ChatroomNullableRelationFilter, ChatroomWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChatmessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    _count?: ChatmessageCountOrderByAggregateInput
    _max?: ChatmessageMaxOrderByAggregateInput
    _min?: ChatmessageMinOrderByAggregateInput
  }

  export type ChatmessageScalarWhereWithAggregatesInput = {
    AND?: ChatmessageScalarWhereWithAggregatesInput | ChatmessageScalarWhereWithAggregatesInput[]
    OR?: ChatmessageScalarWhereWithAggregatesInput[]
    NOT?: ChatmessageScalarWhereWithAggregatesInput | ChatmessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chatmessage"> | string
    content?: StringWithAggregatesFilter<"Chatmessage"> | string
    channel?: EnumChatChannelWithAggregatesFilter<"Chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableWithAggregatesFilter<"Chatmessage">
    createdAt?: DateTimeWithAggregatesFilter<"Chatmessage"> | Date | string
    userId?: StringWithAggregatesFilter<"Chatmessage"> | string
    roomId?: StringNullableWithAggregatesFilter<"Chatmessage"> | string | null
  }

  export type ChatroomWhereInput = {
    AND?: ChatroomWhereInput | ChatroomWhereInput[]
    OR?: ChatroomWhereInput[]
    NOT?: ChatroomWhereInput | ChatroomWhereInput[]
    id?: StringFilter<"Chatroom"> | string
    name?: StringFilter<"Chatroom"> | string
    isGameRoom?: BoolFilter<"Chatroom"> | boolean
    createdAt?: DateTimeFilter<"Chatroom"> | Date | string
    gameSessionId?: StringNullableFilter<"Chatroom"> | string | null
    chatmessage?: ChatmessageListRelationFilter
    gamesession?: XOR<GamesessionNullableRelationFilter, GamesessionWhereInput> | null
  }

  export type ChatroomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    chatmessage?: ChatmessageOrderByRelationAggregateInput
    gamesession?: GamesessionOrderByWithRelationInput
  }

  export type ChatroomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameSessionId?: string
    AND?: ChatroomWhereInput | ChatroomWhereInput[]
    OR?: ChatroomWhereInput[]
    NOT?: ChatroomWhereInput | ChatroomWhereInput[]
    name?: StringFilter<"Chatroom"> | string
    isGameRoom?: BoolFilter<"Chatroom"> | boolean
    createdAt?: DateTimeFilter<"Chatroom"> | Date | string
    chatmessage?: ChatmessageListRelationFilter
    gamesession?: XOR<GamesessionNullableRelationFilter, GamesessionWhereInput> | null
  }, "id" | "gameSessionId">

  export type ChatroomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    _count?: ChatroomCountOrderByAggregateInput
    _max?: ChatroomMaxOrderByAggregateInput
    _min?: ChatroomMinOrderByAggregateInput
  }

  export type ChatroomScalarWhereWithAggregatesInput = {
    AND?: ChatroomScalarWhereWithAggregatesInput | ChatroomScalarWhereWithAggregatesInput[]
    OR?: ChatroomScalarWhereWithAggregatesInput[]
    NOT?: ChatroomScalarWhereWithAggregatesInput | ChatroomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chatroom"> | string
    name?: StringWithAggregatesFilter<"Chatroom"> | string
    isGameRoom?: BoolWithAggregatesFilter<"Chatroom"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Chatroom"> | Date | string
    gameSessionId?: StringNullableWithAggregatesFilter<"Chatroom"> | string | null
  }

  export type FriendshipWhereInput = {
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    id?: StringFilter<"Friendship"> | string
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Friendship"> | Date | string | null
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    userFriendshipFriendidtouser?: XOR<UserRelationFilter, UserWhereInput>
    userFriendshipUseridtouser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FriendshipOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    userFriendshipFriendidtouser?: UserOrderByWithRelationInput
    userFriendshipUseridtouser?: UserOrderByWithRelationInput
  }

  export type FriendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_friendId?: FriendshipUserIdFriendIdCompoundUniqueInput
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Friendship"> | Date | string | null
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    userFriendshipFriendidtouser?: XOR<UserRelationFilter, UserWhereInput>
    userFriendshipUseridtouser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_friendId">

  export type FriendshipOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    _count?: FriendshipCountOrderByAggregateInput
    _max?: FriendshipMaxOrderByAggregateInput
    _min?: FriendshipMinOrderByAggregateInput
  }

  export type FriendshipScalarWhereWithAggregatesInput = {
    AND?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    OR?: FriendshipScalarWhereWithAggregatesInput[]
    NOT?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Friendship"> | string
    status?: EnumFriendshipStatusWithAggregatesFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Friendship"> | Date | string | null
    userId?: StringWithAggregatesFilter<"Friendship"> | string
    friendId?: StringWithAggregatesFilter<"Friendship"> | string
  }

  export type GamesessionWhereInput = {
    AND?: GamesessionWhereInput | GamesessionWhereInput[]
    OR?: GamesessionWhereInput[]
    NOT?: GamesessionWhereInput | GamesessionWhereInput[]
    id?: StringFilter<"Gamesession"> | string
    startTime?: DateTimeFilter<"Gamesession"> | Date | string
    endTime?: DateTimeNullableFilter<"Gamesession"> | Date | string | null
    betAmount?: IntNullableFilter<"Gamesession"> | number | null
    winAmount?: IntNullableFilter<"Gamesession"> | number | null
    xpEarned?: IntFilter<"Gamesession"> | number
    metadata?: JsonNullableFilter<"Gamesession">
    gameId?: StringFilter<"Gamesession"> | string
    tournamentId?: StringNullableFilter<"Gamesession"> | string | null
    active?: BoolFilter<"Gamesession"> | boolean
    profileId?: StringFilter<"Gamesession"> | string
    vipInfoId?: StringNullableFilter<"Gamesession"> | string | null
    chatroom?: ChatroomListRelationFilter
    game?: XOR<GameRelationFilter, GameWhereInput>
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    tournament?: XOR<TournamentNullableRelationFilter, TournamentWhereInput> | null
    Transaction?: TransactionListRelationFilter
    VipInfo?: XOR<VipInfoNullableRelationFilter, VipInfoWhereInput> | null
  }

  export type GamesessionOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    betAmount?: SortOrderInput | SortOrder
    winAmount?: SortOrderInput | SortOrder
    xpEarned?: SortOrder
    metadata?: SortOrderInput | SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    active?: SortOrder
    profileId?: SortOrder
    vipInfoId?: SortOrderInput | SortOrder
    chatroom?: ChatroomOrderByRelationAggregateInput
    game?: GameOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    tournament?: TournamentOrderByWithRelationInput
    Transaction?: TransactionOrderByRelationAggregateInput
    VipInfo?: VipInfoOrderByWithRelationInput
  }

  export type GamesessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GamesessionWhereInput | GamesessionWhereInput[]
    OR?: GamesessionWhereInput[]
    NOT?: GamesessionWhereInput | GamesessionWhereInput[]
    startTime?: DateTimeFilter<"Gamesession"> | Date | string
    endTime?: DateTimeNullableFilter<"Gamesession"> | Date | string | null
    betAmount?: IntNullableFilter<"Gamesession"> | number | null
    winAmount?: IntNullableFilter<"Gamesession"> | number | null
    xpEarned?: IntFilter<"Gamesession"> | number
    metadata?: JsonNullableFilter<"Gamesession">
    gameId?: StringFilter<"Gamesession"> | string
    tournamentId?: StringNullableFilter<"Gamesession"> | string | null
    active?: BoolFilter<"Gamesession"> | boolean
    profileId?: StringFilter<"Gamesession"> | string
    vipInfoId?: StringNullableFilter<"Gamesession"> | string | null
    chatroom?: ChatroomListRelationFilter
    game?: XOR<GameRelationFilter, GameWhereInput>
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    tournament?: XOR<TournamentNullableRelationFilter, TournamentWhereInput> | null
    Transaction?: TransactionListRelationFilter
    VipInfo?: XOR<VipInfoNullableRelationFilter, VipInfoWhereInput> | null
  }, "id">

  export type GamesessionOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    betAmount?: SortOrderInput | SortOrder
    winAmount?: SortOrderInput | SortOrder
    xpEarned?: SortOrder
    metadata?: SortOrderInput | SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    active?: SortOrder
    profileId?: SortOrder
    vipInfoId?: SortOrderInput | SortOrder
    _count?: GamesessionCountOrderByAggregateInput
    _avg?: GamesessionAvgOrderByAggregateInput
    _max?: GamesessionMaxOrderByAggregateInput
    _min?: GamesessionMinOrderByAggregateInput
    _sum?: GamesessionSumOrderByAggregateInput
  }

  export type GamesessionScalarWhereWithAggregatesInput = {
    AND?: GamesessionScalarWhereWithAggregatesInput | GamesessionScalarWhereWithAggregatesInput[]
    OR?: GamesessionScalarWhereWithAggregatesInput[]
    NOT?: GamesessionScalarWhereWithAggregatesInput | GamesessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gamesession"> | string
    startTime?: DateTimeWithAggregatesFilter<"Gamesession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Gamesession"> | Date | string | null
    betAmount?: IntNullableWithAggregatesFilter<"Gamesession"> | number | null
    winAmount?: IntNullableWithAggregatesFilter<"Gamesession"> | number | null
    xpEarned?: IntWithAggregatesFilter<"Gamesession"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Gamesession">
    gameId?: StringWithAggregatesFilter<"Gamesession"> | string
    tournamentId?: StringNullableWithAggregatesFilter<"Gamesession"> | string | null
    active?: BoolWithAggregatesFilter<"Gamesession"> | boolean
    profileId?: StringWithAggregatesFilter<"Gamesession"> | string
    vipInfoId?: StringNullableWithAggregatesFilter<"Gamesession"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    url?: StringFilter<"Product"> | string
    type?: StringFilter<"Product"> | string
    bonusCode?: StringNullableFilter<"Product"> | string | null
    bonusTotalInCredits?: IntFilter<"Product"> | number
    priceInCents?: IntFilter<"Product"> | number
    amountToReceiveInCredits?: IntFilter<"Product"> | number
    bestValue?: IntFilter<"Product"> | number
    discountInCents?: IntFilter<"Product"> | number
    bonusSpins?: IntFilter<"Product"> | number
    isPromo?: BoolNullableFilter<"Product"> | boolean | null
    totalDiscountInCents?: IntFilter<"Product"> | number
    shopId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    operator?: XOR<OperatorNullableRelationFilter, OperatorWhereInput> | null
    transactions?: TransactionListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    bonusCode?: SortOrderInput | SortOrder
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    isPromo?: SortOrderInput | SortOrder
    totalDiscountInCents?: SortOrder
    shopId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    operator?: OperatorOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    url?: StringFilter<"Product"> | string
    type?: StringFilter<"Product"> | string
    bonusCode?: StringNullableFilter<"Product"> | string | null
    bonusTotalInCredits?: IntFilter<"Product"> | number
    priceInCents?: IntFilter<"Product"> | number
    amountToReceiveInCredits?: IntFilter<"Product"> | number
    bestValue?: IntFilter<"Product"> | number
    discountInCents?: IntFilter<"Product"> | number
    bonusSpins?: IntFilter<"Product"> | number
    isPromo?: BoolNullableFilter<"Product"> | boolean | null
    totalDiscountInCents?: IntFilter<"Product"> | number
    shopId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    operator?: XOR<OperatorNullableRelationFilter, OperatorWhereInput> | null
    transactions?: TransactionListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    bonusCode?: SortOrderInput | SortOrder
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    isPromo?: SortOrderInput | SortOrder
    totalDiscountInCents?: SortOrder
    shopId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    title?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    url?: StringWithAggregatesFilter<"Product"> | string
    type?: StringWithAggregatesFilter<"Product"> | string
    bonusCode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    bonusTotalInCredits?: IntWithAggregatesFilter<"Product"> | number
    priceInCents?: IntWithAggregatesFilter<"Product"> | number
    amountToReceiveInCredits?: IntWithAggregatesFilter<"Product"> | number
    bestValue?: IntWithAggregatesFilter<"Product"> | number
    discountInCents?: IntWithAggregatesFilter<"Product"> | number
    bonusSpins?: IntWithAggregatesFilter<"Product"> | number
    isPromo?: BoolNullableWithAggregatesFilter<"Product"> | boolean | null
    totalDiscountInCents?: IntWithAggregatesFilter<"Product"> | number
    shopId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type TournamentWhereInput = {
    AND?: TournamentWhereInput | TournamentWhereInput[]
    OR?: TournamentWhereInput[]
    NOT?: TournamentWhereInput | TournamentWhereInput[]
    id?: StringFilter<"Tournament"> | string
    name?: StringFilter<"Tournament"> | string
    description?: StringNullableFilter<"Tournament"> | string | null
    startTime?: DateTimeFilter<"Tournament"> | Date | string
    endTime?: DateTimeFilter<"Tournament"> | Date | string
    entryFee?: IntNullableFilter<"Tournament"> | number | null
    prizePool?: IntFilter<"Tournament"> | number
    isActive?: BoolFilter<"Tournament"> | boolean
    createdAt?: DateTimeFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    operatorId?: StringFilter<"Tournament"> | string
    leaderboard?: JsonNullableFilter<"Tournament">
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorRelationFilter, OperatorWhereInput>
    tournamententry?: TournamententryListRelationFilter
    tournamentgame?: TournamentgameListRelationFilter
  }

  export type TournamentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrderInput | SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    operatorId?: SortOrder
    leaderboard?: SortOrderInput | SortOrder
    gamesession?: GamesessionOrderByRelationAggregateInput
    operator?: OperatorOrderByWithRelationInput
    tournamententry?: TournamententryOrderByRelationAggregateInput
    tournamentgame?: TournamentgameOrderByRelationAggregateInput
  }

  export type TournamentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TournamentWhereInput | TournamentWhereInput[]
    OR?: TournamentWhereInput[]
    NOT?: TournamentWhereInput | TournamentWhereInput[]
    name?: StringFilter<"Tournament"> | string
    description?: StringNullableFilter<"Tournament"> | string | null
    startTime?: DateTimeFilter<"Tournament"> | Date | string
    endTime?: DateTimeFilter<"Tournament"> | Date | string
    entryFee?: IntNullableFilter<"Tournament"> | number | null
    prizePool?: IntFilter<"Tournament"> | number
    isActive?: BoolFilter<"Tournament"> | boolean
    createdAt?: DateTimeFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    operatorId?: StringFilter<"Tournament"> | string
    leaderboard?: JsonNullableFilter<"Tournament">
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorRelationFilter, OperatorWhereInput>
    tournamententry?: TournamententryListRelationFilter
    tournamentgame?: TournamentgameListRelationFilter
  }, "id">

  export type TournamentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrderInput | SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    operatorId?: SortOrder
    leaderboard?: SortOrderInput | SortOrder
    _count?: TournamentCountOrderByAggregateInput
    _avg?: TournamentAvgOrderByAggregateInput
    _max?: TournamentMaxOrderByAggregateInput
    _min?: TournamentMinOrderByAggregateInput
    _sum?: TournamentSumOrderByAggregateInput
  }

  export type TournamentScalarWhereWithAggregatesInput = {
    AND?: TournamentScalarWhereWithAggregatesInput | TournamentScalarWhereWithAggregatesInput[]
    OR?: TournamentScalarWhereWithAggregatesInput[]
    NOT?: TournamentScalarWhereWithAggregatesInput | TournamentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tournament"> | string
    name?: StringWithAggregatesFilter<"Tournament"> | string
    description?: StringNullableWithAggregatesFilter<"Tournament"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
    entryFee?: IntNullableWithAggregatesFilter<"Tournament"> | number | null
    prizePool?: IntWithAggregatesFilter<"Tournament"> | number
    isActive?: BoolWithAggregatesFilter<"Tournament"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Tournament"> | Date | string | null
    operatorId?: StringWithAggregatesFilter<"Tournament"> | string
    leaderboard?: JsonNullableWithAggregatesFilter<"Tournament">
  }

  export type TournamententryWhereInput = {
    AND?: TournamententryWhereInput | TournamententryWhereInput[]
    OR?: TournamententryWhereInput[]
    NOT?: TournamententryWhereInput | TournamententryWhereInput[]
    id?: StringFilter<"Tournamententry"> | string
    score?: IntFilter<"Tournamententry"> | number
    wagered?: IntFilter<"Tournamententry"> | number
    won?: IntFilter<"Tournamententry"> | number
    joinedAt?: DateTimeFilter<"Tournamententry"> | Date | string
    userId?: StringFilter<"Tournamententry"> | string
    tournamentId?: StringFilter<"Tournamententry"> | string
    profileId?: StringFilter<"Tournamententry"> | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    tournament?: XOR<TournamentRelationFilter, TournamentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TournamententryOrderByWithRelationInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    tournament?: TournamentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TournamententryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tournamentId?: TournamententryUserIdTournamentIdCompoundUniqueInput
    AND?: TournamententryWhereInput | TournamententryWhereInput[]
    OR?: TournamententryWhereInput[]
    NOT?: TournamententryWhereInput | TournamententryWhereInput[]
    score?: IntFilter<"Tournamententry"> | number
    wagered?: IntFilter<"Tournamententry"> | number
    won?: IntFilter<"Tournamententry"> | number
    joinedAt?: DateTimeFilter<"Tournamententry"> | Date | string
    userId?: StringFilter<"Tournamententry"> | string
    tournamentId?: StringFilter<"Tournamententry"> | string
    profileId?: StringFilter<"Tournamententry"> | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    tournament?: XOR<TournamentRelationFilter, TournamentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_tournamentId">

  export type TournamententryOrderByWithAggregationInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
    _count?: TournamententryCountOrderByAggregateInput
    _avg?: TournamententryAvgOrderByAggregateInput
    _max?: TournamententryMaxOrderByAggregateInput
    _min?: TournamententryMinOrderByAggregateInput
    _sum?: TournamententrySumOrderByAggregateInput
  }

  export type TournamententryScalarWhereWithAggregatesInput = {
    AND?: TournamententryScalarWhereWithAggregatesInput | TournamententryScalarWhereWithAggregatesInput[]
    OR?: TournamententryScalarWhereWithAggregatesInput[]
    NOT?: TournamententryScalarWhereWithAggregatesInput | TournamententryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tournamententry"> | string
    score?: IntWithAggregatesFilter<"Tournamententry"> | number
    wagered?: IntWithAggregatesFilter<"Tournamententry"> | number
    won?: IntWithAggregatesFilter<"Tournamententry"> | number
    joinedAt?: DateTimeWithAggregatesFilter<"Tournamententry"> | Date | string
    userId?: StringWithAggregatesFilter<"Tournamententry"> | string
    tournamentId?: StringWithAggregatesFilter<"Tournamententry"> | string
    profileId?: StringWithAggregatesFilter<"Tournamententry"> | string
  }

  export type TournamentgameWhereInput = {
    AND?: TournamentgameWhereInput | TournamentgameWhereInput[]
    OR?: TournamentgameWhereInput[]
    NOT?: TournamentgameWhereInput | TournamentgameWhereInput[]
    id?: StringFilter<"Tournamentgame"> | string
    multiplier?: FloatFilter<"Tournamentgame"> | number
    tournamentId?: StringFilter<"Tournamentgame"> | string
    gameId?: StringFilter<"Tournamentgame"> | string
    game?: XOR<GameRelationFilter, GameWhereInput>
    tournament?: XOR<TournamentRelationFilter, TournamentWhereInput>
  }

  export type TournamentgameOrderByWithRelationInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
    game?: GameOrderByWithRelationInput
    tournament?: TournamentOrderByWithRelationInput
  }

  export type TournamentgameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tournamentId_gameId?: TournamentgameTournamentIdGameIdCompoundUniqueInput
    AND?: TournamentgameWhereInput | TournamentgameWhereInput[]
    OR?: TournamentgameWhereInput[]
    NOT?: TournamentgameWhereInput | TournamentgameWhereInput[]
    multiplier?: FloatFilter<"Tournamentgame"> | number
    tournamentId?: StringFilter<"Tournamentgame"> | string
    gameId?: StringFilter<"Tournamentgame"> | string
    game?: XOR<GameRelationFilter, GameWhereInput>
    tournament?: XOR<TournamentRelationFilter, TournamentWhereInput>
  }, "id" | "tournamentId_gameId">

  export type TournamentgameOrderByWithAggregationInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
    _count?: TournamentgameCountOrderByAggregateInput
    _avg?: TournamentgameAvgOrderByAggregateInput
    _max?: TournamentgameMaxOrderByAggregateInput
    _min?: TournamentgameMinOrderByAggregateInput
    _sum?: TournamentgameSumOrderByAggregateInput
  }

  export type TournamentgameScalarWhereWithAggregatesInput = {
    AND?: TournamentgameScalarWhereWithAggregatesInput | TournamentgameScalarWhereWithAggregatesInput[]
    OR?: TournamentgameScalarWhereWithAggregatesInput[]
    NOT?: TournamentgameScalarWhereWithAggregatesInput | TournamentgameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tournamentgame"> | string
    multiplier?: FloatWithAggregatesFilter<"Tournamentgame"> | number
    tournamentId?: StringWithAggregatesFilter<"Tournamentgame"> | string
    gameId?: StringWithAggregatesFilter<"Tournamentgame"> | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntFilter<"Transaction"> | number
    amountCredits?: IntFilter<"Transaction"> | number
    buyerCashtag?: StringNullableFilter<"Transaction"> | string | null
    buyerUserId?: StringNullableFilter<"Transaction"> | string | null
    username?: StringNullableFilter<"Transaction"> | string | null
    cashiername?: StringNullableFilter<"Transaction"> | string | null
    cashierAvatar?: StringNullableFilter<"Transaction"> | string | null
    cashierId?: StringNullableFilter<"Transaction"> | string | null
    reference?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"Transaction">
    isRealMoney?: BoolFilter<"Transaction"> | boolean
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    paymentDetails?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    gameSessionId?: StringNullableFilter<"Transaction"> | string | null
    profileId?: StringNullableFilter<"Transaction"> | string | null
    cashtag?: StringNullableFilter<"Transaction"> | string | null
    productid?: StringNullableFilter<"Transaction"> | string | null
    vipInfoId?: StringNullableFilter<"Transaction"> | string | null
    gamesession?: XOR<GamesessionNullableRelationFilter, GamesessionWhereInput> | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    vipInfo?: XOR<VipInfoNullableRelationFilter, VipInfoWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    amountCredits?: SortOrder
    buyerCashtag?: SortOrderInput | SortOrder
    buyerUserId?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    cashiername?: SortOrderInput | SortOrder
    cashierAvatar?: SortOrderInput | SortOrder
    cashierId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    profileId?: SortOrderInput | SortOrder
    cashtag?: SortOrderInput | SortOrder
    productid?: SortOrderInput | SortOrder
    vipInfoId?: SortOrderInput | SortOrder
    gamesession?: GamesessionOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    vipInfo?: VipInfoOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntFilter<"Transaction"> | number
    amountCredits?: IntFilter<"Transaction"> | number
    buyerCashtag?: StringNullableFilter<"Transaction"> | string | null
    buyerUserId?: StringNullableFilter<"Transaction"> | string | null
    username?: StringNullableFilter<"Transaction"> | string | null
    cashiername?: StringNullableFilter<"Transaction"> | string | null
    cashierAvatar?: StringNullableFilter<"Transaction"> | string | null
    cashierId?: StringNullableFilter<"Transaction"> | string | null
    reference?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"Transaction">
    isRealMoney?: BoolFilter<"Transaction"> | boolean
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    paymentDetails?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    gameSessionId?: StringNullableFilter<"Transaction"> | string | null
    profileId?: StringNullableFilter<"Transaction"> | string | null
    cashtag?: StringNullableFilter<"Transaction"> | string | null
    productid?: StringNullableFilter<"Transaction"> | string | null
    vipInfoId?: StringNullableFilter<"Transaction"> | string | null
    gamesession?: XOR<GamesessionNullableRelationFilter, GamesessionWhereInput> | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    vipInfo?: XOR<VipInfoNullableRelationFilter, VipInfoWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    amountCredits?: SortOrder
    buyerCashtag?: SortOrderInput | SortOrder
    buyerUserId?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    cashiername?: SortOrderInput | SortOrder
    cashierAvatar?: SortOrderInput | SortOrder
    cashierId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    profileId?: SortOrderInput | SortOrder
    cashtag?: SortOrderInput | SortOrder
    productid?: SortOrderInput | SortOrder
    vipInfoId?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntWithAggregatesFilter<"Transaction"> | number
    amountCredits?: IntWithAggregatesFilter<"Transaction"> | number
    buyerCashtag?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    buyerUserId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    username?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    cashiername?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    cashierAvatar?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    cashierId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableWithAggregatesFilter<"Transaction">
    isRealMoney?: BoolWithAggregatesFilter<"Transaction"> | boolean
    paymentMethod?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentDetails?: JsonNullableWithAggregatesFilter<"Transaction">
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    gameSessionId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    profileId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    cashtag?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    productid?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    vipInfoId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
  }

  export type UserachievementWhereInput = {
    AND?: UserachievementWhereInput | UserachievementWhereInput[]
    OR?: UserachievementWhereInput[]
    NOT?: UserachievementWhereInput | UserachievementWhereInput[]
    id?: StringFilter<"Userachievement"> | string
    progress?: IntFilter<"Userachievement"> | number
    isUnlocked?: BoolFilter<"Userachievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Userachievement"> | Date | string | null
    createdAt?: DateTimeFilter<"Userachievement"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Userachievement"> | Date | string | null
    userId?: StringFilter<"Userachievement"> | string
    achievementId?: StringFilter<"Userachievement"> | string
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserachievementOrderByWithRelationInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    achievement?: AchievementOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserachievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: UserachievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserachievementWhereInput | UserachievementWhereInput[]
    OR?: UserachievementWhereInput[]
    NOT?: UserachievementWhereInput | UserachievementWhereInput[]
    progress?: IntFilter<"Userachievement"> | number
    isUnlocked?: BoolFilter<"Userachievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Userachievement"> | Date | string | null
    createdAt?: DateTimeFilter<"Userachievement"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Userachievement"> | Date | string | null
    userId?: StringFilter<"Userachievement"> | string
    achievementId?: StringFilter<"Userachievement"> | string
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_achievementId">

  export type UserachievementOrderByWithAggregationInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    _count?: UserachievementCountOrderByAggregateInput
    _avg?: UserachievementAvgOrderByAggregateInput
    _max?: UserachievementMaxOrderByAggregateInput
    _min?: UserachievementMinOrderByAggregateInput
    _sum?: UserachievementSumOrderByAggregateInput
  }

  export type UserachievementScalarWhereWithAggregatesInput = {
    AND?: UserachievementScalarWhereWithAggregatesInput | UserachievementScalarWhereWithAggregatesInput[]
    OR?: UserachievementScalarWhereWithAggregatesInput[]
    NOT?: UserachievementScalarWhereWithAggregatesInput | UserachievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Userachievement"> | string
    progress?: IntWithAggregatesFilter<"Userachievement"> | number
    isUnlocked?: BoolWithAggregatesFilter<"Userachievement"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Userachievement"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Userachievement"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Userachievement"> | Date | string | null
    userId?: StringWithAggregatesFilter<"Userachievement"> | string
    achievementId?: StringWithAggregatesFilter<"Userachievement"> | string
  }

  export type RainBetWhereInput = {
    AND?: RainBetWhereInput | RainBetWhereInput[]
    OR?: RainBetWhereInput[]
    NOT?: RainBetWhereInput | RainBetWhereInput[]
    id?: StringFilter<"RainBet"> | string
    rainHistoryId?: StringFilter<"RainBet"> | string
    userId?: StringFilter<"RainBet"> | string
    betAmount?: IntFilter<"RainBet"> | number
    odds?: IntFilter<"RainBet"> | number
    outcome?: StringNullableFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableFilter<"RainBet"> | Date | string | null
    RainHistory?: XOR<RainHistoryRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RainBetOrderByWithRelationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrderInput | SortOrder
    settledAt?: SortOrderInput | SortOrder
    RainHistory?: RainHistoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RainBetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainBetWhereInput | RainBetWhereInput[]
    OR?: RainBetWhereInput[]
    NOT?: RainBetWhereInput | RainBetWhereInput[]
    rainHistoryId?: StringFilter<"RainBet"> | string
    userId?: StringFilter<"RainBet"> | string
    betAmount?: IntFilter<"RainBet"> | number
    odds?: IntFilter<"RainBet"> | number
    outcome?: StringNullableFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableFilter<"RainBet"> | Date | string | null
    RainHistory?: XOR<RainHistoryRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type RainBetOrderByWithAggregationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrderInput | SortOrder
    settledAt?: SortOrderInput | SortOrder
    _count?: RainBetCountOrderByAggregateInput
    _avg?: RainBetAvgOrderByAggregateInput
    _max?: RainBetMaxOrderByAggregateInput
    _min?: RainBetMinOrderByAggregateInput
    _sum?: RainBetSumOrderByAggregateInput
  }

  export type RainBetScalarWhereWithAggregatesInput = {
    AND?: RainBetScalarWhereWithAggregatesInput | RainBetScalarWhereWithAggregatesInput[]
    OR?: RainBetScalarWhereWithAggregatesInput[]
    NOT?: RainBetScalarWhereWithAggregatesInput | RainBetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainBet"> | string
    rainHistoryId?: StringWithAggregatesFilter<"RainBet"> | string
    userId?: StringWithAggregatesFilter<"RainBet"> | string
    betAmount?: IntWithAggregatesFilter<"RainBet"> | number
    odds?: IntWithAggregatesFilter<"RainBet"> | number
    outcome?: StringNullableWithAggregatesFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableWithAggregatesFilter<"RainBet"> | Date | string | null
  }

  export type RainHistoryWhereInput = {
    AND?: RainHistoryWhereInput | RainHistoryWhereInput[]
    OR?: RainHistoryWhereInput[]
    NOT?: RainHistoryWhereInput | RainHistoryWhereInput[]
    id?: StringFilter<"RainHistory"> | string
    userId?: StringFilter<"RainHistory"> | string
    amount?: IntFilter<"RainHistory"> | number
    rainType?: StringFilter<"RainHistory"> | string
    createdAt?: DateTimeFilter<"RainHistory"> | Date | string
    RainBet?: RainBetListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
  }

  export type RainHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
    RainBet?: RainBetOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    RainTip?: RainTipOrderByRelationAggregateInput
    RainWinner?: RainWinnerOrderByRelationAggregateInput
  }

  export type RainHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainHistoryWhereInput | RainHistoryWhereInput[]
    OR?: RainHistoryWhereInput[]
    NOT?: RainHistoryWhereInput | RainHistoryWhereInput[]
    userId?: StringFilter<"RainHistory"> | string
    amount?: IntFilter<"RainHistory"> | number
    rainType?: StringFilter<"RainHistory"> | string
    createdAt?: DateTimeFilter<"RainHistory"> | Date | string
    RainBet?: RainBetListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
  }, "id">

  export type RainHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
    _count?: RainHistoryCountOrderByAggregateInput
    _avg?: RainHistoryAvgOrderByAggregateInput
    _max?: RainHistoryMaxOrderByAggregateInput
    _min?: RainHistoryMinOrderByAggregateInput
    _sum?: RainHistorySumOrderByAggregateInput
  }

  export type RainHistoryScalarWhereWithAggregatesInput = {
    AND?: RainHistoryScalarWhereWithAggregatesInput | RainHistoryScalarWhereWithAggregatesInput[]
    OR?: RainHistoryScalarWhereWithAggregatesInput[]
    NOT?: RainHistoryScalarWhereWithAggregatesInput | RainHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainHistory"> | string
    userId?: StringWithAggregatesFilter<"RainHistory"> | string
    amount?: IntWithAggregatesFilter<"RainHistory"> | number
    rainType?: StringWithAggregatesFilter<"RainHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RainHistory"> | Date | string
  }

  export type RainTipWhereInput = {
    AND?: RainTipWhereInput | RainTipWhereInput[]
    OR?: RainTipWhereInput[]
    NOT?: RainTipWhereInput | RainTipWhereInput[]
    id?: StringFilter<"RainTip"> | string
    rainHistoryId?: StringFilter<"RainTip"> | string
    userId?: StringFilter<"RainTip"> | string
    tipAmount?: IntFilter<"RainTip"> | number
    tippedAt?: DateTimeFilter<"RainTip"> | Date | string
    RainHistory?: XOR<RainHistoryRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RainTipOrderByWithRelationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
    RainHistory?: RainHistoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RainTipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainTipWhereInput | RainTipWhereInput[]
    OR?: RainTipWhereInput[]
    NOT?: RainTipWhereInput | RainTipWhereInput[]
    rainHistoryId?: StringFilter<"RainTip"> | string
    userId?: StringFilter<"RainTip"> | string
    tipAmount?: IntFilter<"RainTip"> | number
    tippedAt?: DateTimeFilter<"RainTip"> | Date | string
    RainHistory?: XOR<RainHistoryRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type RainTipOrderByWithAggregationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
    _count?: RainTipCountOrderByAggregateInput
    _avg?: RainTipAvgOrderByAggregateInput
    _max?: RainTipMaxOrderByAggregateInput
    _min?: RainTipMinOrderByAggregateInput
    _sum?: RainTipSumOrderByAggregateInput
  }

  export type RainTipScalarWhereWithAggregatesInput = {
    AND?: RainTipScalarWhereWithAggregatesInput | RainTipScalarWhereWithAggregatesInput[]
    OR?: RainTipScalarWhereWithAggregatesInput[]
    NOT?: RainTipScalarWhereWithAggregatesInput | RainTipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainTip"> | string
    rainHistoryId?: StringWithAggregatesFilter<"RainTip"> | string
    userId?: StringWithAggregatesFilter<"RainTip"> | string
    tipAmount?: IntWithAggregatesFilter<"RainTip"> | number
    tippedAt?: DateTimeWithAggregatesFilter<"RainTip"> | Date | string
  }

  export type RainWinnerWhereInput = {
    AND?: RainWinnerWhereInput | RainWinnerWhereInput[]
    OR?: RainWinnerWhereInput[]
    NOT?: RainWinnerWhereInput | RainWinnerWhereInput[]
    id?: StringFilter<"RainWinner"> | string
    rainHistoryId?: StringFilter<"RainWinner"> | string
    userId?: StringFilter<"RainWinner"> | string
    wonAmount?: IntFilter<"RainWinner"> | number
    wonAt?: DateTimeFilter<"RainWinner"> | Date | string
    RainHistory?: XOR<RainHistoryRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RainWinnerOrderByWithRelationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
    RainHistory?: RainHistoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RainWinnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainWinnerWhereInput | RainWinnerWhereInput[]
    OR?: RainWinnerWhereInput[]
    NOT?: RainWinnerWhereInput | RainWinnerWhereInput[]
    rainHistoryId?: StringFilter<"RainWinner"> | string
    userId?: StringFilter<"RainWinner"> | string
    wonAmount?: IntFilter<"RainWinner"> | number
    wonAt?: DateTimeFilter<"RainWinner"> | Date | string
    RainHistory?: XOR<RainHistoryRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type RainWinnerOrderByWithAggregationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
    _count?: RainWinnerCountOrderByAggregateInput
    _avg?: RainWinnerAvgOrderByAggregateInput
    _max?: RainWinnerMaxOrderByAggregateInput
    _min?: RainWinnerMinOrderByAggregateInput
    _sum?: RainWinnerSumOrderByAggregateInput
  }

  export type RainWinnerScalarWhereWithAggregatesInput = {
    AND?: RainWinnerScalarWhereWithAggregatesInput | RainWinnerScalarWhereWithAggregatesInput[]
    OR?: RainWinnerScalarWhereWithAggregatesInput[]
    NOT?: RainWinnerScalarWhereWithAggregatesInput | RainWinnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainWinner"> | string
    rainHistoryId?: StringWithAggregatesFilter<"RainWinner"> | string
    userId?: StringWithAggregatesFilter<"RainWinner"> | string
    wonAmount?: IntWithAggregatesFilter<"RainWinner"> | number
    wonAt?: DateTimeWithAggregatesFilter<"RainWinner"> | Date | string
  }

  export type VipInfoWhereInput = {
    AND?: VipInfoWhereInput | VipInfoWhereInput[]
    OR?: VipInfoWhereInput[]
    NOT?: VipInfoWhereInput | VipInfoWhereInput[]
    id?: StringFilter<"VipInfo"> | string
    level?: IntFilter<"VipInfo"> | number
    deposit_exp?: IntFilter<"VipInfo"> | number
    bet_exp?: IntFilter<"VipInfo"> | number
    rank_bet_exp?: IntFilter<"VipInfo"> | number
    rank_deposit_exp?: IntFilter<"VipInfo"> | number
    rank_name?: StringNullableFilter<"VipInfo"> | string | null
    icon?: StringNullableFilter<"VipInfo"> | string | null
    exp_switch_type?: IntNullableFilter<"VipInfo"> | number | null
    now_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    level_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    now_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    level_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    telegram?: StringNullableFilter<"VipInfo"> | string | null
    is_protection?: BoolFilter<"VipInfo"> | boolean
    protection_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    protection_deposit_amount?: StringNullableFilter<"VipInfo"> | string | null
    protection_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    protection_bet_amount?: StringNullableFilter<"VipInfo"> | string | null
    protection_days?: IntNullableFilter<"VipInfo"> | number | null
    protection_switch?: IntNullableFilter<"VipInfo"> | number | null
    cycle_award_switch?: BoolFilter<"VipInfo"> | boolean
    level_award_switch?: BoolFilter<"VipInfo"> | boolean
    signin_award_switch?: BoolFilter<"VipInfo"> | boolean
    bet_award_switch?: BoolFilter<"VipInfo"> | boolean
    withdrawal_award_switch?: BoolFilter<"VipInfo"> | boolean
    unprotection_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_deposit_amount?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_bet_amount?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_days?: IntNullableFilter<"VipInfo"> | number | null
    unprotection_switch?: IntNullableFilter<"VipInfo"> | number | null
    main_currency?: StringNullableFilter<"VipInfo"> | string | null
    can_receive_level_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_rank_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_day_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_week_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_month_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_signin_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_bet_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_withdrawal_award?: BoolFilter<"VipInfo"> | boolean
    userid?: StringNullableFilter<"VipInfo"> | string | null
    free_spin_times?: IntNullableFilter<"VipInfo"> | number | null
    week_gift?: IntNullableFilter<"VipInfo"> | number | null
    month_gift?: IntNullableFilter<"VipInfo"> | number | null
    upgrade_gift?: IntNullableFilter<"VipInfo"> | number | null
    now_cash_back?: IntNullableFilter<"VipInfo"> | number | null
    yesterday_cash_back?: IntNullableFilter<"VipInfo"> | number | null
    history_cash_back?: IntNullableFilter<"VipInfo"> | number | null
    operatorId?: StringNullableFilter<"VipInfo"> | string | null
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorNullableRelationFilter, OperatorWhereInput> | null
    transactions?: TransactionListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type VipInfoOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    rank_name?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    exp_switch_type?: SortOrderInput | SortOrder
    now_deposit_exp?: SortOrderInput | SortOrder
    level_deposit_exp?: SortOrderInput | SortOrder
    now_bet_exp?: SortOrderInput | SortOrder
    level_bet_exp?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    is_protection?: SortOrder
    protection_deposit_exp?: SortOrderInput | SortOrder
    protection_deposit_amount?: SortOrderInput | SortOrder
    protection_bet_exp?: SortOrderInput | SortOrder
    protection_bet_amount?: SortOrderInput | SortOrder
    protection_days?: SortOrderInput | SortOrder
    protection_switch?: SortOrderInput | SortOrder
    cycle_award_switch?: SortOrder
    level_award_switch?: SortOrder
    signin_award_switch?: SortOrder
    bet_award_switch?: SortOrder
    withdrawal_award_switch?: SortOrder
    unprotection_deposit_exp?: SortOrderInput | SortOrder
    unprotection_deposit_amount?: SortOrderInput | SortOrder
    unprotection_bet_exp?: SortOrderInput | SortOrder
    unprotection_bet_amount?: SortOrderInput | SortOrder
    unprotection_days?: SortOrderInput | SortOrder
    unprotection_switch?: SortOrderInput | SortOrder
    main_currency?: SortOrderInput | SortOrder
    can_receive_level_award?: SortOrder
    can_receive_rank_award?: SortOrder
    can_receive_day_award?: SortOrder
    can_receive_week_award?: SortOrder
    can_receive_month_award?: SortOrder
    can_receive_signin_award?: SortOrder
    can_receive_bet_award?: SortOrder
    can_receive_withdrawal_award?: SortOrder
    userid?: SortOrderInput | SortOrder
    free_spin_times?: SortOrderInput | SortOrder
    week_gift?: SortOrderInput | SortOrder
    month_gift?: SortOrderInput | SortOrder
    upgrade_gift?: SortOrderInput | SortOrder
    now_cash_back?: SortOrderInput | SortOrder
    yesterday_cash_back?: SortOrderInput | SortOrder
    history_cash_back?: SortOrderInput | SortOrder
    operatorId?: SortOrderInput | SortOrder
    gamesession?: GamesessionOrderByRelationAggregateInput
    operator?: OperatorOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type VipInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userid?: string
    AND?: VipInfoWhereInput | VipInfoWhereInput[]
    OR?: VipInfoWhereInput[]
    NOT?: VipInfoWhereInput | VipInfoWhereInput[]
    level?: IntFilter<"VipInfo"> | number
    deposit_exp?: IntFilter<"VipInfo"> | number
    bet_exp?: IntFilter<"VipInfo"> | number
    rank_bet_exp?: IntFilter<"VipInfo"> | number
    rank_deposit_exp?: IntFilter<"VipInfo"> | number
    rank_name?: StringNullableFilter<"VipInfo"> | string | null
    icon?: StringNullableFilter<"VipInfo"> | string | null
    exp_switch_type?: IntNullableFilter<"VipInfo"> | number | null
    now_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    level_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    now_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    level_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    telegram?: StringNullableFilter<"VipInfo"> | string | null
    is_protection?: BoolFilter<"VipInfo"> | boolean
    protection_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    protection_deposit_amount?: StringNullableFilter<"VipInfo"> | string | null
    protection_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    protection_bet_amount?: StringNullableFilter<"VipInfo"> | string | null
    protection_days?: IntNullableFilter<"VipInfo"> | number | null
    protection_switch?: IntNullableFilter<"VipInfo"> | number | null
    cycle_award_switch?: BoolFilter<"VipInfo"> | boolean
    level_award_switch?: BoolFilter<"VipInfo"> | boolean
    signin_award_switch?: BoolFilter<"VipInfo"> | boolean
    bet_award_switch?: BoolFilter<"VipInfo"> | boolean
    withdrawal_award_switch?: BoolFilter<"VipInfo"> | boolean
    unprotection_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_deposit_amount?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_bet_amount?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_days?: IntNullableFilter<"VipInfo"> | number | null
    unprotection_switch?: IntNullableFilter<"VipInfo"> | number | null
    main_currency?: StringNullableFilter<"VipInfo"> | string | null
    can_receive_level_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_rank_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_day_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_week_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_month_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_signin_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_bet_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_withdrawal_award?: BoolFilter<"VipInfo"> | boolean
    free_spin_times?: IntNullableFilter<"VipInfo"> | number | null
    week_gift?: IntNullableFilter<"VipInfo"> | number | null
    month_gift?: IntNullableFilter<"VipInfo"> | number | null
    upgrade_gift?: IntNullableFilter<"VipInfo"> | number | null
    now_cash_back?: IntNullableFilter<"VipInfo"> | number | null
    yesterday_cash_back?: IntNullableFilter<"VipInfo"> | number | null
    history_cash_back?: IntNullableFilter<"VipInfo"> | number | null
    operatorId?: StringNullableFilter<"VipInfo"> | string | null
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorNullableRelationFilter, OperatorWhereInput> | null
    transactions?: TransactionListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "userid">

  export type VipInfoOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    rank_name?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    exp_switch_type?: SortOrderInput | SortOrder
    now_deposit_exp?: SortOrderInput | SortOrder
    level_deposit_exp?: SortOrderInput | SortOrder
    now_bet_exp?: SortOrderInput | SortOrder
    level_bet_exp?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    is_protection?: SortOrder
    protection_deposit_exp?: SortOrderInput | SortOrder
    protection_deposit_amount?: SortOrderInput | SortOrder
    protection_bet_exp?: SortOrderInput | SortOrder
    protection_bet_amount?: SortOrderInput | SortOrder
    protection_days?: SortOrderInput | SortOrder
    protection_switch?: SortOrderInput | SortOrder
    cycle_award_switch?: SortOrder
    level_award_switch?: SortOrder
    signin_award_switch?: SortOrder
    bet_award_switch?: SortOrder
    withdrawal_award_switch?: SortOrder
    unprotection_deposit_exp?: SortOrderInput | SortOrder
    unprotection_deposit_amount?: SortOrderInput | SortOrder
    unprotection_bet_exp?: SortOrderInput | SortOrder
    unprotection_bet_amount?: SortOrderInput | SortOrder
    unprotection_days?: SortOrderInput | SortOrder
    unprotection_switch?: SortOrderInput | SortOrder
    main_currency?: SortOrderInput | SortOrder
    can_receive_level_award?: SortOrder
    can_receive_rank_award?: SortOrder
    can_receive_day_award?: SortOrder
    can_receive_week_award?: SortOrder
    can_receive_month_award?: SortOrder
    can_receive_signin_award?: SortOrder
    can_receive_bet_award?: SortOrder
    can_receive_withdrawal_award?: SortOrder
    userid?: SortOrderInput | SortOrder
    free_spin_times?: SortOrderInput | SortOrder
    week_gift?: SortOrderInput | SortOrder
    month_gift?: SortOrderInput | SortOrder
    upgrade_gift?: SortOrderInput | SortOrder
    now_cash_back?: SortOrderInput | SortOrder
    yesterday_cash_back?: SortOrderInput | SortOrder
    history_cash_back?: SortOrderInput | SortOrder
    operatorId?: SortOrderInput | SortOrder
    _count?: VipInfoCountOrderByAggregateInput
    _avg?: VipInfoAvgOrderByAggregateInput
    _max?: VipInfoMaxOrderByAggregateInput
    _min?: VipInfoMinOrderByAggregateInput
    _sum?: VipInfoSumOrderByAggregateInput
  }

  export type VipInfoScalarWhereWithAggregatesInput = {
    AND?: VipInfoScalarWhereWithAggregatesInput | VipInfoScalarWhereWithAggregatesInput[]
    OR?: VipInfoScalarWhereWithAggregatesInput[]
    NOT?: VipInfoScalarWhereWithAggregatesInput | VipInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VipInfo"> | string
    level?: IntWithAggregatesFilter<"VipInfo"> | number
    deposit_exp?: IntWithAggregatesFilter<"VipInfo"> | number
    bet_exp?: IntWithAggregatesFilter<"VipInfo"> | number
    rank_bet_exp?: IntWithAggregatesFilter<"VipInfo"> | number
    rank_deposit_exp?: IntWithAggregatesFilter<"VipInfo"> | number
    rank_name?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    icon?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    exp_switch_type?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    now_deposit_exp?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    level_deposit_exp?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    now_bet_exp?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    level_bet_exp?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    telegram?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    is_protection?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    protection_deposit_exp?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    protection_deposit_amount?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    protection_bet_exp?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    protection_bet_amount?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    protection_days?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    protection_switch?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    cycle_award_switch?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    level_award_switch?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    signin_award_switch?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    bet_award_switch?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    withdrawal_award_switch?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    unprotection_deposit_exp?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    unprotection_deposit_amount?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    unprotection_bet_exp?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    unprotection_bet_amount?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    unprotection_days?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    unprotection_switch?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    main_currency?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    can_receive_level_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_rank_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_day_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_week_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_month_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_signin_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_bet_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_withdrawal_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    userid?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
    free_spin_times?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    week_gift?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    month_gift?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    upgrade_gift?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    now_cash_back?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    yesterday_cash_back?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    history_cash_back?: IntNullableWithAggregatesFilter<"VipInfo"> | number | null
    operatorId?: StringNullableWithAggregatesFilter<"VipInfo"> | string | null
  }

  export type EventLogWhereInput = {
    AND?: EventLogWhereInput | EventLogWhereInput[]
    OR?: EventLogWhereInput[]
    NOT?: EventLogWhereInput | EventLogWhereInput[]
    id?: BigIntFilter<"EventLog"> | bigint | number
    tableName?: StringFilter<"EventLog"> | string
    rowId?: StringNullableFilter<"EventLog"> | string | null
    operation?: StringFilter<"EventLog"> | string
    payload?: JsonNullableFilter<"EventLog">
    createdAt?: DateTimeNullableFilter<"EventLog"> | Date | string | null
  }

  export type EventLogOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    rowId?: SortOrderInput | SortOrder
    operation?: SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
  }

  export type EventLogWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: EventLogWhereInput | EventLogWhereInput[]
    OR?: EventLogWhereInput[]
    NOT?: EventLogWhereInput | EventLogWhereInput[]
    tableName?: StringFilter<"EventLog"> | string
    rowId?: StringNullableFilter<"EventLog"> | string | null
    operation?: StringFilter<"EventLog"> | string
    payload?: JsonNullableFilter<"EventLog">
    createdAt?: DateTimeNullableFilter<"EventLog"> | Date | string | null
  }, "id">

  export type EventLogOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    rowId?: SortOrderInput | SortOrder
    operation?: SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: EventLogCountOrderByAggregateInput
    _avg?: EventLogAvgOrderByAggregateInput
    _max?: EventLogMaxOrderByAggregateInput
    _min?: EventLogMinOrderByAggregateInput
    _sum?: EventLogSumOrderByAggregateInput
  }

  export type EventLogScalarWhereWithAggregatesInput = {
    AND?: EventLogScalarWhereWithAggregatesInput | EventLogScalarWhereWithAggregatesInput[]
    OR?: EventLogScalarWhereWithAggregatesInput[]
    NOT?: EventLogScalarWhereWithAggregatesInput | EventLogScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"EventLog"> | bigint | number
    tableName?: StringWithAggregatesFilter<"EventLog"> | string
    rowId?: StringNullableWithAggregatesFilter<"EventLog"> | string | null
    operation?: StringWithAggregatesFilter<"EventLog"> | string
    payload?: JsonNullableWithAggregatesFilter<"EventLog">
    createdAt?: DateTimeNullableWithAggregatesFilter<"EventLog"> | Date | string | null
  }

  export type AchievementCreateInput = {
    id?: string
    name: string
    description: string
    targetXp: number
    reward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userachievement?: UserachievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    targetXp: number
    reward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userachievement?: UserachievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userachievement?: UserachievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    name: string
    description: string
    targetXp: number
    reward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlatformSessionCreateInput = {
    id?: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type PlatformSessionUncheckedCreateInput = {
    id?: string
    userId: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
  }

  export type PlatformSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type PlatformSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlatformSessionCreateManyInput = {
    id?: string
    userId: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
  }

  export type PlatformSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlatformSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperatorCreateInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    games?: GameCreateNestedManyWithoutOperatorInput
    products?: ProductCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    ownerId: string
    balance?: number
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    products?: ProductUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    games?: GameUpdateManyWithoutOperatorNestedInput
    products?: ProductUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorCreateManyInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    ownerId: string
    balance?: number
  }

  export type OperatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    balance?: IntFieldUpdateOperationsInput | number
  }

  export type OperatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
  }

  export type MessageCreateInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    authorId?: string | null
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    authorId?: string | null
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    authorId?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileCreateInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    operator: OperatorCreateNestedOneWithoutProfilesInput
    userProfileUseridtouser: UserCreateNestedOneWithoutActiveProfileInput
    gamesession?: GamesessionCreateNestedManyWithoutProfileInput
    tournamententry?: TournamententryCreateNestedManyWithoutProfileInput
    transactions?: TransactionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    shopId: string
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutProfileInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    operator?: OperatorUpdateOneRequiredWithoutProfilesNestedInput
    userProfileUseridtouser?: UserUpdateOneRequiredWithoutActiveProfileNestedInput
    gamesession?: GamesessionUpdateManyWithoutProfileNestedInput
    tournamententry?: TournamententryUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: GamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    shopId: string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type GameCreateInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    category?: $Enums.GameCategory
    operator?: OperatorCreateNestedOneWithoutGamesInput
    gamesession?: GamesessionCreateNestedManyWithoutGameInput
    tournamentgame?: TournamentgameCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    operatorId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    category?: $Enums.GameCategory
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutGameInput
    tournamentgame?: TournamentgameUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    operator?: OperatorUpdateOneWithoutGamesNestedInput
    gamesession?: GamesessionUpdateManyWithoutGameNestedInput
    tournamentgame?: TournamentgameUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    gamesession?: GamesessionUncheckedUpdateManyWithoutGameNestedInput
    tournamentgame?: TournamentgameUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    operatorId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    category?: $Enums.GameCategory
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
  }

  export type OperatorgameCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: number | null
    maxBet?: number | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
  }

  export type OperatorgameUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: number | null
    maxBet?: number | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
  }

  export type OperatorgameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableIntFieldUpdateOperationsInput | number | null
    maxBet?: NullableIntFieldUpdateOperationsInput | number | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type OperatorgameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableIntFieldUpdateOperationsInput | number | null
    maxBet?: NullableIntFieldUpdateOperationsInput | number | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type OperatorgameCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: number | null
    maxBet?: number | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
  }

  export type OperatorgameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableIntFieldUpdateOperationsInput | number | null
    maxBet?: NullableIntFieldUpdateOperationsInput | number | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type OperatorgameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableIntFieldUpdateOperationsInput | number | null
    maxBet?: NullableIntFieldUpdateOperationsInput | number | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    metadata?: string | null
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
    members?: MemberCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    metadata?: string | null
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
    members?: MemberUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    metadata?: string | null
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberCreateInput = {
    id?: string
    role: string
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    organizationId: string
    userId: string
    role: string
    createdAt?: Date | string
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateManyInput = {
    id?: string
    organizationId: string
    userId: string
    role: string
    createdAt?: Date | string
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id?: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutInvitationsInput
    organization: OrganizationCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvitationsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type InvitationCreateManyInput = {
    id?: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorCreateInput = {
    id?: string
    secret: string
    backupCodes: string
    user: UserCreateNestedOneWithoutTwofactorsInput
  }

  export type TwoFactorUncheckedCreateInput = {
    id?: string
    secret: string
    backupCodes: string
    userId: string
  }

  export type TwoFactorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTwofactorsNestedInput
  }

  export type TwoFactorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorCreateManyInput = {
    id?: string
    secret: string
    backupCodes: string
    userId: string
  }

  export type TwoFactorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatmessageCreateInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chatroom?: ChatroomCreateNestedOneWithoutChatmessageInput
    user: UserCreateNestedOneWithoutChatmessageInput
  }

  export type ChatmessageUncheckedCreateInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
    roomId?: string | null
  }

  export type ChatmessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom?: ChatroomUpdateOneWithoutChatmessageNestedInput
    user?: UserUpdateOneRequiredWithoutChatmessageNestedInput
  }

  export type ChatmessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatmessageCreateManyInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
    roomId?: string | null
  }

  export type ChatmessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatmessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatroomCreateInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    chatmessage?: ChatmessageCreateNestedManyWithoutChatroomInput
    gamesession?: GamesessionCreateNestedOneWithoutChatroomInput
  }

  export type ChatroomUncheckedCreateInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gameSessionId?: string | null
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutChatroomInput
  }

  export type ChatroomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatmessage?: ChatmessageUpdateManyWithoutChatroomNestedInput
    gamesession?: GamesessionUpdateOneWithoutChatroomNestedInput
  }

  export type ChatroomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutChatroomNestedInput
  }

  export type ChatroomCreateManyInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gameSessionId?: string | null
  }

  export type ChatroomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatroomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FriendshipCreateInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userFriendshipFriendidtouser: UserCreateNestedOneWithoutFriendshipFriendshipFriendidtouserInput
    userFriendshipUseridtouser: UserCreateNestedOneWithoutFriendshipFriendshipUseridtouserInput
  }

  export type FriendshipUncheckedCreateInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
    friendId: string
  }

  export type FriendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userFriendshipFriendidtouser?: UserUpdateOneRequiredWithoutFriendshipFriendshipFriendidtouserNestedInput
    userFriendshipUseridtouser?: UserUpdateOneRequiredWithoutFriendshipFriendshipUseridtouserNestedInput
  }

  export type FriendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type FriendshipCreateManyInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
    friendId: string
  }

  export type FriendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FriendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type GamesessionCreateInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: ChatroomCreateNestedManyWithoutGamesessionInput
    game: GameCreateNestedOneWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    tournament?: TournamentCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
    VipInfo?: VipInfoCreateNestedOneWithoutGamesessionInput
  }

  export type GamesessionUncheckedCreateInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    vipInfoId?: string | null
    chatroom?: ChatroomUncheckedCreateNestedManyWithoutGamesessionInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type GamesessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: ChatroomUpdateManyWithoutGamesessionNestedInput
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: TournamentUpdateOneWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
    VipInfo?: VipInfoUpdateOneWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    chatroom?: ChatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type GamesessionCreateManyInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    vipInfoId?: string | null
  }

  export type GamesessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GamesessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    title?: string
    description?: string
    url?: string
    type?: string
    bonusCode?: string | null
    bonusTotalInCredits?: number
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number
    isPromo?: boolean | null
    totalDiscountInCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operator?: OperatorCreateNestedOneWithoutProductsInput
    transactions?: TransactionCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    title?: string
    description?: string
    url?: string
    type?: string
    bonusCode?: string | null
    bonusTotalInCredits?: number
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number
    isPromo?: boolean | null
    totalDiscountInCents?: number
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: IntFieldUpdateOperationsInput | number
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: IntFieldUpdateOperationsInput | number
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateOneWithoutProductsNestedInput
    transactions?: TransactionUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: IntFieldUpdateOperationsInput | number
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: IntFieldUpdateOperationsInput | number
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    title?: string
    description?: string
    url?: string
    type?: string
    bonusCode?: string | null
    bonusTotalInCredits?: number
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number
    isPromo?: boolean | null
    totalDiscountInCents?: number
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: IntFieldUpdateOperationsInput | number
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: IntFieldUpdateOperationsInput | number
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: IntFieldUpdateOperationsInput | number
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: IntFieldUpdateOperationsInput | number
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentCreateInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionCreateNestedManyWithoutTournamentInput
    operator: OperatorCreateNestedOneWithoutTournamentsInput
    tournamententry?: TournamententryCreateNestedManyWithoutTournamentInput
    tournamentgame?: TournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: TournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUpdateManyWithoutTournamentNestedInput
    operator?: OperatorUpdateOneRequiredWithoutTournamentsNestedInput
    tournamententry?: TournamententryUpdateManyWithoutTournamentNestedInput
    tournamentgame?: TournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: TournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TournamentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TournamentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TournamententryCreateInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTournamententryInput
    tournament: TournamentCreateNestedOneWithoutTournamententryInput
    user: UserCreateNestedOneWithoutTournamententryInput
  }

  export type TournamententryUncheckedCreateInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    tournamentId: string
    profileId: string
  }

  export type TournamententryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTournamententryNestedInput
    tournament?: TournamentUpdateOneRequiredWithoutTournamententryNestedInput
    user?: UserUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type TournamententryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamententryCreateManyInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    tournamentId: string
    profileId: string
  }

  export type TournamententryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamententryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentgameCreateInput = {
    id?: string
    multiplier?: number
    game: GameCreateNestedOneWithoutTournamentgameInput
    tournament: TournamentCreateNestedOneWithoutTournamentgameInput
  }

  export type TournamentgameUncheckedCreateInput = {
    id?: string
    multiplier?: number
    tournamentId: string
    gameId: string
  }

  export type TournamentgameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutTournamentgameNestedInput
    tournament?: TournamentUpdateOneRequiredWithoutTournamentgameNestedInput
  }

  export type TournamentgameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentgameCreateManyInput = {
    id?: string
    multiplier?: number
    tournamentId: string
    gameId: string
  }

  export type TournamentgameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
  }

  export type TournamentgameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    cashtag?: string | null
    gamesession?: GamesessionCreateNestedOneWithoutTransactionInput
    profile?: ProfileCreateNestedOneWithoutTransactionsInput
    product?: ProductCreateNestedOneWithoutTransactionsInput
    vipInfo?: VipInfoCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId?: string | null
    cashtag?: string | null
    productid?: string | null
    vipInfoId?: string | null
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: GamesessionUpdateOneWithoutTransactionNestedInput
    profile?: ProfileUpdateOneWithoutTransactionsNestedInput
    product?: ProductUpdateOneWithoutTransactionsNestedInput
    vipInfo?: VipInfoUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateManyInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId?: string | null
    cashtag?: string | null
    productid?: string | null
    vipInfoId?: string | null
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserachievementCreateInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    achievement: AchievementCreateNestedOneWithoutUserachievementInput
    user: UserCreateNestedOneWithoutUserachievementInput
  }

  export type UserachievementUncheckedCreateInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
    achievementId: string
  }

  export type UserachievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievement?: AchievementUpdateOneRequiredWithoutUserachievementNestedInput
    user?: UserUpdateOneRequiredWithoutUserachievementNestedInput
  }

  export type UserachievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type UserachievementCreateManyInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
    achievementId: string
  }

  export type UserachievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserachievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type RainBetCreateInput = {
    id?: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
    RainHistory: RainHistoryCreateNestedOneWithoutRainBetInput
    user: UserCreateNestedOneWithoutRainBetInput
  }

  export type RainBetUncheckedCreateInput = {
    id?: string
    rainHistoryId: string
    userId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainBetNestedInput
    user?: UserUpdateOneRequiredWithoutRainBetNestedInput
  }

  export type RainBetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetCreateManyInput = {
    id?: string
    rainHistoryId: string
    userId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainHistoryCreateInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    user: UserCreateNestedOneWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryCreateManyInput = {
    id?: string
    userId: string
    amount: number
    rainType: string
    createdAt?: Date | string
  }

  export type RainHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipCreateInput = {
    id?: string
    tipAmount: number
    tippedAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainTipInput
    user: UserCreateNestedOneWithoutRainTipInput
  }

  export type RainTipUncheckedCreateInput = {
    id?: string
    rainHistoryId: string
    userId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainTipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainTipNestedInput
    user?: UserUpdateOneRequiredWithoutRainTipNestedInput
  }

  export type RainTipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipCreateManyInput = {
    id?: string
    rainHistoryId: string
    userId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainTipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerCreateInput = {
    id?: string
    wonAmount: number
    wonAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainWinnerInput
    user: UserCreateNestedOneWithoutRainWinnerInput
  }

  export type RainWinnerUncheckedCreateInput = {
    id?: string
    rainHistoryId: string
    userId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type RainWinnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainWinnerNestedInput
    user?: UserUpdateOneRequiredWithoutRainWinnerNestedInput
  }

  export type RainWinnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerCreateManyInput = {
    id?: string
    rainHistoryId: string
    userId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type RainWinnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VipInfoCreateInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    gamesession?: GamesessionCreateNestedManyWithoutVipInfoInput
    operator?: OperatorCreateNestedOneWithoutVipInfoInput
    transactions?: TransactionCreateNestedManyWithoutVipInfoInput
    user?: UserCreateNestedOneWithoutVipInfoInput
  }

  export type VipInfoUncheckedCreateInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: string | null
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    operatorId?: string | null
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutVipInfoInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutVipInfoInput
  }

  export type VipInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: GamesessionUpdateManyWithoutVipInfoNestedInput
    operator?: OperatorUpdateOneWithoutVipInfoNestedInput
    transactions?: TransactionUpdateManyWithoutVipInfoNestedInput
    user?: UserUpdateOneWithoutVipInfoNestedInput
  }

  export type VipInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: GamesessionUncheckedUpdateManyWithoutVipInfoNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutVipInfoNestedInput
  }

  export type VipInfoCreateManyInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: string | null
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    operatorId?: string | null
  }

  export type VipInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VipInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventLogCreateInput = {
    id?: bigint | number
    tableName: string
    rowId?: string | null
    operation: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type EventLogUncheckedCreateInput = {
    id?: bigint | number
    tableName: string
    rowId?: string | null
    operation: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type EventLogUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tableName?: StringFieldUpdateOperationsInput | string
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventLogUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tableName?: StringFieldUpdateOperationsInput | string
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventLogCreateManyInput = {
    id?: bigint | number
    tableName: string
    rowId?: string | null
    operation: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
  }

  export type EventLogUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tableName?: StringFieldUpdateOperationsInput | string
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventLogUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tableName?: StringFieldUpdateOperationsInput | string
    rowId?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserachievementListRelationFilter = {
    every?: UserachievementWhereInput
    some?: UserachievementWhereInput
    none?: UserachievementWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserachievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    targetXp?: SortOrder
    reward?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    targetXp?: SortOrder
    reward?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumUserStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableFilter<$PrismaModel> | $Enums.UserStatus | null
  }

  export type OperatorListRelationFilter = {
    every?: OperatorWhereInput
    some?: OperatorWhereInput
    none?: OperatorWhereInput
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type RainBetListRelationFilter = {
    every?: RainBetWhereInput
    some?: RainBetWhereInput
    none?: RainBetWhereInput
  }

  export type RainHistoryListRelationFilter = {
    every?: RainHistoryWhereInput
    some?: RainHistoryWhereInput
    none?: RainHistoryWhereInput
  }

  export type RainTipListRelationFilter = {
    every?: RainTipWhereInput
    some?: RainTipWhereInput
    none?: RainTipWhereInput
  }

  export type RainWinnerListRelationFilter = {
    every?: RainWinnerWhereInput
    some?: RainWinnerWhereInput
    none?: RainWinnerWhereInput
  }

  export type PlatformSessionListRelationFilter = {
    every?: PlatformSessionWhereInput
    some?: PlatformSessionWhereInput
    none?: PlatformSessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ChatmessageListRelationFilter = {
    every?: ChatmessageWhereInput
    some?: ChatmessageWhereInput
    none?: ChatmessageWhereInput
  }

  export type FriendshipListRelationFilter = {
    every?: FriendshipWhereInput
    some?: FriendshipWhereInput
    none?: FriendshipWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type TournamententryListRelationFilter = {
    every?: TournamententryWhereInput
    some?: TournamententryWhereInput
    none?: TournamententryWhereInput
  }

  export type TwoFactorListRelationFilter = {
    every?: TwoFactorWhereInput
    some?: TwoFactorWhereInput
    none?: TwoFactorWhereInput
  }

  export type VipInfoNullableRelationFilter = {
    is?: VipInfoWhereInput | null
    isNot?: VipInfoWhereInput | null
  }

  export type OperatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainBetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainTipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainWinnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatmessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TournamententryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwoFactorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    sbId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    isOnline?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    username?: SortOrder
    displayUsername?: SortOrder
    passwordHash?: SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    isVerified?: SortOrder
    active?: SortOrder
    lastLogin?: SortOrder
    verificationToken?: SortOrder
    avatar?: SortOrder
    activeProfileId?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    cashtag?: SortOrder
    phpId?: SortOrder
    accessToken?: SortOrder
    vipInfoId?: SortOrder
    lastDailySpin?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    totalXp?: SortOrder
    balance?: SortOrder
    phpId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    sbId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    isOnline?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    username?: SortOrder
    displayUsername?: SortOrder
    passwordHash?: SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    isVerified?: SortOrder
    active?: SortOrder
    lastLogin?: SortOrder
    verificationToken?: SortOrder
    avatar?: SortOrder
    activeProfileId?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    cashtag?: SortOrder
    phpId?: SortOrder
    accessToken?: SortOrder
    vipInfoId?: SortOrder
    lastDailySpin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    sbId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    isOnline?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    username?: SortOrder
    displayUsername?: SortOrder
    passwordHash?: SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    isVerified?: SortOrder
    active?: SortOrder
    lastLogin?: SortOrder
    verificationToken?: SortOrder
    avatar?: SortOrder
    activeProfileId?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    cashtag?: SortOrder
    phpId?: SortOrder
    accessToken?: SortOrder
    vipInfoId?: SortOrder
    lastDailySpin?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    totalXp?: SortOrder
    balance?: SortOrder
    phpId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumUserStatusNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
    token?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
    token?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
    token?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type GameListRelationFilter = {
    every?: GameWhereInput
    some?: GameWhereInput
    none?: GameWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type TournamentListRelationFilter = {
    every?: TournamentWhereInput
    some?: TournamentWhereInput
    none?: TournamentWhereInput
  }

  export type VipInfoListRelationFilter = {
    every?: VipInfoWhereInput
    some?: VipInfoWhereInput
    none?: VipInfoWhereInput
  }

  export type GameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TournamentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VipInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperatorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acceptedPayments?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
  }

  export type OperatorAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type OperatorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
  }

  export type OperatorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
  }

  export type OperatorSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type OperatorRelationFilter = {
    is?: OperatorWhereInput
    isNot?: OperatorWhereInput
  }

  export type GamesessionListRelationFilter = {
    every?: GamesessionWhereInput
    some?: GamesessionWhereInput
    none?: GamesessionWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type GamesessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileUserIdShopIdCompoundUniqueInput = {
    userId: string
    shopId: string
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    shopId?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    balance?: SortOrder
    xpEarned?: SortOrder
    phpId?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    shopId?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    shopId?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    balance?: SortOrder
    xpEarned?: SortOrder
    phpId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumGameCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.GameCategory | EnumGameCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGameCategoryFilter<$PrismaModel> | $Enums.GameCategory
  }

  export type OperatorNullableRelationFilter = {
    is?: OperatorWhereInput | null
    isNot?: OperatorWhereInput | null
  }

  export type TournamentgameListRelationFilter = {
    every?: TournamentgameWhereInput
    some?: TournamentgameWhereInput
    none?: TournamentgameWhereInput
  }

  export type TournamentgameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    temperature?: SortOrder
    developer?: SortOrder
    vipLevel?: SortOrder
    isActive?: SortOrder
    device?: SortOrder
    featured?: SortOrder
    gamebank?: SortOrder
    bet?: SortOrder
    denomination?: SortOrder
    categoryTemp?: SortOrder
    originalId?: SortOrder
    bids?: SortOrder
    statIn?: SortOrder
    statOut?: SortOrder
    currentRtp?: SortOrder
    rtpStatIn?: SortOrder
    rtpStatOut?: SortOrder
    standardRtp?: SortOrder
    popularity?: SortOrder
    chanceFirepot1?: SortOrder
    chanceFirepot2?: SortOrder
    chanceFirepot3?: SortOrder
    fireCount1?: SortOrder
    fireCount2?: SortOrder
    fireCount3?: SortOrder
    linesPercentConfigSpin?: SortOrder
    linesPercentConfigSpinBonus?: SortOrder
    linesPercentConfigBonus?: SortOrder
    linesPercentConfigBonusBonus?: SortOrder
    rezerv?: SortOrder
    cask?: SortOrder
    advanced?: SortOrder
    scaleMode?: SortOrder
    slotViewState?: SortOrder
    view?: SortOrder
    categoryId?: SortOrder
    operatorId?: SortOrder
    providerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jackpotGroupId?: SortOrder
    active?: SortOrder
    password?: SortOrder
    category?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    vipLevel?: SortOrder
    device?: SortOrder
    bet?: SortOrder
    denomination?: SortOrder
    categoryTemp?: SortOrder
    originalId?: SortOrder
    bids?: SortOrder
    statIn?: SortOrder
    statOut?: SortOrder
    currentRtp?: SortOrder
    rtpStatIn?: SortOrder
    rtpStatOut?: SortOrder
    standardRtp?: SortOrder
    popularity?: SortOrder
    chanceFirepot1?: SortOrder
    chanceFirepot2?: SortOrder
    chanceFirepot3?: SortOrder
    fireCount1?: SortOrder
    fireCount2?: SortOrder
    fireCount3?: SortOrder
    rezerv?: SortOrder
    cask?: SortOrder
    view?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    temperature?: SortOrder
    developer?: SortOrder
    vipLevel?: SortOrder
    isActive?: SortOrder
    device?: SortOrder
    featured?: SortOrder
    gamebank?: SortOrder
    bet?: SortOrder
    denomination?: SortOrder
    categoryTemp?: SortOrder
    originalId?: SortOrder
    bids?: SortOrder
    statIn?: SortOrder
    statOut?: SortOrder
    currentRtp?: SortOrder
    rtpStatIn?: SortOrder
    rtpStatOut?: SortOrder
    standardRtp?: SortOrder
    popularity?: SortOrder
    chanceFirepot1?: SortOrder
    chanceFirepot2?: SortOrder
    chanceFirepot3?: SortOrder
    fireCount1?: SortOrder
    fireCount2?: SortOrder
    fireCount3?: SortOrder
    linesPercentConfigSpin?: SortOrder
    linesPercentConfigSpinBonus?: SortOrder
    linesPercentConfigBonus?: SortOrder
    linesPercentConfigBonusBonus?: SortOrder
    rezerv?: SortOrder
    cask?: SortOrder
    advanced?: SortOrder
    scaleMode?: SortOrder
    slotViewState?: SortOrder
    view?: SortOrder
    categoryId?: SortOrder
    operatorId?: SortOrder
    providerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jackpotGroupId?: SortOrder
    active?: SortOrder
    password?: SortOrder
    category?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    temperature?: SortOrder
    developer?: SortOrder
    vipLevel?: SortOrder
    isActive?: SortOrder
    device?: SortOrder
    featured?: SortOrder
    gamebank?: SortOrder
    bet?: SortOrder
    denomination?: SortOrder
    categoryTemp?: SortOrder
    originalId?: SortOrder
    bids?: SortOrder
    statIn?: SortOrder
    statOut?: SortOrder
    currentRtp?: SortOrder
    rtpStatIn?: SortOrder
    rtpStatOut?: SortOrder
    standardRtp?: SortOrder
    popularity?: SortOrder
    chanceFirepot1?: SortOrder
    chanceFirepot2?: SortOrder
    chanceFirepot3?: SortOrder
    fireCount1?: SortOrder
    fireCount2?: SortOrder
    fireCount3?: SortOrder
    linesPercentConfigSpin?: SortOrder
    linesPercentConfigSpinBonus?: SortOrder
    linesPercentConfigBonus?: SortOrder
    linesPercentConfigBonusBonus?: SortOrder
    rezerv?: SortOrder
    cask?: SortOrder
    advanced?: SortOrder
    scaleMode?: SortOrder
    slotViewState?: SortOrder
    view?: SortOrder
    categoryId?: SortOrder
    operatorId?: SortOrder
    providerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jackpotGroupId?: SortOrder
    active?: SortOrder
    password?: SortOrder
    category?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    vipLevel?: SortOrder
    device?: SortOrder
    bet?: SortOrder
    denomination?: SortOrder
    categoryTemp?: SortOrder
    originalId?: SortOrder
    bids?: SortOrder
    statIn?: SortOrder
    statOut?: SortOrder
    currentRtp?: SortOrder
    rtpStatIn?: SortOrder
    rtpStatOut?: SortOrder
    standardRtp?: SortOrder
    popularity?: SortOrder
    chanceFirepot1?: SortOrder
    chanceFirepot2?: SortOrder
    chanceFirepot3?: SortOrder
    fireCount1?: SortOrder
    fireCount2?: SortOrder
    fireCount3?: SortOrder
    rezerv?: SortOrder
    cask?: SortOrder
    view?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumGameCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameCategory | EnumGameCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGameCategoryWithAggregatesFilter<$PrismaModel> | $Enums.GameCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameCategoryFilter<$PrismaModel>
    _max?: NestedEnumGameCategoryFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type OperatorgameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type OperatorgameAvgOrderByAggregateInput = {
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
  }

  export type OperatorgameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type OperatorgameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type OperatorgameSumOrderByAggregateInput = {
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
  }

  export type TwoFactorCountOrderByAggregateInput = {
    id?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorMaxOrderByAggregateInput = {
    id?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorMinOrderByAggregateInput = {
    id?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    userId?: SortOrder
  }

  export type EnumChatChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelFilter<$PrismaModel> | $Enums.ChatChannel
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ChatroomNullableRelationFilter = {
    is?: ChatroomWhereInput | null
    isNot?: ChatroomWhereInput | null
  }

  export type ChatmessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type ChatmessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type ChatmessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type EnumChatChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelWithAggregatesFilter<$PrismaModel> | $Enums.ChatChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatChannelFilter<$PrismaModel>
    _max?: NestedEnumChatChannelFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type GamesessionNullableRelationFilter = {
    is?: GamesessionWhereInput | null
    isNot?: GamesessionWhereInput | null
  }

  export type ChatroomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrder
  }

  export type ChatroomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrder
  }

  export type ChatroomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrder
  }

  export type EnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type FriendshipUserIdFriendIdCompoundUniqueInput = {
    userId: string
    friendId: string
  }

  export type FriendshipCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
  }

  export type FriendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
  }

  export type FriendshipMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
  }

  export type EnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type ChatroomListRelationFilter = {
    every?: ChatroomWhereInput
    some?: ChatroomWhereInput
    none?: ChatroomWhereInput
  }

  export type GameRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type TournamentNullableRelationFilter = {
    is?: TournamentWhereInput | null
    isNot?: TournamentWhereInput | null
  }

  export type ChatroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GamesessionCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
    metadata?: SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrder
    active?: SortOrder
    profileId?: SortOrder
    vipInfoId?: SortOrder
  }

  export type GamesessionAvgOrderByAggregateInput = {
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
  }

  export type GamesessionMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrder
    active?: SortOrder
    profileId?: SortOrder
    vipInfoId?: SortOrder
  }

  export type GamesessionMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrder
    active?: SortOrder
    profileId?: SortOrder
    vipInfoId?: SortOrder
  }

  export type GamesessionSumOrderByAggregateInput = {
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    bonusCode?: SortOrder
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    isPromo?: SortOrder
    totalDiscountInCents?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    totalDiscountInCents?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    bonusCode?: SortOrder
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    isPromo?: SortOrder
    totalDiscountInCents?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    bonusCode?: SortOrder
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    isPromo?: SortOrder
    totalDiscountInCents?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    totalDiscountInCents?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type TournamentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
    leaderboard?: SortOrder
  }

  export type TournamentAvgOrderByAggregateInput = {
    entryFee?: SortOrder
    prizePool?: SortOrder
  }

  export type TournamentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type TournamentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type TournamentSumOrderByAggregateInput = {
    entryFee?: SortOrder
    prizePool?: SortOrder
  }

  export type TournamentRelationFilter = {
    is?: TournamentWhereInput
    isNot?: TournamentWhereInput
  }

  export type TournamententryUserIdTournamentIdCompoundUniqueInput = {
    userId: string
    tournamentId: string
  }

  export type TournamententryCountOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
  }

  export type TournamententryAvgOrderByAggregateInput = {
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
  }

  export type TournamententryMaxOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
  }

  export type TournamententryMinOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
  }

  export type TournamententrySumOrderByAggregateInput = {
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
  }

  export type TournamentgameTournamentIdGameIdCompoundUniqueInput = {
    tournamentId: string
    gameId: string
  }

  export type TournamentgameCountOrderByAggregateInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
  }

  export type TournamentgameAvgOrderByAggregateInput = {
    multiplier?: SortOrder
  }

  export type TournamentgameMaxOrderByAggregateInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
  }

  export type TournamentgameMinOrderByAggregateInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
  }

  export type TournamentgameSumOrderByAggregateInput = {
    multiplier?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    amountCredits?: SortOrder
    buyerCashtag?: SortOrder
    buyerUserId?: SortOrder
    username?: SortOrder
    cashiername?: SortOrder
    cashierAvatar?: SortOrder
    cashierId?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrder
    paymentDetails?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    gameSessionId?: SortOrder
    profileId?: SortOrder
    cashtag?: SortOrder
    productid?: SortOrder
    vipInfoId?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    amountCredits?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    amountCredits?: SortOrder
    buyerCashtag?: SortOrder
    buyerUserId?: SortOrder
    username?: SortOrder
    cashiername?: SortOrder
    cashierAvatar?: SortOrder
    cashierId?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    gameSessionId?: SortOrder
    profileId?: SortOrder
    cashtag?: SortOrder
    productid?: SortOrder
    vipInfoId?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    amountCredits?: SortOrder
    buyerCashtag?: SortOrder
    buyerUserId?: SortOrder
    username?: SortOrder
    cashiername?: SortOrder
    cashierAvatar?: SortOrder
    cashierId?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    gameSessionId?: SortOrder
    profileId?: SortOrder
    cashtag?: SortOrder
    productid?: SortOrder
    vipInfoId?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    amountCredits?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type AchievementRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type UserachievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type UserachievementCountOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type UserachievementAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserachievementMaxOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type UserachievementMinOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type UserachievementSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type RainHistoryRelationFilter = {
    is?: RainHistoryWhereInput
    isNot?: RainHistoryWhereInput
  }

  export type RainBetCountOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrder
    settledAt?: SortOrder
  }

  export type RainBetAvgOrderByAggregateInput = {
    betAmount?: SortOrder
    odds?: SortOrder
  }

  export type RainBetMaxOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrder
    settledAt?: SortOrder
  }

  export type RainBetMinOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrder
    settledAt?: SortOrder
  }

  export type RainBetSumOrderByAggregateInput = {
    betAmount?: SortOrder
    odds?: SortOrder
  }

  export type RainHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
  }

  export type RainHistoryAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RainHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
  }

  export type RainHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
  }

  export type RainHistorySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RainTipCountOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
  }

  export type RainTipAvgOrderByAggregateInput = {
    tipAmount?: SortOrder
  }

  export type RainTipMaxOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
  }

  export type RainTipMinOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
  }

  export type RainTipSumOrderByAggregateInput = {
    tipAmount?: SortOrder
  }

  export type RainWinnerCountOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
  }

  export type RainWinnerAvgOrderByAggregateInput = {
    wonAmount?: SortOrder
  }

  export type RainWinnerMaxOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
  }

  export type RainWinnerMinOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
  }

  export type RainWinnerSumOrderByAggregateInput = {
    wonAmount?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type VipInfoCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    rank_name?: SortOrder
    icon?: SortOrder
    exp_switch_type?: SortOrder
    now_deposit_exp?: SortOrder
    level_deposit_exp?: SortOrder
    now_bet_exp?: SortOrder
    level_bet_exp?: SortOrder
    telegram?: SortOrder
    is_protection?: SortOrder
    protection_deposit_exp?: SortOrder
    protection_deposit_amount?: SortOrder
    protection_bet_exp?: SortOrder
    protection_bet_amount?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    cycle_award_switch?: SortOrder
    level_award_switch?: SortOrder
    signin_award_switch?: SortOrder
    bet_award_switch?: SortOrder
    withdrawal_award_switch?: SortOrder
    unprotection_deposit_exp?: SortOrder
    unprotection_deposit_amount?: SortOrder
    unprotection_bet_exp?: SortOrder
    unprotection_bet_amount?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
    main_currency?: SortOrder
    can_receive_level_award?: SortOrder
    can_receive_rank_award?: SortOrder
    can_receive_day_award?: SortOrder
    can_receive_week_award?: SortOrder
    can_receive_month_award?: SortOrder
    can_receive_signin_award?: SortOrder
    can_receive_bet_award?: SortOrder
    can_receive_withdrawal_award?: SortOrder
    userid?: SortOrder
    free_spin_times?: SortOrder
    week_gift?: SortOrder
    month_gift?: SortOrder
    upgrade_gift?: SortOrder
    now_cash_back?: SortOrder
    yesterday_cash_back?: SortOrder
    history_cash_back?: SortOrder
    operatorId?: SortOrder
  }

  export type VipInfoAvgOrderByAggregateInput = {
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    exp_switch_type?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
    free_spin_times?: SortOrder
    week_gift?: SortOrder
    month_gift?: SortOrder
    upgrade_gift?: SortOrder
    now_cash_back?: SortOrder
    yesterday_cash_back?: SortOrder
    history_cash_back?: SortOrder
  }

  export type VipInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    rank_name?: SortOrder
    icon?: SortOrder
    exp_switch_type?: SortOrder
    now_deposit_exp?: SortOrder
    level_deposit_exp?: SortOrder
    now_bet_exp?: SortOrder
    level_bet_exp?: SortOrder
    telegram?: SortOrder
    is_protection?: SortOrder
    protection_deposit_exp?: SortOrder
    protection_deposit_amount?: SortOrder
    protection_bet_exp?: SortOrder
    protection_bet_amount?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    cycle_award_switch?: SortOrder
    level_award_switch?: SortOrder
    signin_award_switch?: SortOrder
    bet_award_switch?: SortOrder
    withdrawal_award_switch?: SortOrder
    unprotection_deposit_exp?: SortOrder
    unprotection_deposit_amount?: SortOrder
    unprotection_bet_exp?: SortOrder
    unprotection_bet_amount?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
    main_currency?: SortOrder
    can_receive_level_award?: SortOrder
    can_receive_rank_award?: SortOrder
    can_receive_day_award?: SortOrder
    can_receive_week_award?: SortOrder
    can_receive_month_award?: SortOrder
    can_receive_signin_award?: SortOrder
    can_receive_bet_award?: SortOrder
    can_receive_withdrawal_award?: SortOrder
    userid?: SortOrder
    free_spin_times?: SortOrder
    week_gift?: SortOrder
    month_gift?: SortOrder
    upgrade_gift?: SortOrder
    now_cash_back?: SortOrder
    yesterday_cash_back?: SortOrder
    history_cash_back?: SortOrder
    operatorId?: SortOrder
  }

  export type VipInfoMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    rank_name?: SortOrder
    icon?: SortOrder
    exp_switch_type?: SortOrder
    now_deposit_exp?: SortOrder
    level_deposit_exp?: SortOrder
    now_bet_exp?: SortOrder
    level_bet_exp?: SortOrder
    telegram?: SortOrder
    is_protection?: SortOrder
    protection_deposit_exp?: SortOrder
    protection_deposit_amount?: SortOrder
    protection_bet_exp?: SortOrder
    protection_bet_amount?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    cycle_award_switch?: SortOrder
    level_award_switch?: SortOrder
    signin_award_switch?: SortOrder
    bet_award_switch?: SortOrder
    withdrawal_award_switch?: SortOrder
    unprotection_deposit_exp?: SortOrder
    unprotection_deposit_amount?: SortOrder
    unprotection_bet_exp?: SortOrder
    unprotection_bet_amount?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
    main_currency?: SortOrder
    can_receive_level_award?: SortOrder
    can_receive_rank_award?: SortOrder
    can_receive_day_award?: SortOrder
    can_receive_week_award?: SortOrder
    can_receive_month_award?: SortOrder
    can_receive_signin_award?: SortOrder
    can_receive_bet_award?: SortOrder
    can_receive_withdrawal_award?: SortOrder
    userid?: SortOrder
    free_spin_times?: SortOrder
    week_gift?: SortOrder
    month_gift?: SortOrder
    upgrade_gift?: SortOrder
    now_cash_back?: SortOrder
    yesterday_cash_back?: SortOrder
    history_cash_back?: SortOrder
    operatorId?: SortOrder
  }

  export type VipInfoSumOrderByAggregateInput = {
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    exp_switch_type?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
    free_spin_times?: SortOrder
    week_gift?: SortOrder
    month_gift?: SortOrder
    upgrade_gift?: SortOrder
    now_cash_back?: SortOrder
    yesterday_cash_back?: SortOrder
    history_cash_back?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EventLogCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    rowId?: SortOrder
    operation?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
  }

  export type EventLogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EventLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    rowId?: SortOrder
    operation?: SortOrder
    createdAt?: SortOrder
  }

  export type EventLogMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    rowId?: SortOrder
    operation?: SortOrder
    createdAt?: SortOrder
  }

  export type EventLogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UserachievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserachievementCreateWithoutAchievementInput, UserachievementUncheckedCreateWithoutAchievementInput> | UserachievementCreateWithoutAchievementInput[] | UserachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserachievementCreateOrConnectWithoutAchievementInput | UserachievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserachievementCreateManyAchievementInputEnvelope
    connect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
  }

  export type UserachievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserachievementCreateWithoutAchievementInput, UserachievementUncheckedCreateWithoutAchievementInput> | UserachievementCreateWithoutAchievementInput[] | UserachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserachievementCreateOrConnectWithoutAchievementInput | UserachievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserachievementCreateManyAchievementInputEnvelope
    connect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserachievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserachievementCreateWithoutAchievementInput, UserachievementUncheckedCreateWithoutAchievementInput> | UserachievementCreateWithoutAchievementInput[] | UserachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserachievementCreateOrConnectWithoutAchievementInput | UserachievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserachievementUpsertWithWhereUniqueWithoutAchievementInput | UserachievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserachievementCreateManyAchievementInputEnvelope
    set?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    disconnect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    delete?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    connect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    update?: UserachievementUpdateWithWhereUniqueWithoutAchievementInput | UserachievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserachievementUpdateManyWithWhereWithoutAchievementInput | UserachievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserachievementScalarWhereInput | UserachievementScalarWhereInput[]
  }

  export type UserachievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserachievementCreateWithoutAchievementInput, UserachievementUncheckedCreateWithoutAchievementInput> | UserachievementCreateWithoutAchievementInput[] | UserachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserachievementCreateOrConnectWithoutAchievementInput | UserachievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserachievementUpsertWithWhereUniqueWithoutAchievementInput | UserachievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserachievementCreateManyAchievementInputEnvelope
    set?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    disconnect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    delete?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    connect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    update?: UserachievementUpdateWithWhereUniqueWithoutAchievementInput | UserachievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserachievementUpdateManyWithWhereWithoutAchievementInput | UserachievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserachievementScalarWhereInput | UserachievementScalarWhereInput[]
  }

  export type OperatorCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput> | OperatorCreateWithoutOwnerInput[] | OperatorUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutOwnerInput | OperatorCreateOrConnectWithoutOwnerInput[]
    createMany?: OperatorCreateManyOwnerInputEnvelope
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutUserProfileUseridtouserInput = {
    create?: XOR<ProfileCreateWithoutUserProfileUseridtouserInput, ProfileUncheckedCreateWithoutUserProfileUseridtouserInput> | ProfileCreateWithoutUserProfileUseridtouserInput[] | ProfileUncheckedCreateWithoutUserProfileUseridtouserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserProfileUseridtouserInput | ProfileCreateOrConnectWithoutUserProfileUseridtouserInput[]
    createMany?: ProfileCreateManyUserProfileUseridtouserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type RainBetCreateNestedManyWithoutUserInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type RainHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
  }

  export type RainTipCreateNestedManyWithoutUserInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerCreateNestedManyWithoutUserInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type PlatformSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<PlatformSessionCreateWithoutUserInput, PlatformSessionUncheckedCreateWithoutUserInput> | PlatformSessionCreateWithoutUserInput[] | PlatformSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlatformSessionCreateOrConnectWithoutUserInput | PlatformSessionCreateOrConnectWithoutUserInput[]
    createMany?: PlatformSessionCreateManyUserInputEnvelope
    connect?: PlatformSessionWhereUniqueInput | PlatformSessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ChatmessageCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatmessageCreateWithoutUserInput, ChatmessageUncheckedCreateWithoutUserInput> | ChatmessageCreateWithoutUserInput[] | ChatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatmessageCreateOrConnectWithoutUserInput | ChatmessageCreateOrConnectWithoutUserInput[]
    createMany?: ChatmessageCreateManyUserInputEnvelope
    connect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput = {
    create?: XOR<FriendshipCreateWithoutUserFriendshipFriendidtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput> | FriendshipCreateWithoutUserFriendshipFriendidtouserInput[] | FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserFriendshipFriendidtouserInput | FriendshipCreateOrConnectWithoutUserFriendshipFriendidtouserInput[]
    createMany?: FriendshipCreateManyUserFriendshipFriendidtouserInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput = {
    create?: XOR<FriendshipCreateWithoutUserFriendshipUseridtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput> | FriendshipCreateWithoutUserFriendshipUseridtouserInput[] | FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserFriendshipUseridtouserInput | FriendshipCreateOrConnectWithoutUserFriendshipUseridtouserInput[]
    createMany?: FriendshipCreateManyUserFriendshipUseridtouserInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutUserInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TournamententryCreateNestedManyWithoutUserInput = {
    create?: XOR<TournamententryCreateWithoutUserInput, TournamententryUncheckedCreateWithoutUserInput> | TournamententryCreateWithoutUserInput[] | TournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutUserInput | TournamententryCreateOrConnectWithoutUserInput[]
    createMany?: TournamententryCreateManyUserInputEnvelope
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
  }

  export type TwoFactorCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
  }

  export type UserachievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserachievementCreateWithoutUserInput, UserachievementUncheckedCreateWithoutUserInput> | UserachievementCreateWithoutUserInput[] | UserachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserachievementCreateOrConnectWithoutUserInput | UserachievementCreateOrConnectWithoutUserInput[]
    createMany?: UserachievementCreateManyUserInputEnvelope
    connect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
  }

  export type VipInfoCreateNestedOneWithoutUserInput = {
    create?: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: VipInfoCreateOrConnectWithoutUserInput
    connect?: VipInfoWhereUniqueInput
  }

  export type OperatorUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput> | OperatorCreateWithoutOwnerInput[] | OperatorUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutOwnerInput | OperatorCreateOrConnectWithoutOwnerInput[]
    createMany?: OperatorCreateManyOwnerInputEnvelope
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput = {
    create?: XOR<ProfileCreateWithoutUserProfileUseridtouserInput, ProfileUncheckedCreateWithoutUserProfileUseridtouserInput> | ProfileCreateWithoutUserProfileUseridtouserInput[] | ProfileUncheckedCreateWithoutUserProfileUseridtouserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserProfileUseridtouserInput | ProfileCreateOrConnectWithoutUserProfileUseridtouserInput[]
    createMany?: ProfileCreateManyUserProfileUseridtouserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type RainBetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type RainHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
  }

  export type RainTipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type PlatformSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlatformSessionCreateWithoutUserInput, PlatformSessionUncheckedCreateWithoutUserInput> | PlatformSessionCreateWithoutUserInput[] | PlatformSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlatformSessionCreateOrConnectWithoutUserInput | PlatformSessionCreateOrConnectWithoutUserInput[]
    createMany?: PlatformSessionCreateManyUserInputEnvelope
    connect?: PlatformSessionWhereUniqueInput | PlatformSessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ChatmessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatmessageCreateWithoutUserInput, ChatmessageUncheckedCreateWithoutUserInput> | ChatmessageCreateWithoutUserInput[] | ChatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatmessageCreateOrConnectWithoutUserInput | ChatmessageCreateOrConnectWithoutUserInput[]
    createMany?: ChatmessageCreateManyUserInputEnvelope
    connect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput = {
    create?: XOR<FriendshipCreateWithoutUserFriendshipFriendidtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput> | FriendshipCreateWithoutUserFriendshipFriendidtouserInput[] | FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserFriendshipFriendidtouserInput | FriendshipCreateOrConnectWithoutUserFriendshipFriendidtouserInput[]
    createMany?: FriendshipCreateManyUserFriendshipFriendidtouserInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput = {
    create?: XOR<FriendshipCreateWithoutUserFriendshipUseridtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput> | FriendshipCreateWithoutUserFriendshipUseridtouserInput[] | FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserFriendshipUseridtouserInput | FriendshipCreateOrConnectWithoutUserFriendshipUseridtouserInput[]
    createMany?: FriendshipCreateManyUserFriendshipUseridtouserInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TournamententryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TournamententryCreateWithoutUserInput, TournamententryUncheckedCreateWithoutUserInput> | TournamententryCreateWithoutUserInput[] | TournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutUserInput | TournamententryCreateOrConnectWithoutUserInput[]
    createMany?: TournamententryCreateManyUserInputEnvelope
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
  }

  export type TwoFactorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
  }

  export type UserachievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserachievementCreateWithoutUserInput, UserachievementUncheckedCreateWithoutUserInput> | UserachievementCreateWithoutUserInput[] | UserachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserachievementCreateOrConnectWithoutUserInput | UserachievementCreateOrConnectWithoutUserInput[]
    createMany?: UserachievementCreateManyUserInputEnvelope
    connect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
  }

  export type VipInfoUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: VipInfoCreateOrConnectWithoutUserInput
    connect?: VipInfoWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableEnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus | null
  }

  export type OperatorUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput> | OperatorCreateWithoutOwnerInput[] | OperatorUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutOwnerInput | OperatorCreateOrConnectWithoutOwnerInput[]
    upsert?: OperatorUpsertWithWhereUniqueWithoutOwnerInput | OperatorUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OperatorCreateManyOwnerInputEnvelope
    set?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    disconnect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    delete?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    update?: OperatorUpdateWithWhereUniqueWithoutOwnerInput | OperatorUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OperatorUpdateManyWithWhereWithoutOwnerInput | OperatorUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserProfileUseridtouserInput, ProfileUncheckedCreateWithoutUserProfileUseridtouserInput> | ProfileCreateWithoutUserProfileUseridtouserInput[] | ProfileUncheckedCreateWithoutUserProfileUseridtouserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserProfileUseridtouserInput | ProfileCreateOrConnectWithoutUserProfileUseridtouserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUserProfileUseridtouserInput | ProfileUpsertWithWhereUniqueWithoutUserProfileUseridtouserInput[]
    createMany?: ProfileCreateManyUserProfileUseridtouserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUserProfileUseridtouserInput | ProfileUpdateWithWhereUniqueWithoutUserProfileUseridtouserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUserProfileUseridtouserInput | ProfileUpdateManyWithWhereWithoutUserProfileUseridtouserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type RainBetUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutUserInput | RainBetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutUserInput | RainBetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutUserInput | RainBetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type RainHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    upsert?: RainHistoryUpsertWithWhereUniqueWithoutUserInput | RainHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    set?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    disconnect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    delete?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    update?: RainHistoryUpdateWithWhereUniqueWithoutUserInput | RainHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainHistoryUpdateManyWithWhereWithoutUserInput | RainHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
  }

  export type RainTipUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutUserInput | RainTipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutUserInput | RainTipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutUserInput | RainTipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutUserInput | RainWinnerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutUserInput | RainWinnerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutUserInput | RainWinnerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type PlatformSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlatformSessionCreateWithoutUserInput, PlatformSessionUncheckedCreateWithoutUserInput> | PlatformSessionCreateWithoutUserInput[] | PlatformSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlatformSessionCreateOrConnectWithoutUserInput | PlatformSessionCreateOrConnectWithoutUserInput[]
    upsert?: PlatformSessionUpsertWithWhereUniqueWithoutUserInput | PlatformSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlatformSessionCreateManyUserInputEnvelope
    set?: PlatformSessionWhereUniqueInput | PlatformSessionWhereUniqueInput[]
    disconnect?: PlatformSessionWhereUniqueInput | PlatformSessionWhereUniqueInput[]
    delete?: PlatformSessionWhereUniqueInput | PlatformSessionWhereUniqueInput[]
    connect?: PlatformSessionWhereUniqueInput | PlatformSessionWhereUniqueInput[]
    update?: PlatformSessionUpdateWithWhereUniqueWithoutUserInput | PlatformSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlatformSessionUpdateManyWithWhereWithoutUserInput | PlatformSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlatformSessionScalarWhereInput | PlatformSessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ChatmessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatmessageCreateWithoutUserInput, ChatmessageUncheckedCreateWithoutUserInput> | ChatmessageCreateWithoutUserInput[] | ChatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatmessageCreateOrConnectWithoutUserInput | ChatmessageCreateOrConnectWithoutUserInput[]
    upsert?: ChatmessageUpsertWithWhereUniqueWithoutUserInput | ChatmessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatmessageCreateManyUserInputEnvelope
    set?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    disconnect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    delete?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    connect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    update?: ChatmessageUpdateWithWhereUniqueWithoutUserInput | ChatmessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatmessageUpdateManyWithWhereWithoutUserInput | ChatmessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatmessageScalarWhereInput | ChatmessageScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserFriendshipFriendidtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput> | FriendshipCreateWithoutUserFriendshipFriendidtouserInput[] | FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserFriendshipFriendidtouserInput | FriendshipCreateOrConnectWithoutUserFriendshipFriendidtouserInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserFriendshipFriendidtouserInput | FriendshipUpsertWithWhereUniqueWithoutUserFriendshipFriendidtouserInput[]
    createMany?: FriendshipCreateManyUserFriendshipFriendidtouserInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserFriendshipFriendidtouserInput | FriendshipUpdateWithWhereUniqueWithoutUserFriendshipFriendidtouserInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserFriendshipFriendidtouserInput | FriendshipUpdateManyWithWhereWithoutUserFriendshipFriendidtouserInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserFriendshipUseridtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput> | FriendshipCreateWithoutUserFriendshipUseridtouserInput[] | FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserFriendshipUseridtouserInput | FriendshipCreateOrConnectWithoutUserFriendshipUseridtouserInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserFriendshipUseridtouserInput | FriendshipUpsertWithWhereUniqueWithoutUserFriendshipUseridtouserInput[]
    createMany?: FriendshipCreateManyUserFriendshipUseridtouserInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserFriendshipUseridtouserInput | FriendshipUpdateWithWhereUniqueWithoutUserFriendshipUseridtouserInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserFriendshipUseridtouserInput | FriendshipUpdateManyWithWhereWithoutUserFriendshipUseridtouserInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutUserInput | InvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutUserInput | InvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutUserInput | InvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TournamententryUpdateManyWithoutUserNestedInput = {
    create?: XOR<TournamententryCreateWithoutUserInput, TournamententryUncheckedCreateWithoutUserInput> | TournamententryCreateWithoutUserInput[] | TournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutUserInput | TournamententryCreateOrConnectWithoutUserInput[]
    upsert?: TournamententryUpsertWithWhereUniqueWithoutUserInput | TournamententryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TournamententryCreateManyUserInputEnvelope
    set?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    disconnect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    delete?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    update?: TournamententryUpdateWithWhereUniqueWithoutUserInput | TournamententryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TournamententryUpdateManyWithWhereWithoutUserInput | TournamententryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TournamententryScalarWhereInput | TournamententryScalarWhereInput[]
  }

  export type TwoFactorUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorUpsertWithWhereUniqueWithoutUserInput | TwoFactorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    set?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    disconnect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    delete?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    update?: TwoFactorUpdateWithWhereUniqueWithoutUserInput | TwoFactorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorUpdateManyWithWhereWithoutUserInput | TwoFactorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
  }

  export type UserachievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserachievementCreateWithoutUserInput, UserachievementUncheckedCreateWithoutUserInput> | UserachievementCreateWithoutUserInput[] | UserachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserachievementCreateOrConnectWithoutUserInput | UserachievementCreateOrConnectWithoutUserInput[]
    upsert?: UserachievementUpsertWithWhereUniqueWithoutUserInput | UserachievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserachievementCreateManyUserInputEnvelope
    set?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    disconnect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    delete?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    connect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    update?: UserachievementUpdateWithWhereUniqueWithoutUserInput | UserachievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserachievementUpdateManyWithWhereWithoutUserInput | UserachievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserachievementScalarWhereInput | UserachievementScalarWhereInput[]
  }

  export type VipInfoUpdateOneWithoutUserNestedInput = {
    create?: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: VipInfoCreateOrConnectWithoutUserInput
    upsert?: VipInfoUpsertWithoutUserInput
    disconnect?: VipInfoWhereInput | boolean
    delete?: VipInfoWhereInput | boolean
    connect?: VipInfoWhereUniqueInput
    update?: XOR<XOR<VipInfoUpdateToOneWithWhereWithoutUserInput, VipInfoUpdateWithoutUserInput>, VipInfoUncheckedUpdateWithoutUserInput>
  }

  export type OperatorUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput> | OperatorCreateWithoutOwnerInput[] | OperatorUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutOwnerInput | OperatorCreateOrConnectWithoutOwnerInput[]
    upsert?: OperatorUpsertWithWhereUniqueWithoutOwnerInput | OperatorUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OperatorCreateManyOwnerInputEnvelope
    set?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    disconnect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    delete?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    update?: OperatorUpdateWithWhereUniqueWithoutOwnerInput | OperatorUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OperatorUpdateManyWithWhereWithoutOwnerInput | OperatorUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserProfileUseridtouserInput, ProfileUncheckedCreateWithoutUserProfileUseridtouserInput> | ProfileCreateWithoutUserProfileUseridtouserInput[] | ProfileUncheckedCreateWithoutUserProfileUseridtouserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserProfileUseridtouserInput | ProfileCreateOrConnectWithoutUserProfileUseridtouserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUserProfileUseridtouserInput | ProfileUpsertWithWhereUniqueWithoutUserProfileUseridtouserInput[]
    createMany?: ProfileCreateManyUserProfileUseridtouserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUserProfileUseridtouserInput | ProfileUpdateWithWhereUniqueWithoutUserProfileUseridtouserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUserProfileUseridtouserInput | ProfileUpdateManyWithWhereWithoutUserProfileUseridtouserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type RainBetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutUserInput | RainBetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutUserInput | RainBetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutUserInput | RainBetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type RainHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    upsert?: RainHistoryUpsertWithWhereUniqueWithoutUserInput | RainHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    set?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    disconnect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    delete?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    update?: RainHistoryUpdateWithWhereUniqueWithoutUserInput | RainHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainHistoryUpdateManyWithWhereWithoutUserInput | RainHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
  }

  export type RainTipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutUserInput | RainTipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutUserInput | RainTipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutUserInput | RainTipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutUserInput | RainWinnerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutUserInput | RainWinnerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutUserInput | RainWinnerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type PlatformSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlatformSessionCreateWithoutUserInput, PlatformSessionUncheckedCreateWithoutUserInput> | PlatformSessionCreateWithoutUserInput[] | PlatformSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlatformSessionCreateOrConnectWithoutUserInput | PlatformSessionCreateOrConnectWithoutUserInput[]
    upsert?: PlatformSessionUpsertWithWhereUniqueWithoutUserInput | PlatformSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlatformSessionCreateManyUserInputEnvelope
    set?: PlatformSessionWhereUniqueInput | PlatformSessionWhereUniqueInput[]
    disconnect?: PlatformSessionWhereUniqueInput | PlatformSessionWhereUniqueInput[]
    delete?: PlatformSessionWhereUniqueInput | PlatformSessionWhereUniqueInput[]
    connect?: PlatformSessionWhereUniqueInput | PlatformSessionWhereUniqueInput[]
    update?: PlatformSessionUpdateWithWhereUniqueWithoutUserInput | PlatformSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlatformSessionUpdateManyWithWhereWithoutUserInput | PlatformSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlatformSessionScalarWhereInput | PlatformSessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ChatmessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatmessageCreateWithoutUserInput, ChatmessageUncheckedCreateWithoutUserInput> | ChatmessageCreateWithoutUserInput[] | ChatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatmessageCreateOrConnectWithoutUserInput | ChatmessageCreateOrConnectWithoutUserInput[]
    upsert?: ChatmessageUpsertWithWhereUniqueWithoutUserInput | ChatmessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatmessageCreateManyUserInputEnvelope
    set?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    disconnect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    delete?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    connect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    update?: ChatmessageUpdateWithWhereUniqueWithoutUserInput | ChatmessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatmessageUpdateManyWithWhereWithoutUserInput | ChatmessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatmessageScalarWhereInput | ChatmessageScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserFriendshipFriendidtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput> | FriendshipCreateWithoutUserFriendshipFriendidtouserInput[] | FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserFriendshipFriendidtouserInput | FriendshipCreateOrConnectWithoutUserFriendshipFriendidtouserInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserFriendshipFriendidtouserInput | FriendshipUpsertWithWhereUniqueWithoutUserFriendshipFriendidtouserInput[]
    createMany?: FriendshipCreateManyUserFriendshipFriendidtouserInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserFriendshipFriendidtouserInput | FriendshipUpdateWithWhereUniqueWithoutUserFriendshipFriendidtouserInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserFriendshipFriendidtouserInput | FriendshipUpdateManyWithWhereWithoutUserFriendshipFriendidtouserInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserFriendshipUseridtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput> | FriendshipCreateWithoutUserFriendshipUseridtouserInput[] | FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserFriendshipUseridtouserInput | FriendshipCreateOrConnectWithoutUserFriendshipUseridtouserInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserFriendshipUseridtouserInput | FriendshipUpsertWithWhereUniqueWithoutUserFriendshipUseridtouserInput[]
    createMany?: FriendshipCreateManyUserFriendshipUseridtouserInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserFriendshipUseridtouserInput | FriendshipUpdateWithWhereUniqueWithoutUserFriendshipUseridtouserInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserFriendshipUseridtouserInput | FriendshipUpdateManyWithWhereWithoutUserFriendshipUseridtouserInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutUserInput | InvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutUserInput | InvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutUserInput | InvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TournamententryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TournamententryCreateWithoutUserInput, TournamententryUncheckedCreateWithoutUserInput> | TournamententryCreateWithoutUserInput[] | TournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutUserInput | TournamententryCreateOrConnectWithoutUserInput[]
    upsert?: TournamententryUpsertWithWhereUniqueWithoutUserInput | TournamententryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TournamententryCreateManyUserInputEnvelope
    set?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    disconnect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    delete?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    update?: TournamententryUpdateWithWhereUniqueWithoutUserInput | TournamententryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TournamententryUpdateManyWithWhereWithoutUserInput | TournamententryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TournamententryScalarWhereInput | TournamententryScalarWhereInput[]
  }

  export type TwoFactorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorUpsertWithWhereUniqueWithoutUserInput | TwoFactorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    set?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    disconnect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    delete?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    update?: TwoFactorUpdateWithWhereUniqueWithoutUserInput | TwoFactorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorUpdateManyWithWhereWithoutUserInput | TwoFactorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
  }

  export type UserachievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserachievementCreateWithoutUserInput, UserachievementUncheckedCreateWithoutUserInput> | UserachievementCreateWithoutUserInput[] | UserachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserachievementCreateOrConnectWithoutUserInput | UserachievementCreateOrConnectWithoutUserInput[]
    upsert?: UserachievementUpsertWithWhereUniqueWithoutUserInput | UserachievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserachievementCreateManyUserInputEnvelope
    set?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    disconnect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    delete?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    connect?: UserachievementWhereUniqueInput | UserachievementWhereUniqueInput[]
    update?: UserachievementUpdateWithWhereUniqueWithoutUserInput | UserachievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserachievementUpdateManyWithWhereWithoutUserInput | UserachievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserachievementScalarWhereInput | UserachievementScalarWhereInput[]
  }

  export type VipInfoUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput>
    connectOrCreate?: VipInfoCreateOrConnectWithoutUserInput
    upsert?: VipInfoUpsertWithoutUserInput
    disconnect?: VipInfoWhereInput | boolean
    delete?: VipInfoWhereInput | boolean
    connect?: VipInfoWhereUniqueInput
    update?: XOR<XOR<VipInfoUpdateToOneWithWhereWithoutUserInput, VipInfoUpdateWithoutUserInput>, VipInfoUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type OperatorCreateacceptedPaymentsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutOperatorInput = {
    create?: XOR<UserCreateWithoutOperatorInput, UserUncheckedCreateWithoutOperatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutOperatorInput
    connect?: UserWhereUniqueInput
  }

  export type ProfileCreateNestedManyWithoutOperatorInput = {
    create?: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput> | ProfileCreateWithoutOperatorInput[] | ProfileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutOperatorInput | ProfileCreateOrConnectWithoutOperatorInput[]
    createMany?: ProfileCreateManyOperatorInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutOperatorInput = {
    create?: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput> | GameCreateWithoutOperatorInput[] | GameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: GameCreateOrConnectWithoutOperatorInput | GameCreateOrConnectWithoutOperatorInput[]
    createMany?: GameCreateManyOperatorInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutOperatorInput = {
    create?: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput> | ProductCreateWithoutOperatorInput[] | ProductUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOperatorInput | ProductCreateOrConnectWithoutOperatorInput[]
    createMany?: ProductCreateManyOperatorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type TournamentCreateNestedManyWithoutOperatorInput = {
    create?: XOR<TournamentCreateWithoutOperatorInput, TournamentUncheckedCreateWithoutOperatorInput> | TournamentCreateWithoutOperatorInput[] | TournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutOperatorInput | TournamentCreateOrConnectWithoutOperatorInput[]
    createMany?: TournamentCreateManyOperatorInputEnvelope
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
  }

  export type VipInfoCreateNestedManyWithoutOperatorInput = {
    create?: XOR<VipInfoCreateWithoutOperatorInput, VipInfoUncheckedCreateWithoutOperatorInput> | VipInfoCreateWithoutOperatorInput[] | VipInfoUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: VipInfoCreateOrConnectWithoutOperatorInput | VipInfoCreateOrConnectWithoutOperatorInput[]
    createMany?: VipInfoCreateManyOperatorInputEnvelope
    connect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput> | ProfileCreateWithoutOperatorInput[] | ProfileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutOperatorInput | ProfileCreateOrConnectWithoutOperatorInput[]
    createMany?: ProfileCreateManyOperatorInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput> | GameCreateWithoutOperatorInput[] | GameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: GameCreateOrConnectWithoutOperatorInput | GameCreateOrConnectWithoutOperatorInput[]
    createMany?: GameCreateManyOperatorInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput> | ProductCreateWithoutOperatorInput[] | ProductUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOperatorInput | ProductCreateOrConnectWithoutOperatorInput[]
    createMany?: ProductCreateManyOperatorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type TournamentUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<TournamentCreateWithoutOperatorInput, TournamentUncheckedCreateWithoutOperatorInput> | TournamentCreateWithoutOperatorInput[] | TournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutOperatorInput | TournamentCreateOrConnectWithoutOperatorInput[]
    createMany?: TournamentCreateManyOperatorInputEnvelope
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
  }

  export type VipInfoUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<VipInfoCreateWithoutOperatorInput, VipInfoUncheckedCreateWithoutOperatorInput> | VipInfoCreateWithoutOperatorInput[] | VipInfoUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: VipInfoCreateOrConnectWithoutOperatorInput | VipInfoCreateOrConnectWithoutOperatorInput[]
    createMany?: VipInfoCreateManyOperatorInputEnvelope
    connect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
  }

  export type OperatorUpdateacceptedPaymentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutOperatorNestedInput = {
    create?: XOR<UserCreateWithoutOperatorInput, UserUncheckedCreateWithoutOperatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutOperatorInput
    upsert?: UserUpsertWithoutOperatorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOperatorInput, UserUpdateWithoutOperatorInput>, UserUncheckedUpdateWithoutOperatorInput>
  }

  export type ProfileUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput> | ProfileCreateWithoutOperatorInput[] | ProfileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutOperatorInput | ProfileCreateOrConnectWithoutOperatorInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutOperatorInput | ProfileUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: ProfileCreateManyOperatorInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutOperatorInput | ProfileUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutOperatorInput | ProfileUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type GameUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput> | GameCreateWithoutOperatorInput[] | GameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: GameCreateOrConnectWithoutOperatorInput | GameCreateOrConnectWithoutOperatorInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutOperatorInput | GameUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: GameCreateManyOperatorInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutOperatorInput | GameUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: GameUpdateManyWithWhereWithoutOperatorInput | GameUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput> | ProductCreateWithoutOperatorInput[] | ProductUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOperatorInput | ProductCreateOrConnectWithoutOperatorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOperatorInput | ProductUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: ProductCreateManyOperatorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOperatorInput | ProductUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOperatorInput | ProductUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type TournamentUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<TournamentCreateWithoutOperatorInput, TournamentUncheckedCreateWithoutOperatorInput> | TournamentCreateWithoutOperatorInput[] | TournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutOperatorInput | TournamentCreateOrConnectWithoutOperatorInput[]
    upsert?: TournamentUpsertWithWhereUniqueWithoutOperatorInput | TournamentUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: TournamentCreateManyOperatorInputEnvelope
    set?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    disconnect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    delete?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    update?: TournamentUpdateWithWhereUniqueWithoutOperatorInput | TournamentUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: TournamentUpdateManyWithWhereWithoutOperatorInput | TournamentUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
  }

  export type VipInfoUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<VipInfoCreateWithoutOperatorInput, VipInfoUncheckedCreateWithoutOperatorInput> | VipInfoCreateWithoutOperatorInput[] | VipInfoUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: VipInfoCreateOrConnectWithoutOperatorInput | VipInfoCreateOrConnectWithoutOperatorInput[]
    upsert?: VipInfoUpsertWithWhereUniqueWithoutOperatorInput | VipInfoUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: VipInfoCreateManyOperatorInputEnvelope
    set?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    disconnect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    delete?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    connect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    update?: VipInfoUpdateWithWhereUniqueWithoutOperatorInput | VipInfoUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: VipInfoUpdateManyWithWhereWithoutOperatorInput | VipInfoUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: VipInfoScalarWhereInput | VipInfoScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput> | ProfileCreateWithoutOperatorInput[] | ProfileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutOperatorInput | ProfileCreateOrConnectWithoutOperatorInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutOperatorInput | ProfileUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: ProfileCreateManyOperatorInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutOperatorInput | ProfileUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutOperatorInput | ProfileUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput> | GameCreateWithoutOperatorInput[] | GameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: GameCreateOrConnectWithoutOperatorInput | GameCreateOrConnectWithoutOperatorInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutOperatorInput | GameUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: GameCreateManyOperatorInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutOperatorInput | GameUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: GameUpdateManyWithWhereWithoutOperatorInput | GameUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput> | ProductCreateWithoutOperatorInput[] | ProductUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOperatorInput | ProductCreateOrConnectWithoutOperatorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOperatorInput | ProductUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: ProductCreateManyOperatorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOperatorInput | ProductUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOperatorInput | ProductUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type TournamentUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<TournamentCreateWithoutOperatorInput, TournamentUncheckedCreateWithoutOperatorInput> | TournamentCreateWithoutOperatorInput[] | TournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutOperatorInput | TournamentCreateOrConnectWithoutOperatorInput[]
    upsert?: TournamentUpsertWithWhereUniqueWithoutOperatorInput | TournamentUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: TournamentCreateManyOperatorInputEnvelope
    set?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    disconnect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    delete?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    update?: TournamentUpdateWithWhereUniqueWithoutOperatorInput | TournamentUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: TournamentUpdateManyWithWhereWithoutOperatorInput | TournamentUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
  }

  export type VipInfoUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<VipInfoCreateWithoutOperatorInput, VipInfoUncheckedCreateWithoutOperatorInput> | VipInfoCreateWithoutOperatorInput[] | VipInfoUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: VipInfoCreateOrConnectWithoutOperatorInput | VipInfoCreateOrConnectWithoutOperatorInput[]
    upsert?: VipInfoUpsertWithWhereUniqueWithoutOperatorInput | VipInfoUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: VipInfoCreateManyOperatorInputEnvelope
    set?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    disconnect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    delete?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    connect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    update?: VipInfoUpdateWithWhereUniqueWithoutOperatorInput | VipInfoUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: VipInfoUpdateManyWithWhereWithoutOperatorInput | VipInfoUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: VipInfoScalarWhereInput | VipInfoScalarWhereInput[]
  }

  export type OperatorCreateNestedOneWithoutProfilesInput = {
    create?: XOR<OperatorCreateWithoutProfilesInput, OperatorUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutProfilesInput
    connect?: OperatorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActiveProfileInput = {
    create?: XOR<UserCreateWithoutActiveProfileInput, UserUncheckedCreateWithoutActiveProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutActiveProfileInput
    connect?: UserWhereUniqueInput
  }

  export type GamesessionCreateNestedManyWithoutProfileInput = {
    create?: XOR<GamesessionCreateWithoutProfileInput, GamesessionUncheckedCreateWithoutProfileInput> | GamesessionCreateWithoutProfileInput[] | GamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutProfileInput | GamesessionCreateOrConnectWithoutProfileInput[]
    createMany?: GamesessionCreateManyProfileInputEnvelope
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
  }

  export type TournamententryCreateNestedManyWithoutProfileInput = {
    create?: XOR<TournamententryCreateWithoutProfileInput, TournamententryUncheckedCreateWithoutProfileInput> | TournamententryCreateWithoutProfileInput[] | TournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutProfileInput | TournamententryCreateOrConnectWithoutProfileInput[]
    createMany?: TournamententryCreateManyProfileInputEnvelope
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutProfileInput = {
    create?: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput> | TransactionCreateWithoutProfileInput[] | TransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProfileInput | TransactionCreateOrConnectWithoutProfileInput[]
    createMany?: TransactionCreateManyProfileInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type GamesessionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<GamesessionCreateWithoutProfileInput, GamesessionUncheckedCreateWithoutProfileInput> | GamesessionCreateWithoutProfileInput[] | GamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutProfileInput | GamesessionCreateOrConnectWithoutProfileInput[]
    createMany?: GamesessionCreateManyProfileInputEnvelope
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
  }

  export type TournamententryUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<TournamententryCreateWithoutProfileInput, TournamententryUncheckedCreateWithoutProfileInput> | TournamententryCreateWithoutProfileInput[] | TournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutProfileInput | TournamententryCreateOrConnectWithoutProfileInput[]
    createMany?: TournamententryCreateManyProfileInputEnvelope
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput> | TransactionCreateWithoutProfileInput[] | TransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProfileInput | TransactionCreateOrConnectWithoutProfileInput[]
    createMany?: TransactionCreateManyProfileInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type OperatorUpdateOneRequiredWithoutProfilesNestedInput = {
    create?: XOR<OperatorCreateWithoutProfilesInput, OperatorUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutProfilesInput
    upsert?: OperatorUpsertWithoutProfilesInput
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutProfilesInput, OperatorUpdateWithoutProfilesInput>, OperatorUncheckedUpdateWithoutProfilesInput>
  }

  export type UserUpdateOneRequiredWithoutActiveProfileNestedInput = {
    create?: XOR<UserCreateWithoutActiveProfileInput, UserUncheckedCreateWithoutActiveProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutActiveProfileInput
    upsert?: UserUpsertWithoutActiveProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActiveProfileInput, UserUpdateWithoutActiveProfileInput>, UserUncheckedUpdateWithoutActiveProfileInput>
  }

  export type GamesessionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<GamesessionCreateWithoutProfileInput, GamesessionUncheckedCreateWithoutProfileInput> | GamesessionCreateWithoutProfileInput[] | GamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutProfileInput | GamesessionCreateOrConnectWithoutProfileInput[]
    upsert?: GamesessionUpsertWithWhereUniqueWithoutProfileInput | GamesessionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: GamesessionCreateManyProfileInputEnvelope
    set?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    disconnect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    delete?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    update?: GamesessionUpdateWithWhereUniqueWithoutProfileInput | GamesessionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: GamesessionUpdateManyWithWhereWithoutProfileInput | GamesessionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: GamesessionScalarWhereInput | GamesessionScalarWhereInput[]
  }

  export type TournamententryUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TournamententryCreateWithoutProfileInput, TournamententryUncheckedCreateWithoutProfileInput> | TournamententryCreateWithoutProfileInput[] | TournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutProfileInput | TournamententryCreateOrConnectWithoutProfileInput[]
    upsert?: TournamententryUpsertWithWhereUniqueWithoutProfileInput | TournamententryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TournamententryCreateManyProfileInputEnvelope
    set?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    disconnect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    delete?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    update?: TournamententryUpdateWithWhereUniqueWithoutProfileInput | TournamententryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TournamententryUpdateManyWithWhereWithoutProfileInput | TournamententryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TournamententryScalarWhereInput | TournamententryScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput> | TransactionCreateWithoutProfileInput[] | TransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProfileInput | TransactionCreateOrConnectWithoutProfileInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutProfileInput | TransactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TransactionCreateManyProfileInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutProfileInput | TransactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutProfileInput | TransactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type GamesessionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<GamesessionCreateWithoutProfileInput, GamesessionUncheckedCreateWithoutProfileInput> | GamesessionCreateWithoutProfileInput[] | GamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutProfileInput | GamesessionCreateOrConnectWithoutProfileInput[]
    upsert?: GamesessionUpsertWithWhereUniqueWithoutProfileInput | GamesessionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: GamesessionCreateManyProfileInputEnvelope
    set?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    disconnect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    delete?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    update?: GamesessionUpdateWithWhereUniqueWithoutProfileInput | GamesessionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: GamesessionUpdateManyWithWhereWithoutProfileInput | GamesessionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: GamesessionScalarWhereInput | GamesessionScalarWhereInput[]
  }

  export type TournamententryUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TournamententryCreateWithoutProfileInput, TournamententryUncheckedCreateWithoutProfileInput> | TournamententryCreateWithoutProfileInput[] | TournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutProfileInput | TournamententryCreateOrConnectWithoutProfileInput[]
    upsert?: TournamententryUpsertWithWhereUniqueWithoutProfileInput | TournamententryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TournamententryCreateManyProfileInputEnvelope
    set?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    disconnect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    delete?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    update?: TournamententryUpdateWithWhereUniqueWithoutProfileInput | TournamententryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TournamententryUpdateManyWithWhereWithoutProfileInput | TournamententryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TournamententryScalarWhereInput | TournamententryScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput> | TransactionCreateWithoutProfileInput[] | TransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProfileInput | TransactionCreateOrConnectWithoutProfileInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutProfileInput | TransactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TransactionCreateManyProfileInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutProfileInput | TransactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutProfileInput | TransactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type OperatorCreateNestedOneWithoutGamesInput = {
    create?: XOR<OperatorCreateWithoutGamesInput, OperatorUncheckedCreateWithoutGamesInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutGamesInput
    connect?: OperatorWhereUniqueInput
  }

  export type GamesessionCreateNestedManyWithoutGameInput = {
    create?: XOR<GamesessionCreateWithoutGameInput, GamesessionUncheckedCreateWithoutGameInput> | GamesessionCreateWithoutGameInput[] | GamesessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutGameInput | GamesessionCreateOrConnectWithoutGameInput[]
    createMany?: GamesessionCreateManyGameInputEnvelope
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
  }

  export type TournamentgameCreateNestedManyWithoutGameInput = {
    create?: XOR<TournamentgameCreateWithoutGameInput, TournamentgameUncheckedCreateWithoutGameInput> | TournamentgameCreateWithoutGameInput[] | TournamentgameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: TournamentgameCreateOrConnectWithoutGameInput | TournamentgameCreateOrConnectWithoutGameInput[]
    createMany?: TournamentgameCreateManyGameInputEnvelope
    connect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
  }

  export type GamesessionUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GamesessionCreateWithoutGameInput, GamesessionUncheckedCreateWithoutGameInput> | GamesessionCreateWithoutGameInput[] | GamesessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutGameInput | GamesessionCreateOrConnectWithoutGameInput[]
    createMany?: GamesessionCreateManyGameInputEnvelope
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
  }

  export type TournamentgameUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<TournamentgameCreateWithoutGameInput, TournamentgameUncheckedCreateWithoutGameInput> | TournamentgameCreateWithoutGameInput[] | TournamentgameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: TournamentgameCreateOrConnectWithoutGameInput | TournamentgameCreateOrConnectWithoutGameInput[]
    createMany?: TournamentgameCreateManyGameInputEnvelope
    connect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumGameCategoryFieldUpdateOperationsInput = {
    set?: $Enums.GameCategory
  }

  export type OperatorUpdateOneWithoutGamesNestedInput = {
    create?: XOR<OperatorCreateWithoutGamesInput, OperatorUncheckedCreateWithoutGamesInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutGamesInput
    upsert?: OperatorUpsertWithoutGamesInput
    disconnect?: OperatorWhereInput | boolean
    delete?: OperatorWhereInput | boolean
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutGamesInput, OperatorUpdateWithoutGamesInput>, OperatorUncheckedUpdateWithoutGamesInput>
  }

  export type GamesessionUpdateManyWithoutGameNestedInput = {
    create?: XOR<GamesessionCreateWithoutGameInput, GamesessionUncheckedCreateWithoutGameInput> | GamesessionCreateWithoutGameInput[] | GamesessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutGameInput | GamesessionCreateOrConnectWithoutGameInput[]
    upsert?: GamesessionUpsertWithWhereUniqueWithoutGameInput | GamesessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GamesessionCreateManyGameInputEnvelope
    set?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    disconnect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    delete?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    update?: GamesessionUpdateWithWhereUniqueWithoutGameInput | GamesessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GamesessionUpdateManyWithWhereWithoutGameInput | GamesessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GamesessionScalarWhereInput | GamesessionScalarWhereInput[]
  }

  export type TournamentgameUpdateManyWithoutGameNestedInput = {
    create?: XOR<TournamentgameCreateWithoutGameInput, TournamentgameUncheckedCreateWithoutGameInput> | TournamentgameCreateWithoutGameInput[] | TournamentgameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: TournamentgameCreateOrConnectWithoutGameInput | TournamentgameCreateOrConnectWithoutGameInput[]
    upsert?: TournamentgameUpsertWithWhereUniqueWithoutGameInput | TournamentgameUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: TournamentgameCreateManyGameInputEnvelope
    set?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    disconnect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    delete?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    connect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    update?: TournamentgameUpdateWithWhereUniqueWithoutGameInput | TournamentgameUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: TournamentgameUpdateManyWithWhereWithoutGameInput | TournamentgameUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: TournamentgameScalarWhereInput | TournamentgameScalarWhereInput[]
  }

  export type GamesessionUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GamesessionCreateWithoutGameInput, GamesessionUncheckedCreateWithoutGameInput> | GamesessionCreateWithoutGameInput[] | GamesessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutGameInput | GamesessionCreateOrConnectWithoutGameInput[]
    upsert?: GamesessionUpsertWithWhereUniqueWithoutGameInput | GamesessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GamesessionCreateManyGameInputEnvelope
    set?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    disconnect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    delete?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    update?: GamesessionUpdateWithWhereUniqueWithoutGameInput | GamesessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GamesessionUpdateManyWithWhereWithoutGameInput | GamesessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GamesessionScalarWhereInput | GamesessionScalarWhereInput[]
  }

  export type TournamentgameUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<TournamentgameCreateWithoutGameInput, TournamentgameUncheckedCreateWithoutGameInput> | TournamentgameCreateWithoutGameInput[] | TournamentgameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: TournamentgameCreateOrConnectWithoutGameInput | TournamentgameCreateOrConnectWithoutGameInput[]
    upsert?: TournamentgameUpsertWithWhereUniqueWithoutGameInput | TournamentgameUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: TournamentgameCreateManyGameInputEnvelope
    set?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    disconnect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    delete?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    connect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    update?: TournamentgameUpdateWithWhereUniqueWithoutGameInput | TournamentgameUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: TournamentgameUpdateManyWithWhereWithoutGameInput | TournamentgameUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: TournamentgameScalarWhereInput | TournamentgameScalarWhereInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InvitationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type InvitationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutOrganizationInput | InvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutOrganizationInput | InvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutOrganizationInput | InvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutOrganizationInput | MemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutOrganizationInput | MemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutOrganizationInput | MemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutOrganizationInput | InvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutOrganizationInput | InvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutOrganizationInput | InvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutOrganizationInput | MemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutOrganizationInput | MemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutOrganizationInput | MemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembersInput = {
    create?: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    upsert?: OrganizationUpsertWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembersInput, OrganizationUpdateWithoutMembersInput>, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersInput
    upsert?: UserUpsertWithoutMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembersInput, UserUpdateWithoutMembersInput>, UserUncheckedUpdateWithoutMembersInput>
  }

  export type UserCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    upsert?: UserUpsertWithoutInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsInput, UserUpdateWithoutInvitationsInput>, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    upsert?: OrganizationUpsertWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInvitationsInput, OrganizationUpdateWithoutInvitationsInput>, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutTwofactorsInput = {
    create?: XOR<UserCreateWithoutTwofactorsInput, UserUncheckedCreateWithoutTwofactorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwofactorsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTwofactorsNestedInput = {
    create?: XOR<UserCreateWithoutTwofactorsInput, UserUncheckedCreateWithoutTwofactorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwofactorsInput
    upsert?: UserUpsertWithoutTwofactorsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTwofactorsInput, UserUpdateWithoutTwofactorsInput>, UserUncheckedUpdateWithoutTwofactorsInput>
  }

  export type ChatroomCreateNestedOneWithoutChatmessageInput = {
    create?: XOR<ChatroomCreateWithoutChatmessageInput, ChatroomUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: ChatroomCreateOrConnectWithoutChatmessageInput
    connect?: ChatroomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatmessageInput = {
    create?: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatmessageInput
    connect?: UserWhereUniqueInput
  }

  export type EnumChatChannelFieldUpdateOperationsInput = {
    set?: $Enums.ChatChannel
  }

  export type ChatroomUpdateOneWithoutChatmessageNestedInput = {
    create?: XOR<ChatroomCreateWithoutChatmessageInput, ChatroomUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: ChatroomCreateOrConnectWithoutChatmessageInput
    upsert?: ChatroomUpsertWithoutChatmessageInput
    disconnect?: ChatroomWhereInput | boolean
    delete?: ChatroomWhereInput | boolean
    connect?: ChatroomWhereUniqueInput
    update?: XOR<XOR<ChatroomUpdateToOneWithWhereWithoutChatmessageInput, ChatroomUpdateWithoutChatmessageInput>, ChatroomUncheckedUpdateWithoutChatmessageInput>
  }

  export type UserUpdateOneRequiredWithoutChatmessageNestedInput = {
    create?: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatmessageInput
    upsert?: UserUpsertWithoutChatmessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatmessageInput, UserUpdateWithoutChatmessageInput>, UserUncheckedUpdateWithoutChatmessageInput>
  }

  export type ChatmessageCreateNestedManyWithoutChatroomInput = {
    create?: XOR<ChatmessageCreateWithoutChatroomInput, ChatmessageUncheckedCreateWithoutChatroomInput> | ChatmessageCreateWithoutChatroomInput[] | ChatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatmessageCreateOrConnectWithoutChatroomInput | ChatmessageCreateOrConnectWithoutChatroomInput[]
    createMany?: ChatmessageCreateManyChatroomInputEnvelope
    connect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
  }

  export type GamesessionCreateNestedOneWithoutChatroomInput = {
    create?: XOR<GamesessionCreateWithoutChatroomInput, GamesessionUncheckedCreateWithoutChatroomInput>
    connectOrCreate?: GamesessionCreateOrConnectWithoutChatroomInput
    connect?: GamesessionWhereUniqueInput
  }

  export type ChatmessageUncheckedCreateNestedManyWithoutChatroomInput = {
    create?: XOR<ChatmessageCreateWithoutChatroomInput, ChatmessageUncheckedCreateWithoutChatroomInput> | ChatmessageCreateWithoutChatroomInput[] | ChatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatmessageCreateOrConnectWithoutChatroomInput | ChatmessageCreateOrConnectWithoutChatroomInput[]
    createMany?: ChatmessageCreateManyChatroomInputEnvelope
    connect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
  }

  export type ChatmessageUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<ChatmessageCreateWithoutChatroomInput, ChatmessageUncheckedCreateWithoutChatroomInput> | ChatmessageCreateWithoutChatroomInput[] | ChatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatmessageCreateOrConnectWithoutChatroomInput | ChatmessageCreateOrConnectWithoutChatroomInput[]
    upsert?: ChatmessageUpsertWithWhereUniqueWithoutChatroomInput | ChatmessageUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: ChatmessageCreateManyChatroomInputEnvelope
    set?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    disconnect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    delete?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    connect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    update?: ChatmessageUpdateWithWhereUniqueWithoutChatroomInput | ChatmessageUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: ChatmessageUpdateManyWithWhereWithoutChatroomInput | ChatmessageUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: ChatmessageScalarWhereInput | ChatmessageScalarWhereInput[]
  }

  export type GamesessionUpdateOneWithoutChatroomNestedInput = {
    create?: XOR<GamesessionCreateWithoutChatroomInput, GamesessionUncheckedCreateWithoutChatroomInput>
    connectOrCreate?: GamesessionCreateOrConnectWithoutChatroomInput
    upsert?: GamesessionUpsertWithoutChatroomInput
    disconnect?: GamesessionWhereInput | boolean
    delete?: GamesessionWhereInput | boolean
    connect?: GamesessionWhereUniqueInput
    update?: XOR<XOR<GamesessionUpdateToOneWithWhereWithoutChatroomInput, GamesessionUpdateWithoutChatroomInput>, GamesessionUncheckedUpdateWithoutChatroomInput>
  }

  export type ChatmessageUncheckedUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<ChatmessageCreateWithoutChatroomInput, ChatmessageUncheckedCreateWithoutChatroomInput> | ChatmessageCreateWithoutChatroomInput[] | ChatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: ChatmessageCreateOrConnectWithoutChatroomInput | ChatmessageCreateOrConnectWithoutChatroomInput[]
    upsert?: ChatmessageUpsertWithWhereUniqueWithoutChatroomInput | ChatmessageUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: ChatmessageCreateManyChatroomInputEnvelope
    set?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    disconnect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    delete?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    connect?: ChatmessageWhereUniqueInput | ChatmessageWhereUniqueInput[]
    update?: ChatmessageUpdateWithWhereUniqueWithoutChatroomInput | ChatmessageUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: ChatmessageUpdateManyWithWhereWithoutChatroomInput | ChatmessageUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: ChatmessageScalarWhereInput | ChatmessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFriendshipFriendshipFriendidtouserInput = {
    create?: XOR<UserCreateWithoutFriendshipFriendshipFriendidtouserInput, UserUncheckedCreateWithoutFriendshipFriendshipFriendidtouserInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipFriendshipFriendidtouserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFriendshipFriendshipUseridtouserInput = {
    create?: XOR<UserCreateWithoutFriendshipFriendshipUseridtouserInput, UserUncheckedCreateWithoutFriendshipFriendshipUseridtouserInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipFriendshipUseridtouserInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFriendshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.FriendshipStatus
  }

  export type UserUpdateOneRequiredWithoutFriendshipFriendshipFriendidtouserNestedInput = {
    create?: XOR<UserCreateWithoutFriendshipFriendshipFriendidtouserInput, UserUncheckedCreateWithoutFriendshipFriendshipFriendidtouserInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipFriendshipFriendidtouserInput
    upsert?: UserUpsertWithoutFriendshipFriendshipFriendidtouserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendshipFriendshipFriendidtouserInput, UserUpdateWithoutFriendshipFriendshipFriendidtouserInput>, UserUncheckedUpdateWithoutFriendshipFriendshipFriendidtouserInput>
  }

  export type UserUpdateOneRequiredWithoutFriendshipFriendshipUseridtouserNestedInput = {
    create?: XOR<UserCreateWithoutFriendshipFriendshipUseridtouserInput, UserUncheckedCreateWithoutFriendshipFriendshipUseridtouserInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipFriendshipUseridtouserInput
    upsert?: UserUpsertWithoutFriendshipFriendshipUseridtouserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendshipFriendshipUseridtouserInput, UserUpdateWithoutFriendshipFriendshipUseridtouserInput>, UserUncheckedUpdateWithoutFriendshipFriendshipUseridtouserInput>
  }

  export type ChatroomCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<ChatroomCreateWithoutGamesessionInput, ChatroomUncheckedCreateWithoutGamesessionInput> | ChatroomCreateWithoutGamesessionInput[] | ChatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: ChatroomCreateOrConnectWithoutGamesessionInput | ChatroomCreateOrConnectWithoutGamesessionInput[]
    createMany?: ChatroomCreateManyGamesessionInputEnvelope
    connect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
  }

  export type GameCreateNestedOneWithoutGamesessionInput = {
    create?: XOR<GameCreateWithoutGamesessionInput, GameUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: GameCreateOrConnectWithoutGamesessionInput
    connect?: GameWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutGamesessionInput = {
    create?: XOR<ProfileCreateWithoutGamesessionInput, ProfileUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutGamesessionInput
    connect?: ProfileWhereUniqueInput
  }

  export type TournamentCreateNestedOneWithoutGamesessionInput = {
    create?: XOR<TournamentCreateWithoutGamesessionInput, TournamentUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutGamesessionInput
    connect?: TournamentWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput> | TransactionCreateWithoutGamesessionInput[] | TransactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGamesessionInput | TransactionCreateOrConnectWithoutGamesessionInput[]
    createMany?: TransactionCreateManyGamesessionInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type VipInfoCreateNestedOneWithoutGamesessionInput = {
    create?: XOR<VipInfoCreateWithoutGamesessionInput, VipInfoUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: VipInfoCreateOrConnectWithoutGamesessionInput
    connect?: VipInfoWhereUniqueInput
  }

  export type ChatroomUncheckedCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<ChatroomCreateWithoutGamesessionInput, ChatroomUncheckedCreateWithoutGamesessionInput> | ChatroomCreateWithoutGamesessionInput[] | ChatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: ChatroomCreateOrConnectWithoutGamesessionInput | ChatroomCreateOrConnectWithoutGamesessionInput[]
    createMany?: ChatroomCreateManyGamesessionInputEnvelope
    connect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput> | TransactionCreateWithoutGamesessionInput[] | TransactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGamesessionInput | TransactionCreateOrConnectWithoutGamesessionInput[]
    createMany?: TransactionCreateManyGamesessionInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ChatroomUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<ChatroomCreateWithoutGamesessionInput, ChatroomUncheckedCreateWithoutGamesessionInput> | ChatroomCreateWithoutGamesessionInput[] | ChatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: ChatroomCreateOrConnectWithoutGamesessionInput | ChatroomCreateOrConnectWithoutGamesessionInput[]
    upsert?: ChatroomUpsertWithWhereUniqueWithoutGamesessionInput | ChatroomUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: ChatroomCreateManyGamesessionInputEnvelope
    set?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    disconnect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    delete?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    connect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    update?: ChatroomUpdateWithWhereUniqueWithoutGamesessionInput | ChatroomUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: ChatroomUpdateManyWithWhereWithoutGamesessionInput | ChatroomUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: ChatroomScalarWhereInput | ChatroomScalarWhereInput[]
  }

  export type GameUpdateOneRequiredWithoutGamesessionNestedInput = {
    create?: XOR<GameCreateWithoutGamesessionInput, GameUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: GameCreateOrConnectWithoutGamesessionInput
    upsert?: GameUpsertWithoutGamesessionInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutGamesessionInput, GameUpdateWithoutGamesessionInput>, GameUncheckedUpdateWithoutGamesessionInput>
  }

  export type ProfileUpdateOneRequiredWithoutGamesessionNestedInput = {
    create?: XOR<ProfileCreateWithoutGamesessionInput, ProfileUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutGamesessionInput
    upsert?: ProfileUpsertWithoutGamesessionInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutGamesessionInput, ProfileUpdateWithoutGamesessionInput>, ProfileUncheckedUpdateWithoutGamesessionInput>
  }

  export type TournamentUpdateOneWithoutGamesessionNestedInput = {
    create?: XOR<TournamentCreateWithoutGamesessionInput, TournamentUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutGamesessionInput
    upsert?: TournamentUpsertWithoutGamesessionInput
    disconnect?: TournamentWhereInput | boolean
    delete?: TournamentWhereInput | boolean
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutGamesessionInput, TournamentUpdateWithoutGamesessionInput>, TournamentUncheckedUpdateWithoutGamesessionInput>
  }

  export type TransactionUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput> | TransactionCreateWithoutGamesessionInput[] | TransactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGamesessionInput | TransactionCreateOrConnectWithoutGamesessionInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutGamesessionInput | TransactionUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: TransactionCreateManyGamesessionInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutGamesessionInput | TransactionUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutGamesessionInput | TransactionUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type VipInfoUpdateOneWithoutGamesessionNestedInput = {
    create?: XOR<VipInfoCreateWithoutGamesessionInput, VipInfoUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: VipInfoCreateOrConnectWithoutGamesessionInput
    upsert?: VipInfoUpsertWithoutGamesessionInput
    disconnect?: VipInfoWhereInput | boolean
    delete?: VipInfoWhereInput | boolean
    connect?: VipInfoWhereUniqueInput
    update?: XOR<XOR<VipInfoUpdateToOneWithWhereWithoutGamesessionInput, VipInfoUpdateWithoutGamesessionInput>, VipInfoUncheckedUpdateWithoutGamesessionInput>
  }

  export type ChatroomUncheckedUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<ChatroomCreateWithoutGamesessionInput, ChatroomUncheckedCreateWithoutGamesessionInput> | ChatroomCreateWithoutGamesessionInput[] | ChatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: ChatroomCreateOrConnectWithoutGamesessionInput | ChatroomCreateOrConnectWithoutGamesessionInput[]
    upsert?: ChatroomUpsertWithWhereUniqueWithoutGamesessionInput | ChatroomUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: ChatroomCreateManyGamesessionInputEnvelope
    set?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    disconnect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    delete?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    connect?: ChatroomWhereUniqueInput | ChatroomWhereUniqueInput[]
    update?: ChatroomUpdateWithWhereUniqueWithoutGamesessionInput | ChatroomUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: ChatroomUpdateManyWithWhereWithoutGamesessionInput | ChatroomUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: ChatroomScalarWhereInput | ChatroomScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput> | TransactionCreateWithoutGamesessionInput[] | TransactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGamesessionInput | TransactionCreateOrConnectWithoutGamesessionInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutGamesessionInput | TransactionUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: TransactionCreateManyGamesessionInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutGamesessionInput | TransactionUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutGamesessionInput | TransactionUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type OperatorCreateNestedOneWithoutProductsInput = {
    create?: XOR<OperatorCreateWithoutProductsInput, OperatorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutProductsInput
    connect?: OperatorWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput> | TransactionCreateWithoutProductInput[] | TransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProductInput | TransactionCreateOrConnectWithoutProductInput[]
    createMany?: TransactionCreateManyProductInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput> | TransactionCreateWithoutProductInput[] | TransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProductInput | TransactionCreateOrConnectWithoutProductInput[]
    createMany?: TransactionCreateManyProductInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type OperatorUpdateOneWithoutProductsNestedInput = {
    create?: XOR<OperatorCreateWithoutProductsInput, OperatorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutProductsInput
    upsert?: OperatorUpsertWithoutProductsInput
    disconnect?: OperatorWhereInput | boolean
    delete?: OperatorWhereInput | boolean
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutProductsInput, OperatorUpdateWithoutProductsInput>, OperatorUncheckedUpdateWithoutProductsInput>
  }

  export type TransactionUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput> | TransactionCreateWithoutProductInput[] | TransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProductInput | TransactionCreateOrConnectWithoutProductInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutProductInput | TransactionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransactionCreateManyProductInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutProductInput | TransactionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutProductInput | TransactionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput> | TransactionCreateWithoutProductInput[] | TransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProductInput | TransactionCreateOrConnectWithoutProductInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutProductInput | TransactionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransactionCreateManyProductInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutProductInput | TransactionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutProductInput | TransactionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type GamesessionCreateNestedManyWithoutTournamentInput = {
    create?: XOR<GamesessionCreateWithoutTournamentInput, GamesessionUncheckedCreateWithoutTournamentInput> | GamesessionCreateWithoutTournamentInput[] | GamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutTournamentInput | GamesessionCreateOrConnectWithoutTournamentInput[]
    createMany?: GamesessionCreateManyTournamentInputEnvelope
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
  }

  export type OperatorCreateNestedOneWithoutTournamentsInput = {
    create?: XOR<OperatorCreateWithoutTournamentsInput, OperatorUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutTournamentsInput
    connect?: OperatorWhereUniqueInput
  }

  export type TournamententryCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamententryCreateWithoutTournamentInput, TournamententryUncheckedCreateWithoutTournamentInput> | TournamententryCreateWithoutTournamentInput[] | TournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutTournamentInput | TournamententryCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamententryCreateManyTournamentInputEnvelope
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
  }

  export type TournamentgameCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentgameCreateWithoutTournamentInput, TournamentgameUncheckedCreateWithoutTournamentInput> | TournamentgameCreateWithoutTournamentInput[] | TournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentgameCreateOrConnectWithoutTournamentInput | TournamentgameCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentgameCreateManyTournamentInputEnvelope
    connect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
  }

  export type GamesessionUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<GamesessionCreateWithoutTournamentInput, GamesessionUncheckedCreateWithoutTournamentInput> | GamesessionCreateWithoutTournamentInput[] | GamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutTournamentInput | GamesessionCreateOrConnectWithoutTournamentInput[]
    createMany?: GamesessionCreateManyTournamentInputEnvelope
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
  }

  export type TournamententryUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamententryCreateWithoutTournamentInput, TournamententryUncheckedCreateWithoutTournamentInput> | TournamententryCreateWithoutTournamentInput[] | TournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutTournamentInput | TournamententryCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamententryCreateManyTournamentInputEnvelope
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
  }

  export type TournamentgameUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentgameCreateWithoutTournamentInput, TournamentgameUncheckedCreateWithoutTournamentInput> | TournamentgameCreateWithoutTournamentInput[] | TournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentgameCreateOrConnectWithoutTournamentInput | TournamentgameCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentgameCreateManyTournamentInputEnvelope
    connect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
  }

  export type GamesessionUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<GamesessionCreateWithoutTournamentInput, GamesessionUncheckedCreateWithoutTournamentInput> | GamesessionCreateWithoutTournamentInput[] | GamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutTournamentInput | GamesessionCreateOrConnectWithoutTournamentInput[]
    upsert?: GamesessionUpsertWithWhereUniqueWithoutTournamentInput | GamesessionUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: GamesessionCreateManyTournamentInputEnvelope
    set?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    disconnect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    delete?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    update?: GamesessionUpdateWithWhereUniqueWithoutTournamentInput | GamesessionUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: GamesessionUpdateManyWithWhereWithoutTournamentInput | GamesessionUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: GamesessionScalarWhereInput | GamesessionScalarWhereInput[]
  }

  export type OperatorUpdateOneRequiredWithoutTournamentsNestedInput = {
    create?: XOR<OperatorCreateWithoutTournamentsInput, OperatorUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutTournamentsInput
    upsert?: OperatorUpsertWithoutTournamentsInput
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutTournamentsInput, OperatorUpdateWithoutTournamentsInput>, OperatorUncheckedUpdateWithoutTournamentsInput>
  }

  export type TournamententryUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamententryCreateWithoutTournamentInput, TournamententryUncheckedCreateWithoutTournamentInput> | TournamententryCreateWithoutTournamentInput[] | TournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutTournamentInput | TournamententryCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamententryUpsertWithWhereUniqueWithoutTournamentInput | TournamententryUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamententryCreateManyTournamentInputEnvelope
    set?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    disconnect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    delete?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    update?: TournamententryUpdateWithWhereUniqueWithoutTournamentInput | TournamententryUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamententryUpdateManyWithWhereWithoutTournamentInput | TournamententryUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamententryScalarWhereInput | TournamententryScalarWhereInput[]
  }

  export type TournamentgameUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentgameCreateWithoutTournamentInput, TournamentgameUncheckedCreateWithoutTournamentInput> | TournamentgameCreateWithoutTournamentInput[] | TournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentgameCreateOrConnectWithoutTournamentInput | TournamentgameCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentgameUpsertWithWhereUniqueWithoutTournamentInput | TournamentgameUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentgameCreateManyTournamentInputEnvelope
    set?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    disconnect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    delete?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    connect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    update?: TournamentgameUpdateWithWhereUniqueWithoutTournamentInput | TournamentgameUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentgameUpdateManyWithWhereWithoutTournamentInput | TournamentgameUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentgameScalarWhereInput | TournamentgameScalarWhereInput[]
  }

  export type GamesessionUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<GamesessionCreateWithoutTournamentInput, GamesessionUncheckedCreateWithoutTournamentInput> | GamesessionCreateWithoutTournamentInput[] | GamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutTournamentInput | GamesessionCreateOrConnectWithoutTournamentInput[]
    upsert?: GamesessionUpsertWithWhereUniqueWithoutTournamentInput | GamesessionUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: GamesessionCreateManyTournamentInputEnvelope
    set?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    disconnect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    delete?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    update?: GamesessionUpdateWithWhereUniqueWithoutTournamentInput | GamesessionUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: GamesessionUpdateManyWithWhereWithoutTournamentInput | GamesessionUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: GamesessionScalarWhereInput | GamesessionScalarWhereInput[]
  }

  export type TournamententryUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamententryCreateWithoutTournamentInput, TournamententryUncheckedCreateWithoutTournamentInput> | TournamententryCreateWithoutTournamentInput[] | TournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamententryCreateOrConnectWithoutTournamentInput | TournamententryCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamententryUpsertWithWhereUniqueWithoutTournamentInput | TournamententryUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamententryCreateManyTournamentInputEnvelope
    set?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    disconnect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    delete?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    connect?: TournamententryWhereUniqueInput | TournamententryWhereUniqueInput[]
    update?: TournamententryUpdateWithWhereUniqueWithoutTournamentInput | TournamententryUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamententryUpdateManyWithWhereWithoutTournamentInput | TournamententryUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamententryScalarWhereInput | TournamententryScalarWhereInput[]
  }

  export type TournamentgameUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentgameCreateWithoutTournamentInput, TournamentgameUncheckedCreateWithoutTournamentInput> | TournamentgameCreateWithoutTournamentInput[] | TournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentgameCreateOrConnectWithoutTournamentInput | TournamentgameCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentgameUpsertWithWhereUniqueWithoutTournamentInput | TournamentgameUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentgameCreateManyTournamentInputEnvelope
    set?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    disconnect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    delete?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    connect?: TournamentgameWhereUniqueInput | TournamentgameWhereUniqueInput[]
    update?: TournamentgameUpdateWithWhereUniqueWithoutTournamentInput | TournamentgameUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentgameUpdateManyWithWhereWithoutTournamentInput | TournamentgameUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentgameScalarWhereInput | TournamentgameScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutTournamententryInput = {
    create?: XOR<ProfileCreateWithoutTournamententryInput, ProfileUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTournamententryInput
    connect?: ProfileWhereUniqueInput
  }

  export type TournamentCreateNestedOneWithoutTournamententryInput = {
    create?: XOR<TournamentCreateWithoutTournamententryInput, TournamentUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamententryInput
    connect?: TournamentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTournamententryInput = {
    create?: XOR<UserCreateWithoutTournamententryInput, UserUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTournamententryInput
    connect?: UserWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutTournamententryNestedInput = {
    create?: XOR<ProfileCreateWithoutTournamententryInput, ProfileUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTournamententryInput
    upsert?: ProfileUpsertWithoutTournamententryInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutTournamententryInput, ProfileUpdateWithoutTournamententryInput>, ProfileUncheckedUpdateWithoutTournamententryInput>
  }

  export type TournamentUpdateOneRequiredWithoutTournamententryNestedInput = {
    create?: XOR<TournamentCreateWithoutTournamententryInput, TournamentUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamententryInput
    upsert?: TournamentUpsertWithoutTournamententryInput
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutTournamententryInput, TournamentUpdateWithoutTournamententryInput>, TournamentUncheckedUpdateWithoutTournamententryInput>
  }

  export type UserUpdateOneRequiredWithoutTournamententryNestedInput = {
    create?: XOR<UserCreateWithoutTournamententryInput, UserUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTournamententryInput
    upsert?: UserUpsertWithoutTournamententryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTournamententryInput, UserUpdateWithoutTournamententryInput>, UserUncheckedUpdateWithoutTournamententryInput>
  }

  export type GameCreateNestedOneWithoutTournamentgameInput = {
    create?: XOR<GameCreateWithoutTournamentgameInput, GameUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: GameCreateOrConnectWithoutTournamentgameInput
    connect?: GameWhereUniqueInput
  }

  export type TournamentCreateNestedOneWithoutTournamentgameInput = {
    create?: XOR<TournamentCreateWithoutTournamentgameInput, TournamentUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamentgameInput
    connect?: TournamentWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutTournamentgameNestedInput = {
    create?: XOR<GameCreateWithoutTournamentgameInput, GameUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: GameCreateOrConnectWithoutTournamentgameInput
    upsert?: GameUpsertWithoutTournamentgameInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutTournamentgameInput, GameUpdateWithoutTournamentgameInput>, GameUncheckedUpdateWithoutTournamentgameInput>
  }

  export type TournamentUpdateOneRequiredWithoutTournamentgameNestedInput = {
    create?: XOR<TournamentCreateWithoutTournamentgameInput, TournamentUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamentgameInput
    upsert?: TournamentUpsertWithoutTournamentgameInput
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutTournamentgameInput, TournamentUpdateWithoutTournamentgameInput>, TournamentUncheckedUpdateWithoutTournamentgameInput>
  }

  export type GamesessionCreateNestedOneWithoutTransactionInput = {
    create?: XOR<GamesessionCreateWithoutTransactionInput, GamesessionUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: GamesessionCreateOrConnectWithoutTransactionInput
    connect?: GamesessionWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ProfileCreateWithoutTransactionsInput, ProfileUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTransactionsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionsInput
    connect?: ProductWhereUniqueInput
  }

  export type VipInfoCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<VipInfoCreateWithoutTransactionsInput, VipInfoUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: VipInfoCreateOrConnectWithoutTransactionsInput
    connect?: VipInfoWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type GamesessionUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<GamesessionCreateWithoutTransactionInput, GamesessionUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: GamesessionCreateOrConnectWithoutTransactionInput
    upsert?: GamesessionUpsertWithoutTransactionInput
    disconnect?: GamesessionWhereInput | boolean
    delete?: GamesessionWhereInput | boolean
    connect?: GamesessionWhereUniqueInput
    update?: XOR<XOR<GamesessionUpdateToOneWithWhereWithoutTransactionInput, GamesessionUpdateWithoutTransactionInput>, GamesessionUncheckedUpdateWithoutTransactionInput>
  }

  export type ProfileUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<ProfileCreateWithoutTransactionsInput, ProfileUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTransactionsInput
    upsert?: ProfileUpsertWithoutTransactionsInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutTransactionsInput, ProfileUpdateWithoutTransactionsInput>, ProfileUncheckedUpdateWithoutTransactionsInput>
  }

  export type ProductUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionsInput
    upsert?: ProductUpsertWithoutTransactionsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTransactionsInput, ProductUpdateWithoutTransactionsInput>, ProductUncheckedUpdateWithoutTransactionsInput>
  }

  export type VipInfoUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<VipInfoCreateWithoutTransactionsInput, VipInfoUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: VipInfoCreateOrConnectWithoutTransactionsInput
    upsert?: VipInfoUpsertWithoutTransactionsInput
    disconnect?: VipInfoWhereInput | boolean
    delete?: VipInfoWhereInput | boolean
    connect?: VipInfoWhereUniqueInput
    update?: XOR<XOR<VipInfoUpdateToOneWithWhereWithoutTransactionsInput, VipInfoUpdateWithoutTransactionsInput>, VipInfoUncheckedUpdateWithoutTransactionsInput>
  }

  export type AchievementCreateNestedOneWithoutUserachievementInput = {
    create?: XOR<AchievementCreateWithoutUserachievementInput, AchievementUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserachievementInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserachievementInput = {
    create?: XOR<UserCreateWithoutUserachievementInput, UserUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserachievementInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementUpdateOneRequiredWithoutUserachievementNestedInput = {
    create?: XOR<AchievementCreateWithoutUserachievementInput, AchievementUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserachievementInput
    upsert?: AchievementUpsertWithoutUserachievementInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUserachievementInput, AchievementUpdateWithoutUserachievementInput>, AchievementUncheckedUpdateWithoutUserachievementInput>
  }

  export type UserUpdateOneRequiredWithoutUserachievementNestedInput = {
    create?: XOR<UserCreateWithoutUserachievementInput, UserUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserachievementInput
    upsert?: UserUpsertWithoutUserachievementInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserachievementInput, UserUpdateWithoutUserachievementInput>, UserUncheckedUpdateWithoutUserachievementInput>
  }

  export type RainHistoryCreateNestedOneWithoutRainBetInput = {
    create?: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainBetInput
    connect?: RainHistoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRainBetInput = {
    create?: XOR<UserCreateWithoutRainBetInput, UserUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainBetInput
    connect?: UserWhereUniqueInput
  }

  export type RainHistoryUpdateOneRequiredWithoutRainBetNestedInput = {
    create?: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainBetInput
    upsert?: RainHistoryUpsertWithoutRainBetInput
    connect?: RainHistoryWhereUniqueInput
    update?: XOR<XOR<RainHistoryUpdateToOneWithWhereWithoutRainBetInput, RainHistoryUpdateWithoutRainBetInput>, RainHistoryUncheckedUpdateWithoutRainBetInput>
  }

  export type UserUpdateOneRequiredWithoutRainBetNestedInput = {
    create?: XOR<UserCreateWithoutRainBetInput, UserUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainBetInput
    upsert?: UserUpsertWithoutRainBetInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRainBetInput, UserUpdateWithoutRainBetInput>, UserUncheckedUpdateWithoutRainBetInput>
  }

  export type RainBetCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutRainHistoryInput = {
    create?: XOR<UserCreateWithoutRainHistoryInput, UserUncheckedCreateWithoutRainHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type RainTipCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type RainBetUncheckedCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type RainTipUncheckedCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type RainBetUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutRainHistoryInput | RainBetUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutRainHistoryInput | RainBetUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutRainHistoryInput | RainBetUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutRainHistoryNestedInput = {
    create?: XOR<UserCreateWithoutRainHistoryInput, UserUncheckedCreateWithoutRainHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainHistoryInput
    upsert?: UserUpsertWithoutRainHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRainHistoryInput, UserUpdateWithoutRainHistoryInput>, UserUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainTipUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutRainHistoryInput | RainTipUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutRainHistoryInput | RainTipUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutRainHistoryInput | RainTipUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutRainHistoryInput | RainWinnerUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutRainHistoryInput | RainBetUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutRainHistoryInput | RainBetUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutRainHistoryInput | RainBetUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutRainHistoryInput | RainTipUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutRainHistoryInput | RainTipUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutRainHistoryInput | RainTipUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutRainHistoryInput | RainWinnerUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type RainHistoryCreateNestedOneWithoutRainTipInput = {
    create?: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainTipInput
    connect?: RainHistoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRainTipInput = {
    create?: XOR<UserCreateWithoutRainTipInput, UserUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainTipInput
    connect?: UserWhereUniqueInput
  }

  export type RainHistoryUpdateOneRequiredWithoutRainTipNestedInput = {
    create?: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainTipInput
    upsert?: RainHistoryUpsertWithoutRainTipInput
    connect?: RainHistoryWhereUniqueInput
    update?: XOR<XOR<RainHistoryUpdateToOneWithWhereWithoutRainTipInput, RainHistoryUpdateWithoutRainTipInput>, RainHistoryUncheckedUpdateWithoutRainTipInput>
  }

  export type UserUpdateOneRequiredWithoutRainTipNestedInput = {
    create?: XOR<UserCreateWithoutRainTipInput, UserUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainTipInput
    upsert?: UserUpsertWithoutRainTipInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRainTipInput, UserUpdateWithoutRainTipInput>, UserUncheckedUpdateWithoutRainTipInput>
  }

  export type RainHistoryCreateNestedOneWithoutRainWinnerInput = {
    create?: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainWinnerInput
    connect?: RainHistoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRainWinnerInput = {
    create?: XOR<UserCreateWithoutRainWinnerInput, UserUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainWinnerInput
    connect?: UserWhereUniqueInput
  }

  export type RainHistoryUpdateOneRequiredWithoutRainWinnerNestedInput = {
    create?: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainWinnerInput
    upsert?: RainHistoryUpsertWithoutRainWinnerInput
    connect?: RainHistoryWhereUniqueInput
    update?: XOR<XOR<RainHistoryUpdateToOneWithWhereWithoutRainWinnerInput, RainHistoryUpdateWithoutRainWinnerInput>, RainHistoryUncheckedUpdateWithoutRainWinnerInput>
  }

  export type UserUpdateOneRequiredWithoutRainWinnerNestedInput = {
    create?: XOR<UserCreateWithoutRainWinnerInput, UserUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainWinnerInput
    upsert?: UserUpsertWithoutRainWinnerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRainWinnerInput, UserUpdateWithoutRainWinnerInput>, UserUncheckedUpdateWithoutRainWinnerInput>
  }

  export type GamesessionCreateNestedManyWithoutVipInfoInput = {
    create?: XOR<GamesessionCreateWithoutVipInfoInput, GamesessionUncheckedCreateWithoutVipInfoInput> | GamesessionCreateWithoutVipInfoInput[] | GamesessionUncheckedCreateWithoutVipInfoInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutVipInfoInput | GamesessionCreateOrConnectWithoutVipInfoInput[]
    createMany?: GamesessionCreateManyVipInfoInputEnvelope
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
  }

  export type OperatorCreateNestedOneWithoutVipInfoInput = {
    create?: XOR<OperatorCreateWithoutVipInfoInput, OperatorUncheckedCreateWithoutVipInfoInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutVipInfoInput
    connect?: OperatorWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutVipInfoInput = {
    create?: XOR<TransactionCreateWithoutVipInfoInput, TransactionUncheckedCreateWithoutVipInfoInput> | TransactionCreateWithoutVipInfoInput[] | TransactionUncheckedCreateWithoutVipInfoInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVipInfoInput | TransactionCreateOrConnectWithoutVipInfoInput[]
    createMany?: TransactionCreateManyVipInfoInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutVipInfoInput = {
    create?: XOR<UserCreateWithoutVipInfoInput, UserUncheckedCreateWithoutVipInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutVipInfoInput
    connect?: UserWhereUniqueInput
  }

  export type GamesessionUncheckedCreateNestedManyWithoutVipInfoInput = {
    create?: XOR<GamesessionCreateWithoutVipInfoInput, GamesessionUncheckedCreateWithoutVipInfoInput> | GamesessionCreateWithoutVipInfoInput[] | GamesessionUncheckedCreateWithoutVipInfoInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutVipInfoInput | GamesessionCreateOrConnectWithoutVipInfoInput[]
    createMany?: GamesessionCreateManyVipInfoInputEnvelope
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutVipInfoInput = {
    create?: XOR<TransactionCreateWithoutVipInfoInput, TransactionUncheckedCreateWithoutVipInfoInput> | TransactionCreateWithoutVipInfoInput[] | TransactionUncheckedCreateWithoutVipInfoInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVipInfoInput | TransactionCreateOrConnectWithoutVipInfoInput[]
    createMany?: TransactionCreateManyVipInfoInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type GamesessionUpdateManyWithoutVipInfoNestedInput = {
    create?: XOR<GamesessionCreateWithoutVipInfoInput, GamesessionUncheckedCreateWithoutVipInfoInput> | GamesessionCreateWithoutVipInfoInput[] | GamesessionUncheckedCreateWithoutVipInfoInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutVipInfoInput | GamesessionCreateOrConnectWithoutVipInfoInput[]
    upsert?: GamesessionUpsertWithWhereUniqueWithoutVipInfoInput | GamesessionUpsertWithWhereUniqueWithoutVipInfoInput[]
    createMany?: GamesessionCreateManyVipInfoInputEnvelope
    set?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    disconnect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    delete?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    update?: GamesessionUpdateWithWhereUniqueWithoutVipInfoInput | GamesessionUpdateWithWhereUniqueWithoutVipInfoInput[]
    updateMany?: GamesessionUpdateManyWithWhereWithoutVipInfoInput | GamesessionUpdateManyWithWhereWithoutVipInfoInput[]
    deleteMany?: GamesessionScalarWhereInput | GamesessionScalarWhereInput[]
  }

  export type OperatorUpdateOneWithoutVipInfoNestedInput = {
    create?: XOR<OperatorCreateWithoutVipInfoInput, OperatorUncheckedCreateWithoutVipInfoInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutVipInfoInput
    upsert?: OperatorUpsertWithoutVipInfoInput
    disconnect?: OperatorWhereInput | boolean
    delete?: OperatorWhereInput | boolean
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutVipInfoInput, OperatorUpdateWithoutVipInfoInput>, OperatorUncheckedUpdateWithoutVipInfoInput>
  }

  export type TransactionUpdateManyWithoutVipInfoNestedInput = {
    create?: XOR<TransactionCreateWithoutVipInfoInput, TransactionUncheckedCreateWithoutVipInfoInput> | TransactionCreateWithoutVipInfoInput[] | TransactionUncheckedCreateWithoutVipInfoInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVipInfoInput | TransactionCreateOrConnectWithoutVipInfoInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutVipInfoInput | TransactionUpsertWithWhereUniqueWithoutVipInfoInput[]
    createMany?: TransactionCreateManyVipInfoInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutVipInfoInput | TransactionUpdateWithWhereUniqueWithoutVipInfoInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutVipInfoInput | TransactionUpdateManyWithWhereWithoutVipInfoInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUpdateOneWithoutVipInfoNestedInput = {
    create?: XOR<UserCreateWithoutVipInfoInput, UserUncheckedCreateWithoutVipInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutVipInfoInput
    upsert?: UserUpsertWithoutVipInfoInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVipInfoInput, UserUpdateWithoutVipInfoInput>, UserUncheckedUpdateWithoutVipInfoInput>
  }

  export type GamesessionUncheckedUpdateManyWithoutVipInfoNestedInput = {
    create?: XOR<GamesessionCreateWithoutVipInfoInput, GamesessionUncheckedCreateWithoutVipInfoInput> | GamesessionCreateWithoutVipInfoInput[] | GamesessionUncheckedCreateWithoutVipInfoInput[]
    connectOrCreate?: GamesessionCreateOrConnectWithoutVipInfoInput | GamesessionCreateOrConnectWithoutVipInfoInput[]
    upsert?: GamesessionUpsertWithWhereUniqueWithoutVipInfoInput | GamesessionUpsertWithWhereUniqueWithoutVipInfoInput[]
    createMany?: GamesessionCreateManyVipInfoInputEnvelope
    set?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    disconnect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    delete?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    connect?: GamesessionWhereUniqueInput | GamesessionWhereUniqueInput[]
    update?: GamesessionUpdateWithWhereUniqueWithoutVipInfoInput | GamesessionUpdateWithWhereUniqueWithoutVipInfoInput[]
    updateMany?: GamesessionUpdateManyWithWhereWithoutVipInfoInput | GamesessionUpdateManyWithWhereWithoutVipInfoInput[]
    deleteMany?: GamesessionScalarWhereInput | GamesessionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutVipInfoNestedInput = {
    create?: XOR<TransactionCreateWithoutVipInfoInput, TransactionUncheckedCreateWithoutVipInfoInput> | TransactionCreateWithoutVipInfoInput[] | TransactionUncheckedCreateWithoutVipInfoInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVipInfoInput | TransactionCreateOrConnectWithoutVipInfoInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutVipInfoInput | TransactionUpsertWithWhereUniqueWithoutVipInfoInput[]
    createMany?: TransactionCreateManyVipInfoInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutVipInfoInput | TransactionUpdateWithWhereUniqueWithoutVipInfoInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutVipInfoInput | TransactionUpdateManyWithWhereWithoutVipInfoInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumUserStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableFilter<$PrismaModel> | $Enums.UserStatus | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumUserStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumGameCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.GameCategory | EnumGameCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGameCategoryFilter<$PrismaModel> | $Enums.GameCategory
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumGameCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameCategory | EnumGameCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGameCategoryWithAggregatesFilter<$PrismaModel> | $Enums.GameCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameCategoryFilter<$PrismaModel>
    _max?: NestedEnumGameCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumChatChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelFilter<$PrismaModel> | $Enums.ChatChannel
  }

  export type NestedEnumChatChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelWithAggregatesFilter<$PrismaModel> | $Enums.ChatChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatChannelFilter<$PrismaModel>
    _max?: NestedEnumChatChannelFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UserachievementCreateWithoutAchievementInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserachievementInput
  }

  export type UserachievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
  }

  export type UserachievementCreateOrConnectWithoutAchievementInput = {
    where: UserachievementWhereUniqueInput
    create: XOR<UserachievementCreateWithoutAchievementInput, UserachievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserachievementCreateManyAchievementInputEnvelope = {
    data: UserachievementCreateManyAchievementInput | UserachievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type UserachievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserachievementWhereUniqueInput
    update: XOR<UserachievementUpdateWithoutAchievementInput, UserachievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserachievementCreateWithoutAchievementInput, UserachievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserachievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserachievementWhereUniqueInput
    data: XOR<UserachievementUpdateWithoutAchievementInput, UserachievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserachievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserachievementScalarWhereInput
    data: XOR<UserachievementUpdateManyMutationInput, UserachievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserachievementScalarWhereInput = {
    AND?: UserachievementScalarWhereInput | UserachievementScalarWhereInput[]
    OR?: UserachievementScalarWhereInput[]
    NOT?: UserachievementScalarWhereInput | UserachievementScalarWhereInput[]
    id?: StringFilter<"Userachievement"> | string
    progress?: IntFilter<"Userachievement"> | number
    isUnlocked?: BoolFilter<"Userachievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Userachievement"> | Date | string | null
    createdAt?: DateTimeFilter<"Userachievement"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Userachievement"> | Date | string | null
    userId?: StringFilter<"Userachievement"> | string
    achievementId?: StringFilter<"Userachievement"> | string
  }

  export type OperatorCreateWithoutOwnerInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    balance?: number
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    games?: GameCreateNestedManyWithoutOperatorInput
    products?: ProductCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    balance?: number
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    products?: ProductUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutOwnerInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput>
  }

  export type OperatorCreateManyOwnerInputEnvelope = {
    data: OperatorCreateManyOwnerInput | OperatorCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserProfileUseridtouserInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    operator: OperatorCreateNestedOneWithoutProfilesInput
    gamesession?: GamesessionCreateNestedManyWithoutProfileInput
    tournamententry?: TournamententryCreateNestedManyWithoutProfileInput
    transactions?: TransactionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserProfileUseridtouserInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    shopId: string
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutProfileInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserProfileUseridtouserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserProfileUseridtouserInput, ProfileUncheckedCreateWithoutUserProfileUseridtouserInput>
  }

  export type ProfileCreateManyUserProfileUseridtouserInputEnvelope = {
    data: ProfileCreateManyUserProfileUseridtouserInput | ProfileCreateManyUserProfileUseridtouserInput[]
    skipDuplicates?: boolean
  }

  export type RainBetCreateWithoutUserInput = {
    id?: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
    RainHistory: RainHistoryCreateNestedOneWithoutRainBetInput
  }

  export type RainBetUncheckedCreateWithoutUserInput = {
    id?: string
    rainHistoryId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetCreateOrConnectWithoutUserInput = {
    where: RainBetWhereUniqueInput
    create: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput>
  }

  export type RainBetCreateManyUserInputEnvelope = {
    data: RainBetCreateManyUserInput | RainBetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainHistoryCreateWithoutUserInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutUserInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput>
  }

  export type RainHistoryCreateManyUserInputEnvelope = {
    data: RainHistoryCreateManyUserInput | RainHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainTipCreateWithoutUserInput = {
    id?: string
    tipAmount: number
    tippedAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainTipInput
  }

  export type RainTipUncheckedCreateWithoutUserInput = {
    id?: string
    rainHistoryId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainTipCreateOrConnectWithoutUserInput = {
    where: RainTipWhereUniqueInput
    create: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput>
  }

  export type RainTipCreateManyUserInputEnvelope = {
    data: RainTipCreateManyUserInput | RainTipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainWinnerCreateWithoutUserInput = {
    id?: string
    wonAmount: number
    wonAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainWinnerInput
  }

  export type RainWinnerUncheckedCreateWithoutUserInput = {
    id?: string
    rainHistoryId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type RainWinnerCreateOrConnectWithoutUserInput = {
    where: RainWinnerWhereUniqueInput
    create: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput>
  }

  export type RainWinnerCreateManyUserInputEnvelope = {
    data: RainWinnerCreateManyUserInput | RainWinnerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlatformSessionCreateWithoutUserInput = {
    id?: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
  }

  export type PlatformSessionUncheckedCreateWithoutUserInput = {
    id?: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
  }

  export type PlatformSessionCreateOrConnectWithoutUserInput = {
    where: PlatformSessionWhereUniqueInput
    create: XOR<PlatformSessionCreateWithoutUserInput, PlatformSessionUncheckedCreateWithoutUserInput>
  }

  export type PlatformSessionCreateManyUserInputEnvelope = {
    data: PlatformSessionCreateManyUserInput | PlatformSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatmessageCreateWithoutUserInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chatroom?: ChatroomCreateNestedOneWithoutChatmessageInput
  }

  export type ChatmessageUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    roomId?: string | null
  }

  export type ChatmessageCreateOrConnectWithoutUserInput = {
    where: ChatmessageWhereUniqueInput
    create: XOR<ChatmessageCreateWithoutUserInput, ChatmessageUncheckedCreateWithoutUserInput>
  }

  export type ChatmessageCreateManyUserInputEnvelope = {
    data: ChatmessageCreateManyUserInput | ChatmessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutUserFriendshipFriendidtouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userFriendshipUseridtouser: UserCreateNestedOneWithoutFriendshipFriendshipUseridtouserInput
  }

  export type FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
  }

  export type FriendshipCreateOrConnectWithoutUserFriendshipFriendidtouserInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutUserFriendshipFriendidtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput>
  }

  export type FriendshipCreateManyUserFriendshipFriendidtouserInputEnvelope = {
    data: FriendshipCreateManyUserFriendshipFriendidtouserInput | FriendshipCreateManyUserFriendshipFriendidtouserInput[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutUserFriendshipUseridtouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userFriendshipFriendidtouser: UserCreateNestedOneWithoutFriendshipFriendshipFriendidtouserInput
  }

  export type FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    friendId: string
  }

  export type FriendshipCreateOrConnectWithoutUserFriendshipUseridtouserInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutUserFriendshipUseridtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput>
  }

  export type FriendshipCreateManyUserFriendshipUseridtouserInputEnvelope = {
    data: FriendshipCreateManyUserFriendshipUseridtouserInput | FriendshipCreateManyUserFriendshipUseridtouserInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutUserInput = {
    id?: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    organization: OrganizationCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
  }

  export type InvitationCreateOrConnectWithoutUserInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput>
  }

  export type InvitationCreateManyUserInputEnvelope = {
    data: InvitationCreateManyUserInput | InvitationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutUserInput = {
    id?: string
    role: string
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    role: string
    createdAt?: Date | string
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberCreateManyUserInputEnvelope = {
    data: MemberCreateManyUserInput | MemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TournamententryCreateWithoutUserInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTournamententryInput
    tournament: TournamentCreateNestedOneWithoutTournamententryInput
  }

  export type TournamententryUncheckedCreateWithoutUserInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    tournamentId: string
    profileId: string
  }

  export type TournamententryCreateOrConnectWithoutUserInput = {
    where: TournamententryWhereUniqueInput
    create: XOR<TournamententryCreateWithoutUserInput, TournamententryUncheckedCreateWithoutUserInput>
  }

  export type TournamententryCreateManyUserInputEnvelope = {
    data: TournamententryCreateManyUserInput | TournamententryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TwoFactorCreateWithoutUserInput = {
    id?: string
    secret: string
    backupCodes: string
  }

  export type TwoFactorUncheckedCreateWithoutUserInput = {
    id?: string
    secret: string
    backupCodes: string
  }

  export type TwoFactorCreateOrConnectWithoutUserInput = {
    where: TwoFactorWhereUniqueInput
    create: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorCreateManyUserInputEnvelope = {
    data: TwoFactorCreateManyUserInput | TwoFactorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserachievementCreateWithoutUserInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    achievement: AchievementCreateNestedOneWithoutUserachievementInput
  }

  export type UserachievementUncheckedCreateWithoutUserInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    achievementId: string
  }

  export type UserachievementCreateOrConnectWithoutUserInput = {
    where: UserachievementWhereUniqueInput
    create: XOR<UserachievementCreateWithoutUserInput, UserachievementUncheckedCreateWithoutUserInput>
  }

  export type UserachievementCreateManyUserInputEnvelope = {
    data: UserachievementCreateManyUserInput | UserachievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VipInfoCreateWithoutUserInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    gamesession?: GamesessionCreateNestedManyWithoutVipInfoInput
    operator?: OperatorCreateNestedOneWithoutVipInfoInput
    transactions?: TransactionCreateNestedManyWithoutVipInfoInput
  }

  export type VipInfoUncheckedCreateWithoutUserInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    operatorId?: string | null
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutVipInfoInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutVipInfoInput
  }

  export type VipInfoCreateOrConnectWithoutUserInput = {
    where: VipInfoWhereUniqueInput
    create: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput>
  }

  export type OperatorUpsertWithWhereUniqueWithoutOwnerInput = {
    where: OperatorWhereUniqueInput
    update: XOR<OperatorUpdateWithoutOwnerInput, OperatorUncheckedUpdateWithoutOwnerInput>
    create: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput>
  }

  export type OperatorUpdateWithWhereUniqueWithoutOwnerInput = {
    where: OperatorWhereUniqueInput
    data: XOR<OperatorUpdateWithoutOwnerInput, OperatorUncheckedUpdateWithoutOwnerInput>
  }

  export type OperatorUpdateManyWithWhereWithoutOwnerInput = {
    where: OperatorScalarWhereInput
    data: XOR<OperatorUpdateManyMutationInput, OperatorUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OperatorScalarWhereInput = {
    AND?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
    OR?: OperatorScalarWhereInput[]
    NOT?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
    id?: StringFilter<"Operator"> | string
    name?: StringFilter<"Operator"> | string
    slug?: StringFilter<"Operator"> | string
    logo?: StringNullableFilter<"Operator"> | string | null
    description?: StringNullableFilter<"Operator"> | string | null
    isActive?: BoolFilter<"Operator"> | boolean
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Operator"> | Date | string | null
    acceptedPayments?: StringNullableListFilter<"Operator">
    ownerId?: StringFilter<"Operator"> | string
    balance?: IntFilter<"Operator"> | number
  }

  export type ProfileUpsertWithWhereUniqueWithoutUserProfileUseridtouserInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutUserProfileUseridtouserInput, ProfileUncheckedUpdateWithoutUserProfileUseridtouserInput>
    create: XOR<ProfileCreateWithoutUserProfileUseridtouserInput, ProfileUncheckedCreateWithoutUserProfileUseridtouserInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutUserProfileUseridtouserInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutUserProfileUseridtouserInput, ProfileUncheckedUpdateWithoutUserProfileUseridtouserInput>
  }

  export type ProfileUpdateManyWithWhereWithoutUserProfileUseridtouserInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: StringFilter<"Profile"> | string
    balance?: IntFilter<"Profile"> | number
    xpEarned?: IntFilter<"Profile"> | number
    isActive?: BoolFilter<"Profile"> | boolean
    lastPlayed?: DateTimeNullableFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    phpId?: IntNullableFilter<"Profile"> | number | null
    userId?: StringFilter<"Profile"> | string
    currency?: StringFilter<"Profile"> | string
    shopId?: StringFilter<"Profile"> | string
  }

  export type RainBetUpsertWithWhereUniqueWithoutUserInput = {
    where: RainBetWhereUniqueInput
    update: XOR<RainBetUpdateWithoutUserInput, RainBetUncheckedUpdateWithoutUserInput>
    create: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput>
  }

  export type RainBetUpdateWithWhereUniqueWithoutUserInput = {
    where: RainBetWhereUniqueInput
    data: XOR<RainBetUpdateWithoutUserInput, RainBetUncheckedUpdateWithoutUserInput>
  }

  export type RainBetUpdateManyWithWhereWithoutUserInput = {
    where: RainBetScalarWhereInput
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyWithoutUserInput>
  }

  export type RainBetScalarWhereInput = {
    AND?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
    OR?: RainBetScalarWhereInput[]
    NOT?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
    id?: StringFilter<"RainBet"> | string
    rainHistoryId?: StringFilter<"RainBet"> | string
    userId?: StringFilter<"RainBet"> | string
    betAmount?: IntFilter<"RainBet"> | number
    odds?: IntFilter<"RainBet"> | number
    outcome?: StringNullableFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableFilter<"RainBet"> | Date | string | null
  }

  export type RainHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: RainHistoryWhereUniqueInput
    update: XOR<RainHistoryUpdateWithoutUserInput, RainHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput>
  }

  export type RainHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: RainHistoryWhereUniqueInput
    data: XOR<RainHistoryUpdateWithoutUserInput, RainHistoryUncheckedUpdateWithoutUserInput>
  }

  export type RainHistoryUpdateManyWithWhereWithoutUserInput = {
    where: RainHistoryScalarWhereInput
    data: XOR<RainHistoryUpdateManyMutationInput, RainHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type RainHistoryScalarWhereInput = {
    AND?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
    OR?: RainHistoryScalarWhereInput[]
    NOT?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
    id?: StringFilter<"RainHistory"> | string
    userId?: StringFilter<"RainHistory"> | string
    amount?: IntFilter<"RainHistory"> | number
    rainType?: StringFilter<"RainHistory"> | string
    createdAt?: DateTimeFilter<"RainHistory"> | Date | string
  }

  export type RainTipUpsertWithWhereUniqueWithoutUserInput = {
    where: RainTipWhereUniqueInput
    update: XOR<RainTipUpdateWithoutUserInput, RainTipUncheckedUpdateWithoutUserInput>
    create: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput>
  }

  export type RainTipUpdateWithWhereUniqueWithoutUserInput = {
    where: RainTipWhereUniqueInput
    data: XOR<RainTipUpdateWithoutUserInput, RainTipUncheckedUpdateWithoutUserInput>
  }

  export type RainTipUpdateManyWithWhereWithoutUserInput = {
    where: RainTipScalarWhereInput
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyWithoutUserInput>
  }

  export type RainTipScalarWhereInput = {
    AND?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
    OR?: RainTipScalarWhereInput[]
    NOT?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
    id?: StringFilter<"RainTip"> | string
    rainHistoryId?: StringFilter<"RainTip"> | string
    userId?: StringFilter<"RainTip"> | string
    tipAmount?: IntFilter<"RainTip"> | number
    tippedAt?: DateTimeFilter<"RainTip"> | Date | string
  }

  export type RainWinnerUpsertWithWhereUniqueWithoutUserInput = {
    where: RainWinnerWhereUniqueInput
    update: XOR<RainWinnerUpdateWithoutUserInput, RainWinnerUncheckedUpdateWithoutUserInput>
    create: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput>
  }

  export type RainWinnerUpdateWithWhereUniqueWithoutUserInput = {
    where: RainWinnerWhereUniqueInput
    data: XOR<RainWinnerUpdateWithoutUserInput, RainWinnerUncheckedUpdateWithoutUserInput>
  }

  export type RainWinnerUpdateManyWithWhereWithoutUserInput = {
    where: RainWinnerScalarWhereInput
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyWithoutUserInput>
  }

  export type RainWinnerScalarWhereInput = {
    AND?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
    OR?: RainWinnerScalarWhereInput[]
    NOT?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
    id?: StringFilter<"RainWinner"> | string
    rainHistoryId?: StringFilter<"RainWinner"> | string
    userId?: StringFilter<"RainWinner"> | string
    wonAmount?: IntFilter<"RainWinner"> | number
    wonAt?: DateTimeFilter<"RainWinner"> | Date | string
  }

  export type PlatformSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: PlatformSessionWhereUniqueInput
    update: XOR<PlatformSessionUpdateWithoutUserInput, PlatformSessionUncheckedUpdateWithoutUserInput>
    create: XOR<PlatformSessionCreateWithoutUserInput, PlatformSessionUncheckedCreateWithoutUserInput>
  }

  export type PlatformSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: PlatformSessionWhereUniqueInput
    data: XOR<PlatformSessionUpdateWithoutUserInput, PlatformSessionUncheckedUpdateWithoutUserInput>
  }

  export type PlatformSessionUpdateManyWithWhereWithoutUserInput = {
    where: PlatformSessionScalarWhereInput
    data: XOR<PlatformSessionUpdateManyMutationInput, PlatformSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type PlatformSessionScalarWhereInput = {
    AND?: PlatformSessionScalarWhereInput | PlatformSessionScalarWhereInput[]
    OR?: PlatformSessionScalarWhereInput[]
    NOT?: PlatformSessionScalarWhereInput | PlatformSessionScalarWhereInput[]
    id?: StringFilter<"PlatformSession"> | string
    userId?: StringFilter<"PlatformSession"> | string
    activeGameId?: StringNullableFilter<"PlatformSession"> | string | null
    ipAddress?: StringNullableFilter<"PlatformSession"> | string | null
    userAgent?: StringNullableFilter<"PlatformSession"> | string | null
    expiresAt?: DateTimeFilter<"PlatformSession"> | Date | string
    createdAt?: DateTimeFilter<"PlatformSession"> | Date | string
    refreshToken?: StringNullableFilter<"PlatformSession"> | string | null
    active?: BoolFilter<"PlatformSession"> | boolean
    token?: StringFilter<"PlatformSession"> | string
    updatedAt?: DateTimeNullableFilter<"PlatformSession"> | Date | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
  }

  export type ChatmessageUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatmessageWhereUniqueInput
    update: XOR<ChatmessageUpdateWithoutUserInput, ChatmessageUncheckedUpdateWithoutUserInput>
    create: XOR<ChatmessageCreateWithoutUserInput, ChatmessageUncheckedCreateWithoutUserInput>
  }

  export type ChatmessageUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatmessageWhereUniqueInput
    data: XOR<ChatmessageUpdateWithoutUserInput, ChatmessageUncheckedUpdateWithoutUserInput>
  }

  export type ChatmessageUpdateManyWithWhereWithoutUserInput = {
    where: ChatmessageScalarWhereInput
    data: XOR<ChatmessageUpdateManyMutationInput, ChatmessageUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatmessageScalarWhereInput = {
    AND?: ChatmessageScalarWhereInput | ChatmessageScalarWhereInput[]
    OR?: ChatmessageScalarWhereInput[]
    NOT?: ChatmessageScalarWhereInput | ChatmessageScalarWhereInput[]
    id?: StringFilter<"Chatmessage"> | string
    content?: StringFilter<"Chatmessage"> | string
    channel?: EnumChatChannelFilter<"Chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableFilter<"Chatmessage">
    createdAt?: DateTimeFilter<"Chatmessage"> | Date | string
    userId?: StringFilter<"Chatmessage"> | string
    roomId?: StringNullableFilter<"Chatmessage"> | string | null
  }

  export type FriendshipUpsertWithWhereUniqueWithoutUserFriendshipFriendidtouserInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutUserFriendshipFriendidtouserInput, FriendshipUncheckedUpdateWithoutUserFriendshipFriendidtouserInput>
    create: XOR<FriendshipCreateWithoutUserFriendshipFriendidtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipFriendidtouserInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutUserFriendshipFriendidtouserInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutUserFriendshipFriendidtouserInput, FriendshipUncheckedUpdateWithoutUserFriendshipFriendidtouserInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutUserFriendshipFriendidtouserInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserInput>
  }

  export type FriendshipScalarWhereInput = {
    AND?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    OR?: FriendshipScalarWhereInput[]
    NOT?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    id?: StringFilter<"Friendship"> | string
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Friendship"> | Date | string | null
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutUserFriendshipUseridtouserInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutUserFriendshipUseridtouserInput, FriendshipUncheckedUpdateWithoutUserFriendshipUseridtouserInput>
    create: XOR<FriendshipCreateWithoutUserFriendshipUseridtouserInput, FriendshipUncheckedCreateWithoutUserFriendshipUseridtouserInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutUserFriendshipUseridtouserInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutUserFriendshipUseridtouserInput, FriendshipUncheckedUpdateWithoutUserFriendshipUseridtouserInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutUserFriendshipUseridtouserInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserInput>
  }

  export type InvitationUpsertWithWhereUniqueWithoutUserInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutUserInput, InvitationUncheckedUpdateWithoutUserInput>
    create: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutUserInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutUserInput, InvitationUncheckedUpdateWithoutUserInput>
  }

  export type InvitationUpdateManyWithWhereWithoutUserInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutUserInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    organizationId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: StringNullableFilter<"Invitation"> | string | null
    status?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    inviterId?: StringFilter<"Invitation"> | string
  }

  export type MemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateManyWithWhereWithoutUserInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: StringFilter<"Member"> | string
    organizationId?: StringFilter<"Member"> | string
    userId?: StringFilter<"Member"> | string
    role?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
  }

  export type TournamententryUpsertWithWhereUniqueWithoutUserInput = {
    where: TournamententryWhereUniqueInput
    update: XOR<TournamententryUpdateWithoutUserInput, TournamententryUncheckedUpdateWithoutUserInput>
    create: XOR<TournamententryCreateWithoutUserInput, TournamententryUncheckedCreateWithoutUserInput>
  }

  export type TournamententryUpdateWithWhereUniqueWithoutUserInput = {
    where: TournamententryWhereUniqueInput
    data: XOR<TournamententryUpdateWithoutUserInput, TournamententryUncheckedUpdateWithoutUserInput>
  }

  export type TournamententryUpdateManyWithWhereWithoutUserInput = {
    where: TournamententryScalarWhereInput
    data: XOR<TournamententryUpdateManyMutationInput, TournamententryUncheckedUpdateManyWithoutUserInput>
  }

  export type TournamententryScalarWhereInput = {
    AND?: TournamententryScalarWhereInput | TournamententryScalarWhereInput[]
    OR?: TournamententryScalarWhereInput[]
    NOT?: TournamententryScalarWhereInput | TournamententryScalarWhereInput[]
    id?: StringFilter<"Tournamententry"> | string
    score?: IntFilter<"Tournamententry"> | number
    wagered?: IntFilter<"Tournamententry"> | number
    won?: IntFilter<"Tournamententry"> | number
    joinedAt?: DateTimeFilter<"Tournamententry"> | Date | string
    userId?: StringFilter<"Tournamententry"> | string
    tournamentId?: StringFilter<"Tournamententry"> | string
    profileId?: StringFilter<"Tournamententry"> | string
  }

  export type TwoFactorUpsertWithWhereUniqueWithoutUserInput = {
    where: TwoFactorWhereUniqueInput
    update: XOR<TwoFactorUpdateWithoutUserInput, TwoFactorUncheckedUpdateWithoutUserInput>
    create: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorUpdateWithWhereUniqueWithoutUserInput = {
    where: TwoFactorWhereUniqueInput
    data: XOR<TwoFactorUpdateWithoutUserInput, TwoFactorUncheckedUpdateWithoutUserInput>
  }

  export type TwoFactorUpdateManyWithWhereWithoutUserInput = {
    where: TwoFactorScalarWhereInput
    data: XOR<TwoFactorUpdateManyMutationInput, TwoFactorUncheckedUpdateManyWithoutUserInput>
  }

  export type TwoFactorScalarWhereInput = {
    AND?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
    OR?: TwoFactorScalarWhereInput[]
    NOT?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
    id?: StringFilter<"TwoFactor"> | string
    secret?: StringFilter<"TwoFactor"> | string
    backupCodes?: StringFilter<"TwoFactor"> | string
    userId?: StringFilter<"TwoFactor"> | string
  }

  export type UserachievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserachievementWhereUniqueInput
    update: XOR<UserachievementUpdateWithoutUserInput, UserachievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserachievementCreateWithoutUserInput, UserachievementUncheckedCreateWithoutUserInput>
  }

  export type UserachievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserachievementWhereUniqueInput
    data: XOR<UserachievementUpdateWithoutUserInput, UserachievementUncheckedUpdateWithoutUserInput>
  }

  export type UserachievementUpdateManyWithWhereWithoutUserInput = {
    where: UserachievementScalarWhereInput
    data: XOR<UserachievementUpdateManyMutationInput, UserachievementUncheckedUpdateManyWithoutUserInput>
  }

  export type VipInfoUpsertWithoutUserInput = {
    update: XOR<VipInfoUpdateWithoutUserInput, VipInfoUncheckedUpdateWithoutUserInput>
    create: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput>
    where?: VipInfoWhereInput
  }

  export type VipInfoUpdateToOneWithWhereWithoutUserInput = {
    where?: VipInfoWhereInput
    data: XOR<VipInfoUpdateWithoutUserInput, VipInfoUncheckedUpdateWithoutUserInput>
  }

  export type VipInfoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: GamesessionUpdateManyWithoutVipInfoNestedInput
    operator?: OperatorUpdateOneWithoutVipInfoNestedInput
    transactions?: TransactionUpdateManyWithoutVipInfoNestedInput
  }

  export type VipInfoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: GamesessionUncheckedUpdateManyWithoutVipInfoNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutVipInfoNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutOperatorInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOperatorInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOperatorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOperatorInput, UserUncheckedCreateWithoutOperatorInput>
  }

  export type ProfileCreateWithoutOperatorInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    userProfileUseridtouser: UserCreateNestedOneWithoutActiveProfileInput
    gamesession?: GamesessionCreateNestedManyWithoutProfileInput
    tournamententry?: TournamententryCreateNestedManyWithoutProfileInput
    transactions?: TransactionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutOperatorInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutProfileInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutOperatorInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput>
  }

  export type ProfileCreateManyOperatorInputEnvelope = {
    data: ProfileCreateManyOperatorInput | ProfileCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutOperatorInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    category?: $Enums.GameCategory
    gamesession?: GamesessionCreateNestedManyWithoutGameInput
    tournamentgame?: TournamentgameCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutOperatorInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    category?: $Enums.GameCategory
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutGameInput
    tournamentgame?: TournamentgameUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutOperatorInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput>
  }

  export type GameCreateManyOperatorInputEnvelope = {
    data: GameCreateManyOperatorInput | GameCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutOperatorInput = {
    id?: string
    title?: string
    description?: string
    url?: string
    type?: string
    bonusCode?: string | null
    bonusTotalInCredits?: number
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number
    isPromo?: boolean | null
    totalDiscountInCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    transactions?: TransactionCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOperatorInput = {
    id?: string
    title?: string
    description?: string
    url?: string
    type?: string
    bonusCode?: string | null
    bonusTotalInCredits?: number
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number
    isPromo?: boolean | null
    totalDiscountInCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOperatorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput>
  }

  export type ProductCreateManyOperatorInputEnvelope = {
    data: ProductCreateManyOperatorInput | ProductCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type TournamentCreateWithoutOperatorInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionCreateNestedManyWithoutTournamentInput
    tournamententry?: TournamententryCreateNestedManyWithoutTournamentInput
    tournamentgame?: TournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutOperatorInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: TournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutOperatorInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutOperatorInput, TournamentUncheckedCreateWithoutOperatorInput>
  }

  export type TournamentCreateManyOperatorInputEnvelope = {
    data: TournamentCreateManyOperatorInput | TournamentCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type VipInfoCreateWithoutOperatorInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    gamesession?: GamesessionCreateNestedManyWithoutVipInfoInput
    transactions?: TransactionCreateNestedManyWithoutVipInfoInput
    user?: UserCreateNestedOneWithoutVipInfoInput
  }

  export type VipInfoUncheckedCreateWithoutOperatorInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: string | null
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutVipInfoInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutVipInfoInput
  }

  export type VipInfoCreateOrConnectWithoutOperatorInput = {
    where: VipInfoWhereUniqueInput
    create: XOR<VipInfoCreateWithoutOperatorInput, VipInfoUncheckedCreateWithoutOperatorInput>
  }

  export type VipInfoCreateManyOperatorInputEnvelope = {
    data: VipInfoCreateManyOperatorInput | VipInfoCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOperatorInput = {
    update: XOR<UserUpdateWithoutOperatorInput, UserUncheckedUpdateWithoutOperatorInput>
    create: XOR<UserCreateWithoutOperatorInput, UserUncheckedCreateWithoutOperatorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOperatorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOperatorInput, UserUncheckedUpdateWithoutOperatorInput>
  }

  export type UserUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProfileUpsertWithWhereUniqueWithoutOperatorInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutOperatorInput, ProfileUncheckedUpdateWithoutOperatorInput>
    create: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutOperatorInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutOperatorInput, ProfileUncheckedUpdateWithoutOperatorInput>
  }

  export type ProfileUpdateManyWithWhereWithoutOperatorInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutOperatorInput>
  }

  export type GameUpsertWithWhereUniqueWithoutOperatorInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutOperatorInput, GameUncheckedUpdateWithoutOperatorInput>
    create: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput>
  }

  export type GameUpdateWithWhereUniqueWithoutOperatorInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutOperatorInput, GameUncheckedUpdateWithoutOperatorInput>
  }

  export type GameUpdateManyWithWhereWithoutOperatorInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutOperatorInput>
  }

  export type GameScalarWhereInput = {
    AND?: GameScalarWhereInput | GameScalarWhereInput[]
    OR?: GameScalarWhereInput[]
    NOT?: GameScalarWhereInput | GameScalarWhereInput[]
    id?: StringFilter<"Game"> | string
    name?: StringFilter<"Game"> | string
    title?: StringFilter<"Game"> | string
    temperature?: StringNullableFilter<"Game"> | string | null
    developer?: StringNullableFilter<"Game"> | string | null
    vipLevel?: IntNullableFilter<"Game"> | number | null
    isActive?: BoolNullableFilter<"Game"> | boolean | null
    device?: IntNullableFilter<"Game"> | number | null
    featured?: BoolNullableFilter<"Game"> | boolean | null
    gamebank?: StringNullableFilter<"Game"> | string | null
    bet?: FloatNullableFilter<"Game"> | number | null
    denomination?: FloatNullableFilter<"Game"> | number | null
    categoryTemp?: FloatNullableFilter<"Game"> | number | null
    originalId?: IntNullableFilter<"Game"> | number | null
    bids?: IntNullableFilter<"Game"> | number | null
    statIn?: FloatNullableFilter<"Game"> | number | null
    statOut?: FloatNullableFilter<"Game"> | number | null
    currentRtp?: FloatNullableFilter<"Game"> | number | null
    rtpStatIn?: FloatNullableFilter<"Game"> | number | null
    rtpStatOut?: FloatNullableFilter<"Game"> | number | null
    standardRtp?: FloatNullableFilter<"Game"> | number | null
    popularity?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot1?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot2?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot3?: FloatNullableFilter<"Game"> | number | null
    fireCount1?: FloatNullableFilter<"Game"> | number | null
    fireCount2?: FloatNullableFilter<"Game"> | number | null
    fireCount3?: FloatNullableFilter<"Game"> | number | null
    linesPercentConfigSpin?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigSpinBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonusBonus?: StringNullableFilter<"Game"> | string | null
    rezerv?: FloatNullableFilter<"Game"> | number | null
    cask?: FloatNullableFilter<"Game"> | number | null
    advanced?: StringNullableFilter<"Game"> | string | null
    scaleMode?: StringFilter<"Game"> | string
    slotViewState?: StringFilter<"Game"> | string
    view?: IntNullableFilter<"Game"> | number | null
    categoryId?: StringNullableFilter<"Game"> | string | null
    operatorId?: StringNullableFilter<"Game"> | string | null
    providerId?: StringNullableFilter<"Game"> | string | null
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Game"> | Date | string | null
    jackpotGroupId?: StringNullableFilter<"Game"> | string | null
    active?: BoolFilter<"Game"> | boolean
    password?: StringNullableFilter<"Game"> | string | null
    category?: EnumGameCategoryFilter<"Game"> | $Enums.GameCategory
  }

  export type ProductUpsertWithWhereUniqueWithoutOperatorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutOperatorInput, ProductUncheckedUpdateWithoutOperatorInput>
    create: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutOperatorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutOperatorInput, ProductUncheckedUpdateWithoutOperatorInput>
  }

  export type ProductUpdateManyWithWhereWithoutOperatorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutOperatorInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    url?: StringFilter<"Product"> | string
    type?: StringFilter<"Product"> | string
    bonusCode?: StringNullableFilter<"Product"> | string | null
    bonusTotalInCredits?: IntFilter<"Product"> | number
    priceInCents?: IntFilter<"Product"> | number
    amountToReceiveInCredits?: IntFilter<"Product"> | number
    bestValue?: IntFilter<"Product"> | number
    discountInCents?: IntFilter<"Product"> | number
    bonusSpins?: IntFilter<"Product"> | number
    isPromo?: BoolNullableFilter<"Product"> | boolean | null
    totalDiscountInCents?: IntFilter<"Product"> | number
    shopId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
  }

  export type TournamentUpsertWithWhereUniqueWithoutOperatorInput = {
    where: TournamentWhereUniqueInput
    update: XOR<TournamentUpdateWithoutOperatorInput, TournamentUncheckedUpdateWithoutOperatorInput>
    create: XOR<TournamentCreateWithoutOperatorInput, TournamentUncheckedCreateWithoutOperatorInput>
  }

  export type TournamentUpdateWithWhereUniqueWithoutOperatorInput = {
    where: TournamentWhereUniqueInput
    data: XOR<TournamentUpdateWithoutOperatorInput, TournamentUncheckedUpdateWithoutOperatorInput>
  }

  export type TournamentUpdateManyWithWhereWithoutOperatorInput = {
    where: TournamentScalarWhereInput
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyWithoutOperatorInput>
  }

  export type TournamentScalarWhereInput = {
    AND?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
    OR?: TournamentScalarWhereInput[]
    NOT?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
    id?: StringFilter<"Tournament"> | string
    name?: StringFilter<"Tournament"> | string
    description?: StringNullableFilter<"Tournament"> | string | null
    startTime?: DateTimeFilter<"Tournament"> | Date | string
    endTime?: DateTimeFilter<"Tournament"> | Date | string
    entryFee?: IntNullableFilter<"Tournament"> | number | null
    prizePool?: IntFilter<"Tournament"> | number
    isActive?: BoolFilter<"Tournament"> | boolean
    createdAt?: DateTimeFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    operatorId?: StringFilter<"Tournament"> | string
    leaderboard?: JsonNullableFilter<"Tournament">
  }

  export type VipInfoUpsertWithWhereUniqueWithoutOperatorInput = {
    where: VipInfoWhereUniqueInput
    update: XOR<VipInfoUpdateWithoutOperatorInput, VipInfoUncheckedUpdateWithoutOperatorInput>
    create: XOR<VipInfoCreateWithoutOperatorInput, VipInfoUncheckedCreateWithoutOperatorInput>
  }

  export type VipInfoUpdateWithWhereUniqueWithoutOperatorInput = {
    where: VipInfoWhereUniqueInput
    data: XOR<VipInfoUpdateWithoutOperatorInput, VipInfoUncheckedUpdateWithoutOperatorInput>
  }

  export type VipInfoUpdateManyWithWhereWithoutOperatorInput = {
    where: VipInfoScalarWhereInput
    data: XOR<VipInfoUpdateManyMutationInput, VipInfoUncheckedUpdateManyWithoutOperatorInput>
  }

  export type VipInfoScalarWhereInput = {
    AND?: VipInfoScalarWhereInput | VipInfoScalarWhereInput[]
    OR?: VipInfoScalarWhereInput[]
    NOT?: VipInfoScalarWhereInput | VipInfoScalarWhereInput[]
    id?: StringFilter<"VipInfo"> | string
    level?: IntFilter<"VipInfo"> | number
    deposit_exp?: IntFilter<"VipInfo"> | number
    bet_exp?: IntFilter<"VipInfo"> | number
    rank_bet_exp?: IntFilter<"VipInfo"> | number
    rank_deposit_exp?: IntFilter<"VipInfo"> | number
    rank_name?: StringNullableFilter<"VipInfo"> | string | null
    icon?: StringNullableFilter<"VipInfo"> | string | null
    exp_switch_type?: IntNullableFilter<"VipInfo"> | number | null
    now_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    level_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    now_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    level_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    telegram?: StringNullableFilter<"VipInfo"> | string | null
    is_protection?: BoolFilter<"VipInfo"> | boolean
    protection_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    protection_deposit_amount?: StringNullableFilter<"VipInfo"> | string | null
    protection_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    protection_bet_amount?: StringNullableFilter<"VipInfo"> | string | null
    protection_days?: IntNullableFilter<"VipInfo"> | number | null
    protection_switch?: IntNullableFilter<"VipInfo"> | number | null
    cycle_award_switch?: BoolFilter<"VipInfo"> | boolean
    level_award_switch?: BoolFilter<"VipInfo"> | boolean
    signin_award_switch?: BoolFilter<"VipInfo"> | boolean
    bet_award_switch?: BoolFilter<"VipInfo"> | boolean
    withdrawal_award_switch?: BoolFilter<"VipInfo"> | boolean
    unprotection_deposit_exp?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_deposit_amount?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_bet_exp?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_bet_amount?: StringNullableFilter<"VipInfo"> | string | null
    unprotection_days?: IntNullableFilter<"VipInfo"> | number | null
    unprotection_switch?: IntNullableFilter<"VipInfo"> | number | null
    main_currency?: StringNullableFilter<"VipInfo"> | string | null
    can_receive_level_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_rank_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_day_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_week_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_month_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_signin_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_bet_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_withdrawal_award?: BoolFilter<"VipInfo"> | boolean
    userid?: StringNullableFilter<"VipInfo"> | string | null
    free_spin_times?: IntNullableFilter<"VipInfo"> | number | null
    week_gift?: IntNullableFilter<"VipInfo"> | number | null
    month_gift?: IntNullableFilter<"VipInfo"> | number | null
    upgrade_gift?: IntNullableFilter<"VipInfo"> | number | null
    now_cash_back?: IntNullableFilter<"VipInfo"> | number | null
    yesterday_cash_back?: IntNullableFilter<"VipInfo"> | number | null
    history_cash_back?: IntNullableFilter<"VipInfo"> | number | null
    operatorId?: StringNullableFilter<"VipInfo"> | string | null
  }

  export type OperatorCreateWithoutProfilesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    games?: GameCreateNestedManyWithoutOperatorInput
    products?: ProductCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutProfilesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    ownerId: string
    balance?: number
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    products?: ProductUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutProfilesInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutProfilesInput, OperatorUncheckedCreateWithoutProfilesInput>
  }

  export type UserCreateWithoutActiveProfileInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActiveProfileInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActiveProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActiveProfileInput, UserUncheckedCreateWithoutActiveProfileInput>
  }

  export type GamesessionCreateWithoutProfileInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: ChatroomCreateNestedManyWithoutGamesessionInput
    game: GameCreateNestedOneWithoutGamesessionInput
    tournament?: TournamentCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
    VipInfo?: VipInfoCreateNestedOneWithoutGamesessionInput
  }

  export type GamesessionUncheckedCreateWithoutProfileInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    vipInfoId?: string | null
    chatroom?: ChatroomUncheckedCreateNestedManyWithoutGamesessionInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type GamesessionCreateOrConnectWithoutProfileInput = {
    where: GamesessionWhereUniqueInput
    create: XOR<GamesessionCreateWithoutProfileInput, GamesessionUncheckedCreateWithoutProfileInput>
  }

  export type GamesessionCreateManyProfileInputEnvelope = {
    data: GamesessionCreateManyProfileInput | GamesessionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type TournamententryCreateWithoutProfileInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    tournament: TournamentCreateNestedOneWithoutTournamententryInput
    user: UserCreateNestedOneWithoutTournamententryInput
  }

  export type TournamententryUncheckedCreateWithoutProfileInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    tournamentId: string
  }

  export type TournamententryCreateOrConnectWithoutProfileInput = {
    where: TournamententryWhereUniqueInput
    create: XOR<TournamententryCreateWithoutProfileInput, TournamententryUncheckedCreateWithoutProfileInput>
  }

  export type TournamententryCreateManyProfileInputEnvelope = {
    data: TournamententryCreateManyProfileInput | TournamententryCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutProfileInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    cashtag?: string | null
    gamesession?: GamesessionCreateNestedOneWithoutTransactionInput
    product?: ProductCreateNestedOneWithoutTransactionsInput
    vipInfo?: VipInfoCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutProfileInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    cashtag?: string | null
    productid?: string | null
    vipInfoId?: string | null
  }

  export type TransactionCreateOrConnectWithoutProfileInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput>
  }

  export type TransactionCreateManyProfileInputEnvelope = {
    data: TransactionCreateManyProfileInput | TransactionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type OperatorUpsertWithoutProfilesInput = {
    update: XOR<OperatorUpdateWithoutProfilesInput, OperatorUncheckedUpdateWithoutProfilesInput>
    create: XOR<OperatorCreateWithoutProfilesInput, OperatorUncheckedCreateWithoutProfilesInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutProfilesInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutProfilesInput, OperatorUncheckedUpdateWithoutProfilesInput>
  }

  export type OperatorUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    games?: GameUpdateManyWithoutOperatorNestedInput
    products?: ProductUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type UserUpsertWithoutActiveProfileInput = {
    update: XOR<UserUpdateWithoutActiveProfileInput, UserUncheckedUpdateWithoutActiveProfileInput>
    create: XOR<UserCreateWithoutActiveProfileInput, UserUncheckedCreateWithoutActiveProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActiveProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActiveProfileInput, UserUncheckedUpdateWithoutActiveProfileInput>
  }

  export type UserUpdateWithoutActiveProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActiveProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type GamesessionUpsertWithWhereUniqueWithoutProfileInput = {
    where: GamesessionWhereUniqueInput
    update: XOR<GamesessionUpdateWithoutProfileInput, GamesessionUncheckedUpdateWithoutProfileInput>
    create: XOR<GamesessionCreateWithoutProfileInput, GamesessionUncheckedCreateWithoutProfileInput>
  }

  export type GamesessionUpdateWithWhereUniqueWithoutProfileInput = {
    where: GamesessionWhereUniqueInput
    data: XOR<GamesessionUpdateWithoutProfileInput, GamesessionUncheckedUpdateWithoutProfileInput>
  }

  export type GamesessionUpdateManyWithWhereWithoutProfileInput = {
    where: GamesessionScalarWhereInput
    data: XOR<GamesessionUpdateManyMutationInput, GamesessionUncheckedUpdateManyWithoutProfileInput>
  }

  export type GamesessionScalarWhereInput = {
    AND?: GamesessionScalarWhereInput | GamesessionScalarWhereInput[]
    OR?: GamesessionScalarWhereInput[]
    NOT?: GamesessionScalarWhereInput | GamesessionScalarWhereInput[]
    id?: StringFilter<"Gamesession"> | string
    startTime?: DateTimeFilter<"Gamesession"> | Date | string
    endTime?: DateTimeNullableFilter<"Gamesession"> | Date | string | null
    betAmount?: IntNullableFilter<"Gamesession"> | number | null
    winAmount?: IntNullableFilter<"Gamesession"> | number | null
    xpEarned?: IntFilter<"Gamesession"> | number
    metadata?: JsonNullableFilter<"Gamesession">
    gameId?: StringFilter<"Gamesession"> | string
    tournamentId?: StringNullableFilter<"Gamesession"> | string | null
    active?: BoolFilter<"Gamesession"> | boolean
    profileId?: StringFilter<"Gamesession"> | string
    vipInfoId?: StringNullableFilter<"Gamesession"> | string | null
  }

  export type TournamententryUpsertWithWhereUniqueWithoutProfileInput = {
    where: TournamententryWhereUniqueInput
    update: XOR<TournamententryUpdateWithoutProfileInput, TournamententryUncheckedUpdateWithoutProfileInput>
    create: XOR<TournamententryCreateWithoutProfileInput, TournamententryUncheckedCreateWithoutProfileInput>
  }

  export type TournamententryUpdateWithWhereUniqueWithoutProfileInput = {
    where: TournamententryWhereUniqueInput
    data: XOR<TournamententryUpdateWithoutProfileInput, TournamententryUncheckedUpdateWithoutProfileInput>
  }

  export type TournamententryUpdateManyWithWhereWithoutProfileInput = {
    where: TournamententryScalarWhereInput
    data: XOR<TournamententryUpdateManyMutationInput, TournamententryUncheckedUpdateManyWithoutProfileInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutProfileInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutProfileInput, TransactionUncheckedUpdateWithoutProfileInput>
    create: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutProfileInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutProfileInput, TransactionUncheckedUpdateWithoutProfileInput>
  }

  export type TransactionUpdateManyWithWhereWithoutProfileInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutProfileInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntFilter<"Transaction"> | number
    amountCredits?: IntFilter<"Transaction"> | number
    buyerCashtag?: StringNullableFilter<"Transaction"> | string | null
    buyerUserId?: StringNullableFilter<"Transaction"> | string | null
    username?: StringNullableFilter<"Transaction"> | string | null
    cashiername?: StringNullableFilter<"Transaction"> | string | null
    cashierAvatar?: StringNullableFilter<"Transaction"> | string | null
    cashierId?: StringNullableFilter<"Transaction"> | string | null
    reference?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"Transaction">
    isRealMoney?: BoolFilter<"Transaction"> | boolean
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    paymentDetails?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    gameSessionId?: StringNullableFilter<"Transaction"> | string | null
    profileId?: StringNullableFilter<"Transaction"> | string | null
    cashtag?: StringNullableFilter<"Transaction"> | string | null
    productid?: StringNullableFilter<"Transaction"> | string | null
    vipInfoId?: StringNullableFilter<"Transaction"> | string | null
  }

  export type OperatorCreateWithoutGamesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    products?: ProductCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutGamesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    ownerId: string
    balance?: number
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    products?: ProductUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutGamesInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutGamesInput, OperatorUncheckedCreateWithoutGamesInput>
  }

  export type GamesessionCreateWithoutGameInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: ChatroomCreateNestedManyWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    tournament?: TournamentCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
    VipInfo?: VipInfoCreateNestedOneWithoutGamesessionInput
  }

  export type GamesessionUncheckedCreateWithoutGameInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: string | null
    active?: boolean
    profileId: string
    vipInfoId?: string | null
    chatroom?: ChatroomUncheckedCreateNestedManyWithoutGamesessionInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type GamesessionCreateOrConnectWithoutGameInput = {
    where: GamesessionWhereUniqueInput
    create: XOR<GamesessionCreateWithoutGameInput, GamesessionUncheckedCreateWithoutGameInput>
  }

  export type GamesessionCreateManyGameInputEnvelope = {
    data: GamesessionCreateManyGameInput | GamesessionCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type TournamentgameCreateWithoutGameInput = {
    id?: string
    multiplier?: number
    tournament: TournamentCreateNestedOneWithoutTournamentgameInput
  }

  export type TournamentgameUncheckedCreateWithoutGameInput = {
    id?: string
    multiplier?: number
    tournamentId: string
  }

  export type TournamentgameCreateOrConnectWithoutGameInput = {
    where: TournamentgameWhereUniqueInput
    create: XOR<TournamentgameCreateWithoutGameInput, TournamentgameUncheckedCreateWithoutGameInput>
  }

  export type TournamentgameCreateManyGameInputEnvelope = {
    data: TournamentgameCreateManyGameInput | TournamentgameCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type OperatorUpsertWithoutGamesInput = {
    update: XOR<OperatorUpdateWithoutGamesInput, OperatorUncheckedUpdateWithoutGamesInput>
    create: XOR<OperatorCreateWithoutGamesInput, OperatorUncheckedCreateWithoutGamesInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutGamesInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutGamesInput, OperatorUncheckedUpdateWithoutGamesInput>
  }

  export type OperatorUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    products?: ProductUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type GamesessionUpsertWithWhereUniqueWithoutGameInput = {
    where: GamesessionWhereUniqueInput
    update: XOR<GamesessionUpdateWithoutGameInput, GamesessionUncheckedUpdateWithoutGameInput>
    create: XOR<GamesessionCreateWithoutGameInput, GamesessionUncheckedCreateWithoutGameInput>
  }

  export type GamesessionUpdateWithWhereUniqueWithoutGameInput = {
    where: GamesessionWhereUniqueInput
    data: XOR<GamesessionUpdateWithoutGameInput, GamesessionUncheckedUpdateWithoutGameInput>
  }

  export type GamesessionUpdateManyWithWhereWithoutGameInput = {
    where: GamesessionScalarWhereInput
    data: XOR<GamesessionUpdateManyMutationInput, GamesessionUncheckedUpdateManyWithoutGameInput>
  }

  export type TournamentgameUpsertWithWhereUniqueWithoutGameInput = {
    where: TournamentgameWhereUniqueInput
    update: XOR<TournamentgameUpdateWithoutGameInput, TournamentgameUncheckedUpdateWithoutGameInput>
    create: XOR<TournamentgameCreateWithoutGameInput, TournamentgameUncheckedCreateWithoutGameInput>
  }

  export type TournamentgameUpdateWithWhereUniqueWithoutGameInput = {
    where: TournamentgameWhereUniqueInput
    data: XOR<TournamentgameUpdateWithoutGameInput, TournamentgameUncheckedUpdateWithoutGameInput>
  }

  export type TournamentgameUpdateManyWithWhereWithoutGameInput = {
    where: TournamentgameScalarWhereInput
    data: XOR<TournamentgameUpdateManyMutationInput, TournamentgameUncheckedUpdateManyWithoutGameInput>
  }

  export type TournamentgameScalarWhereInput = {
    AND?: TournamentgameScalarWhereInput | TournamentgameScalarWhereInput[]
    OR?: TournamentgameScalarWhereInput[]
    NOT?: TournamentgameScalarWhereInput | TournamentgameScalarWhereInput[]
    id?: StringFilter<"Tournamentgame"> | string
    multiplier?: FloatFilter<"Tournamentgame"> | number
    tournamentId?: StringFilter<"Tournamentgame"> | string
    gameId?: StringFilter<"Tournamentgame"> | string
  }

  export type InvitationCreateWithoutOrganizationInput = {
    id?: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type InvitationCreateOrConnectWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type InvitationCreateManyOrganizationInputEnvelope = {
    data: InvitationCreateManyOrganizationInput | InvitationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutOrganizationInput = {
    id?: string
    role: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    role: string
    createdAt?: Date | string
  }

  export type MemberCreateOrConnectWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberCreateManyOrganizationInputEnvelope = {
    data: MemberCreateManyOrganizationInput | MemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type InvitationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutOrganizationInput, InvitationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutOrganizationInput, InvitationUncheckedUpdateWithoutOrganizationInput>
  }

  export type InvitationUpdateManyWithWhereWithoutOrganizationInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type MemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutOrganizationInput, MemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutOrganizationInput, MemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type MemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationCreateWithoutMembersInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    metadata?: string | null
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    metadata?: string | null
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMembersInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembersInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
  }

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutMembersInput = {
    update: XOR<UserUpdateWithoutMembersInput, UserUncheckedUpdateWithoutMembersInput>
    create: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembersInput, UserUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutInvitationsInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
  }

  export type OrganizationCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    metadata?: string | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt?: Date | string
    metadata?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutInvitationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
  }

  export type UserUpsertWithoutInvitationsInput = {
    update: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutInvitationsInput = {
    update: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type OrganizationUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutTwofactorsInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTwofactorsInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTwofactorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTwofactorsInput, UserUncheckedCreateWithoutTwofactorsInput>
  }

  export type UserUpsertWithoutTwofactorsInput = {
    update: XOR<UserUpdateWithoutTwofactorsInput, UserUncheckedUpdateWithoutTwofactorsInput>
    create: XOR<UserCreateWithoutTwofactorsInput, UserUncheckedCreateWithoutTwofactorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTwofactorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTwofactorsInput, UserUncheckedUpdateWithoutTwofactorsInput>
  }

  export type UserUpdateWithoutTwofactorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTwofactorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ChatroomCreateWithoutChatmessageInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gamesession?: GamesessionCreateNestedOneWithoutChatroomInput
  }

  export type ChatroomUncheckedCreateWithoutChatmessageInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gameSessionId?: string | null
  }

  export type ChatroomCreateOrConnectWithoutChatmessageInput = {
    where: ChatroomWhereUniqueInput
    create: XOR<ChatroomCreateWithoutChatmessageInput, ChatroomUncheckedCreateWithoutChatmessageInput>
  }

  export type UserCreateWithoutChatmessageInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatmessageInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatmessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
  }

  export type ChatroomUpsertWithoutChatmessageInput = {
    update: XOR<ChatroomUpdateWithoutChatmessageInput, ChatroomUncheckedUpdateWithoutChatmessageInput>
    create: XOR<ChatroomCreateWithoutChatmessageInput, ChatroomUncheckedCreateWithoutChatmessageInput>
    where?: ChatroomWhereInput
  }

  export type ChatroomUpdateToOneWithWhereWithoutChatmessageInput = {
    where?: ChatroomWhereInput
    data: XOR<ChatroomUpdateWithoutChatmessageInput, ChatroomUncheckedUpdateWithoutChatmessageInput>
  }

  export type ChatroomUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamesession?: GamesessionUpdateOneWithoutChatroomNestedInput
  }

  export type ChatroomUncheckedUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutChatmessageInput = {
    update: XOR<UserUpdateWithoutChatmessageInput, UserUncheckedUpdateWithoutChatmessageInput>
    create: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatmessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatmessageInput, UserUncheckedUpdateWithoutChatmessageInput>
  }

  export type UserUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ChatmessageCreateWithoutChatroomInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutChatmessageInput
  }

  export type ChatmessageUncheckedCreateWithoutChatroomInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type ChatmessageCreateOrConnectWithoutChatroomInput = {
    where: ChatmessageWhereUniqueInput
    create: XOR<ChatmessageCreateWithoutChatroomInput, ChatmessageUncheckedCreateWithoutChatroomInput>
  }

  export type ChatmessageCreateManyChatroomInputEnvelope = {
    data: ChatmessageCreateManyChatroomInput | ChatmessageCreateManyChatroomInput[]
    skipDuplicates?: boolean
  }

  export type GamesessionCreateWithoutChatroomInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    game: GameCreateNestedOneWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    tournament?: TournamentCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
    VipInfo?: VipInfoCreateNestedOneWithoutGamesessionInput
  }

  export type GamesessionUncheckedCreateWithoutChatroomInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    vipInfoId?: string | null
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type GamesessionCreateOrConnectWithoutChatroomInput = {
    where: GamesessionWhereUniqueInput
    create: XOR<GamesessionCreateWithoutChatroomInput, GamesessionUncheckedCreateWithoutChatroomInput>
  }

  export type ChatmessageUpsertWithWhereUniqueWithoutChatroomInput = {
    where: ChatmessageWhereUniqueInput
    update: XOR<ChatmessageUpdateWithoutChatroomInput, ChatmessageUncheckedUpdateWithoutChatroomInput>
    create: XOR<ChatmessageCreateWithoutChatroomInput, ChatmessageUncheckedCreateWithoutChatroomInput>
  }

  export type ChatmessageUpdateWithWhereUniqueWithoutChatroomInput = {
    where: ChatmessageWhereUniqueInput
    data: XOR<ChatmessageUpdateWithoutChatroomInput, ChatmessageUncheckedUpdateWithoutChatroomInput>
  }

  export type ChatmessageUpdateManyWithWhereWithoutChatroomInput = {
    where: ChatmessageScalarWhereInput
    data: XOR<ChatmessageUpdateManyMutationInput, ChatmessageUncheckedUpdateManyWithoutChatroomInput>
  }

  export type GamesessionUpsertWithoutChatroomInput = {
    update: XOR<GamesessionUpdateWithoutChatroomInput, GamesessionUncheckedUpdateWithoutChatroomInput>
    create: XOR<GamesessionCreateWithoutChatroomInput, GamesessionUncheckedCreateWithoutChatroomInput>
    where?: GamesessionWhereInput
  }

  export type GamesessionUpdateToOneWithWhereWithoutChatroomInput = {
    where?: GamesessionWhereInput
    data: XOR<GamesessionUpdateWithoutChatroomInput, GamesessionUncheckedUpdateWithoutChatroomInput>
  }

  export type GamesessionUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: TournamentUpdateOneWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
    VipInfo?: VipInfoUpdateOneWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type UserCreateWithoutFriendshipFriendshipFriendidtouserInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriendshipFriendshipFriendidtouserInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriendshipFriendshipFriendidtouserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendshipFriendshipFriendidtouserInput, UserUncheckedCreateWithoutFriendshipFriendshipFriendidtouserInput>
  }

  export type UserCreateWithoutFriendshipFriendshipUseridtouserInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriendshipFriendshipUseridtouserInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriendshipFriendshipUseridtouserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendshipFriendshipUseridtouserInput, UserUncheckedCreateWithoutFriendshipFriendshipUseridtouserInput>
  }

  export type UserUpsertWithoutFriendshipFriendshipFriendidtouserInput = {
    update: XOR<UserUpdateWithoutFriendshipFriendshipFriendidtouserInput, UserUncheckedUpdateWithoutFriendshipFriendshipFriendidtouserInput>
    create: XOR<UserCreateWithoutFriendshipFriendshipFriendidtouserInput, UserUncheckedCreateWithoutFriendshipFriendshipFriendidtouserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendshipFriendshipFriendidtouserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendshipFriendshipFriendidtouserInput, UserUncheckedUpdateWithoutFriendshipFriendshipFriendidtouserInput>
  }

  export type UserUpdateWithoutFriendshipFriendshipFriendidtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendshipFriendshipFriendidtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutFriendshipFriendshipUseridtouserInput = {
    update: XOR<UserUpdateWithoutFriendshipFriendshipUseridtouserInput, UserUncheckedUpdateWithoutFriendshipFriendshipUseridtouserInput>
    create: XOR<UserCreateWithoutFriendshipFriendshipUseridtouserInput, UserUncheckedCreateWithoutFriendshipFriendshipUseridtouserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendshipFriendshipUseridtouserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendshipFriendshipUseridtouserInput, UserUncheckedUpdateWithoutFriendshipFriendshipUseridtouserInput>
  }

  export type UserUpdateWithoutFriendshipFriendshipUseridtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendshipFriendshipUseridtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ChatroomCreateWithoutGamesessionInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    chatmessage?: ChatmessageCreateNestedManyWithoutChatroomInput
  }

  export type ChatroomUncheckedCreateWithoutGamesessionInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutChatroomInput
  }

  export type ChatroomCreateOrConnectWithoutGamesessionInput = {
    where: ChatroomWhereUniqueInput
    create: XOR<ChatroomCreateWithoutGamesessionInput, ChatroomUncheckedCreateWithoutGamesessionInput>
  }

  export type ChatroomCreateManyGamesessionInputEnvelope = {
    data: ChatroomCreateManyGamesessionInput | ChatroomCreateManyGamesessionInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutGamesessionInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    category?: $Enums.GameCategory
    operator?: OperatorCreateNestedOneWithoutGamesInput
    tournamentgame?: TournamentgameCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutGamesessionInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    operatorId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    category?: $Enums.GameCategory
    tournamentgame?: TournamentgameUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutGamesessionInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutGamesessionInput, GameUncheckedCreateWithoutGamesessionInput>
  }

  export type ProfileCreateWithoutGamesessionInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    operator: OperatorCreateNestedOneWithoutProfilesInput
    userProfileUseridtouser: UserCreateNestedOneWithoutActiveProfileInput
    tournamententry?: TournamententryCreateNestedManyWithoutProfileInput
    transactions?: TransactionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutGamesessionInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    shopId: string
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutProfileInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutGamesessionInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutGamesessionInput, ProfileUncheckedCreateWithoutGamesessionInput>
  }

  export type TournamentCreateWithoutGamesessionInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    operator: OperatorCreateNestedOneWithoutTournamentsInput
    tournamententry?: TournamententryCreateNestedManyWithoutTournamentInput
    tournamentgame?: TournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutGamesessionInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: TournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutGamesessionInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutGamesessionInput, TournamentUncheckedCreateWithoutGamesessionInput>
  }

  export type TransactionCreateWithoutGamesessionInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    cashtag?: string | null
    profile?: ProfileCreateNestedOneWithoutTransactionsInput
    product?: ProductCreateNestedOneWithoutTransactionsInput
    vipInfo?: VipInfoCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutGamesessionInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    profileId?: string | null
    cashtag?: string | null
    productid?: string | null
    vipInfoId?: string | null
  }

  export type TransactionCreateOrConnectWithoutGamesessionInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput>
  }

  export type TransactionCreateManyGamesessionInputEnvelope = {
    data: TransactionCreateManyGamesessionInput | TransactionCreateManyGamesessionInput[]
    skipDuplicates?: boolean
  }

  export type VipInfoCreateWithoutGamesessionInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    operator?: OperatorCreateNestedOneWithoutVipInfoInput
    transactions?: TransactionCreateNestedManyWithoutVipInfoInput
    user?: UserCreateNestedOneWithoutVipInfoInput
  }

  export type VipInfoUncheckedCreateWithoutGamesessionInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: string | null
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    operatorId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutVipInfoInput
  }

  export type VipInfoCreateOrConnectWithoutGamesessionInput = {
    where: VipInfoWhereUniqueInput
    create: XOR<VipInfoCreateWithoutGamesessionInput, VipInfoUncheckedCreateWithoutGamesessionInput>
  }

  export type ChatroomUpsertWithWhereUniqueWithoutGamesessionInput = {
    where: ChatroomWhereUniqueInput
    update: XOR<ChatroomUpdateWithoutGamesessionInput, ChatroomUncheckedUpdateWithoutGamesessionInput>
    create: XOR<ChatroomCreateWithoutGamesessionInput, ChatroomUncheckedCreateWithoutGamesessionInput>
  }

  export type ChatroomUpdateWithWhereUniqueWithoutGamesessionInput = {
    where: ChatroomWhereUniqueInput
    data: XOR<ChatroomUpdateWithoutGamesessionInput, ChatroomUncheckedUpdateWithoutGamesessionInput>
  }

  export type ChatroomUpdateManyWithWhereWithoutGamesessionInput = {
    where: ChatroomScalarWhereInput
    data: XOR<ChatroomUpdateManyMutationInput, ChatroomUncheckedUpdateManyWithoutGamesessionInput>
  }

  export type ChatroomScalarWhereInput = {
    AND?: ChatroomScalarWhereInput | ChatroomScalarWhereInput[]
    OR?: ChatroomScalarWhereInput[]
    NOT?: ChatroomScalarWhereInput | ChatroomScalarWhereInput[]
    id?: StringFilter<"Chatroom"> | string
    name?: StringFilter<"Chatroom"> | string
    isGameRoom?: BoolFilter<"Chatroom"> | boolean
    createdAt?: DateTimeFilter<"Chatroom"> | Date | string
    gameSessionId?: StringNullableFilter<"Chatroom"> | string | null
  }

  export type GameUpsertWithoutGamesessionInput = {
    update: XOR<GameUpdateWithoutGamesessionInput, GameUncheckedUpdateWithoutGamesessionInput>
    create: XOR<GameCreateWithoutGamesessionInput, GameUncheckedCreateWithoutGamesessionInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutGamesessionInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutGamesessionInput, GameUncheckedUpdateWithoutGamesessionInput>
  }

  export type GameUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    operator?: OperatorUpdateOneWithoutGamesNestedInput
    tournamentgame?: TournamentgameUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    tournamentgame?: TournamentgameUncheckedUpdateManyWithoutGameNestedInput
  }

  export type ProfileUpsertWithoutGamesessionInput = {
    update: XOR<ProfileUpdateWithoutGamesessionInput, ProfileUncheckedUpdateWithoutGamesessionInput>
    create: XOR<ProfileCreateWithoutGamesessionInput, ProfileUncheckedCreateWithoutGamesessionInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutGamesessionInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutGamesessionInput, ProfileUncheckedUpdateWithoutGamesessionInput>
  }

  export type ProfileUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    operator?: OperatorUpdateOneRequiredWithoutProfilesNestedInput
    userProfileUseridtouser?: UserUpdateOneRequiredWithoutActiveProfileNestedInput
    tournamententry?: TournamententryUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tournamententry?: TournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type TournamentUpsertWithoutGamesessionInput = {
    update: XOR<TournamentUpdateWithoutGamesessionInput, TournamentUncheckedUpdateWithoutGamesessionInput>
    create: XOR<TournamentCreateWithoutGamesessionInput, TournamentUncheckedCreateWithoutGamesessionInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutGamesessionInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutGamesessionInput, TournamentUncheckedUpdateWithoutGamesessionInput>
  }

  export type TournamentUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    operator?: OperatorUpdateOneRequiredWithoutTournamentsNestedInput
    tournamententry?: TournamententryUpdateManyWithoutTournamentNestedInput
    tournamentgame?: TournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    tournamententry?: TournamententryUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: TournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutGamesessionInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutGamesessionInput, TransactionUncheckedUpdateWithoutGamesessionInput>
    create: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutGamesessionInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutGamesessionInput, TransactionUncheckedUpdateWithoutGamesessionInput>
  }

  export type TransactionUpdateManyWithWhereWithoutGamesessionInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutGamesessionInput>
  }

  export type VipInfoUpsertWithoutGamesessionInput = {
    update: XOR<VipInfoUpdateWithoutGamesessionInput, VipInfoUncheckedUpdateWithoutGamesessionInput>
    create: XOR<VipInfoCreateWithoutGamesessionInput, VipInfoUncheckedCreateWithoutGamesessionInput>
    where?: VipInfoWhereInput
  }

  export type VipInfoUpdateToOneWithWhereWithoutGamesessionInput = {
    where?: VipInfoWhereInput
    data: XOR<VipInfoUpdateWithoutGamesessionInput, VipInfoUncheckedUpdateWithoutGamesessionInput>
  }

  export type VipInfoUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: OperatorUpdateOneWithoutVipInfoNestedInput
    transactions?: TransactionUpdateManyWithoutVipInfoNestedInput
    user?: UserUpdateOneWithoutVipInfoNestedInput
  }

  export type VipInfoUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutVipInfoNestedInput
  }

  export type OperatorCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    games?: GameCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    ownerId: string
    balance?: number
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutProductsInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutProductsInput, OperatorUncheckedCreateWithoutProductsInput>
  }

  export type TransactionCreateWithoutProductInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    cashtag?: string | null
    gamesession?: GamesessionCreateNestedOneWithoutTransactionInput
    profile?: ProfileCreateNestedOneWithoutTransactionsInput
    vipInfo?: VipInfoCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutProductInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId?: string | null
    cashtag?: string | null
    vipInfoId?: string | null
  }

  export type TransactionCreateOrConnectWithoutProductInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput>
  }

  export type TransactionCreateManyProductInputEnvelope = {
    data: TransactionCreateManyProductInput | TransactionCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OperatorUpsertWithoutProductsInput = {
    update: XOR<OperatorUpdateWithoutProductsInput, OperatorUncheckedUpdateWithoutProductsInput>
    create: XOR<OperatorCreateWithoutProductsInput, OperatorUncheckedCreateWithoutProductsInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutProductsInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutProductsInput, OperatorUncheckedUpdateWithoutProductsInput>
  }

  export type OperatorUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    games?: GameUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutProductInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutProductInput, TransactionUncheckedUpdateWithoutProductInput>
    create: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutProductInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutProductInput, TransactionUncheckedUpdateWithoutProductInput>
  }

  export type TransactionUpdateManyWithWhereWithoutProductInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutProductInput>
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type GamesessionCreateWithoutTournamentInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: ChatroomCreateNestedManyWithoutGamesessionInput
    game: GameCreateNestedOneWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
    VipInfo?: VipInfoCreateNestedOneWithoutGamesessionInput
  }

  export type GamesessionUncheckedCreateWithoutTournamentInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    active?: boolean
    profileId: string
    vipInfoId?: string | null
    chatroom?: ChatroomUncheckedCreateNestedManyWithoutGamesessionInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type GamesessionCreateOrConnectWithoutTournamentInput = {
    where: GamesessionWhereUniqueInput
    create: XOR<GamesessionCreateWithoutTournamentInput, GamesessionUncheckedCreateWithoutTournamentInput>
  }

  export type GamesessionCreateManyTournamentInputEnvelope = {
    data: GamesessionCreateManyTournamentInput | GamesessionCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type OperatorCreateWithoutTournamentsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    games?: GameCreateNestedManyWithoutOperatorInput
    products?: ProductCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutTournamentsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    ownerId: string
    balance?: number
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    products?: ProductUncheckedCreateNestedManyWithoutOperatorInput
    VipInfo?: VipInfoUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutTournamentsInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutTournamentsInput, OperatorUncheckedCreateWithoutTournamentsInput>
  }

  export type TournamententryCreateWithoutTournamentInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTournamententryInput
    user: UserCreateNestedOneWithoutTournamententryInput
  }

  export type TournamententryUncheckedCreateWithoutTournamentInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    profileId: string
  }

  export type TournamententryCreateOrConnectWithoutTournamentInput = {
    where: TournamententryWhereUniqueInput
    create: XOR<TournamententryCreateWithoutTournamentInput, TournamententryUncheckedCreateWithoutTournamentInput>
  }

  export type TournamententryCreateManyTournamentInputEnvelope = {
    data: TournamententryCreateManyTournamentInput | TournamententryCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type TournamentgameCreateWithoutTournamentInput = {
    id?: string
    multiplier?: number
    game: GameCreateNestedOneWithoutTournamentgameInput
  }

  export type TournamentgameUncheckedCreateWithoutTournamentInput = {
    id?: string
    multiplier?: number
    gameId: string
  }

  export type TournamentgameCreateOrConnectWithoutTournamentInput = {
    where: TournamentgameWhereUniqueInput
    create: XOR<TournamentgameCreateWithoutTournamentInput, TournamentgameUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentgameCreateManyTournamentInputEnvelope = {
    data: TournamentgameCreateManyTournamentInput | TournamentgameCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type GamesessionUpsertWithWhereUniqueWithoutTournamentInput = {
    where: GamesessionWhereUniqueInput
    update: XOR<GamesessionUpdateWithoutTournamentInput, GamesessionUncheckedUpdateWithoutTournamentInput>
    create: XOR<GamesessionCreateWithoutTournamentInput, GamesessionUncheckedCreateWithoutTournamentInput>
  }

  export type GamesessionUpdateWithWhereUniqueWithoutTournamentInput = {
    where: GamesessionWhereUniqueInput
    data: XOR<GamesessionUpdateWithoutTournamentInput, GamesessionUncheckedUpdateWithoutTournamentInput>
  }

  export type GamesessionUpdateManyWithWhereWithoutTournamentInput = {
    where: GamesessionScalarWhereInput
    data: XOR<GamesessionUpdateManyMutationInput, GamesessionUncheckedUpdateManyWithoutTournamentInput>
  }

  export type OperatorUpsertWithoutTournamentsInput = {
    update: XOR<OperatorUpdateWithoutTournamentsInput, OperatorUncheckedUpdateWithoutTournamentsInput>
    create: XOR<OperatorCreateWithoutTournamentsInput, OperatorUncheckedCreateWithoutTournamentsInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutTournamentsInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutTournamentsInput, OperatorUncheckedUpdateWithoutTournamentsInput>
  }

  export type OperatorUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    games?: GameUpdateManyWithoutOperatorNestedInput
    products?: ProductUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type TournamententryUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamententryWhereUniqueInput
    update: XOR<TournamententryUpdateWithoutTournamentInput, TournamententryUncheckedUpdateWithoutTournamentInput>
    create: XOR<TournamententryCreateWithoutTournamentInput, TournamententryUncheckedCreateWithoutTournamentInput>
  }

  export type TournamententryUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamententryWhereUniqueInput
    data: XOR<TournamententryUpdateWithoutTournamentInput, TournamententryUncheckedUpdateWithoutTournamentInput>
  }

  export type TournamententryUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamententryScalarWhereInput
    data: XOR<TournamententryUpdateManyMutationInput, TournamententryUncheckedUpdateManyWithoutTournamentInput>
  }

  export type TournamentgameUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamentgameWhereUniqueInput
    update: XOR<TournamentgameUpdateWithoutTournamentInput, TournamentgameUncheckedUpdateWithoutTournamentInput>
    create: XOR<TournamentgameCreateWithoutTournamentInput, TournamentgameUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentgameUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamentgameWhereUniqueInput
    data: XOR<TournamentgameUpdateWithoutTournamentInput, TournamentgameUncheckedUpdateWithoutTournamentInput>
  }

  export type TournamentgameUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamentgameScalarWhereInput
    data: XOR<TournamentgameUpdateManyMutationInput, TournamentgameUncheckedUpdateManyWithoutTournamentInput>
  }

  export type ProfileCreateWithoutTournamententryInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    operator: OperatorCreateNestedOneWithoutProfilesInput
    userProfileUseridtouser: UserCreateNestedOneWithoutActiveProfileInput
    gamesession?: GamesessionCreateNestedManyWithoutProfileInput
    transactions?: TransactionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutTournamententryInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    shopId: string
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutProfileInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutTournamententryInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutTournamententryInput, ProfileUncheckedCreateWithoutTournamententryInput>
  }

  export type TournamentCreateWithoutTournamententryInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionCreateNestedManyWithoutTournamentInput
    operator: OperatorCreateNestedOneWithoutTournamentsInput
    tournamentgame?: TournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutTournamententryInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: TournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutTournamententryInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutTournamententryInput, TournamentUncheckedCreateWithoutTournamententryInput>
  }

  export type UserCreateWithoutTournamententryInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTournamententryInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTournamententryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTournamententryInput, UserUncheckedCreateWithoutTournamententryInput>
  }

  export type ProfileUpsertWithoutTournamententryInput = {
    update: XOR<ProfileUpdateWithoutTournamententryInput, ProfileUncheckedUpdateWithoutTournamententryInput>
    create: XOR<ProfileCreateWithoutTournamententryInput, ProfileUncheckedCreateWithoutTournamententryInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutTournamententryInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutTournamententryInput, ProfileUncheckedUpdateWithoutTournamententryInput>
  }

  export type ProfileUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    operator?: OperatorUpdateOneRequiredWithoutProfilesNestedInput
    userProfileUseridtouser?: UserUpdateOneRequiredWithoutActiveProfileNestedInput
    gamesession?: GamesessionUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: GamesessionUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type TournamentUpsertWithoutTournamententryInput = {
    update: XOR<TournamentUpdateWithoutTournamententryInput, TournamentUncheckedUpdateWithoutTournamententryInput>
    create: XOR<TournamentCreateWithoutTournamententryInput, TournamentUncheckedCreateWithoutTournamententryInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutTournamententryInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutTournamententryInput, TournamentUncheckedUpdateWithoutTournamententryInput>
  }

  export type TournamentUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUpdateManyWithoutTournamentNestedInput
    operator?: OperatorUpdateOneRequiredWithoutTournamentsNestedInput
    tournamentgame?: TournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: TournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type UserUpsertWithoutTournamententryInput = {
    update: XOR<UserUpdateWithoutTournamententryInput, UserUncheckedUpdateWithoutTournamententryInput>
    create: XOR<UserCreateWithoutTournamententryInput, UserUncheckedCreateWithoutTournamententryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTournamententryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTournamententryInput, UserUncheckedUpdateWithoutTournamententryInput>
  }

  export type UserUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type GameCreateWithoutTournamentgameInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    category?: $Enums.GameCategory
    operator?: OperatorCreateNestedOneWithoutGamesInput
    gamesession?: GamesessionCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutTournamentgameInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    operatorId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    category?: $Enums.GameCategory
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutTournamentgameInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutTournamentgameInput, GameUncheckedCreateWithoutTournamentgameInput>
  }

  export type TournamentCreateWithoutTournamentgameInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionCreateNestedManyWithoutTournamentInput
    operator: OperatorCreateNestedOneWithoutTournamentsInput
    tournamententry?: TournamententryCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutTournamentgameInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutTournamentgameInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutTournamentgameInput, TournamentUncheckedCreateWithoutTournamentgameInput>
  }

  export type GameUpsertWithoutTournamentgameInput = {
    update: XOR<GameUpdateWithoutTournamentgameInput, GameUncheckedUpdateWithoutTournamentgameInput>
    create: XOR<GameCreateWithoutTournamentgameInput, GameUncheckedCreateWithoutTournamentgameInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutTournamentgameInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutTournamentgameInput, GameUncheckedUpdateWithoutTournamentgameInput>
  }

  export type GameUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    operator?: OperatorUpdateOneWithoutGamesNestedInput
    gamesession?: GamesessionUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    gamesession?: GamesessionUncheckedUpdateManyWithoutGameNestedInput
  }

  export type TournamentUpsertWithoutTournamentgameInput = {
    update: XOR<TournamentUpdateWithoutTournamentgameInput, TournamentUncheckedUpdateWithoutTournamentgameInput>
    create: XOR<TournamentCreateWithoutTournamentgameInput, TournamentUncheckedCreateWithoutTournamentgameInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutTournamentgameInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutTournamentgameInput, TournamentUncheckedUpdateWithoutTournamentgameInput>
  }

  export type TournamentUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUpdateManyWithoutTournamentNestedInput
    operator?: OperatorUpdateOneRequiredWithoutTournamentsNestedInput
    tournamententry?: TournamententryUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type GamesessionCreateWithoutTransactionInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: ChatroomCreateNestedManyWithoutGamesessionInput
    game: GameCreateNestedOneWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    tournament?: TournamentCreateNestedOneWithoutGamesessionInput
    VipInfo?: VipInfoCreateNestedOneWithoutGamesessionInput
  }

  export type GamesessionUncheckedCreateWithoutTransactionInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    vipInfoId?: string | null
    chatroom?: ChatroomUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type GamesessionCreateOrConnectWithoutTransactionInput = {
    where: GamesessionWhereUniqueInput
    create: XOR<GamesessionCreateWithoutTransactionInput, GamesessionUncheckedCreateWithoutTransactionInput>
  }

  export type ProfileCreateWithoutTransactionsInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    operator: OperatorCreateNestedOneWithoutProfilesInput
    userProfileUseridtouser: UserCreateNestedOneWithoutActiveProfileInput
    gamesession?: GamesessionCreateNestedManyWithoutProfileInput
    tournamententry?: TournamententryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutTransactionsInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    shopId: string
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutTransactionsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutTransactionsInput, ProfileUncheckedCreateWithoutTransactionsInput>
  }

  export type ProductCreateWithoutTransactionsInput = {
    id?: string
    title?: string
    description?: string
    url?: string
    type?: string
    bonusCode?: string | null
    bonusTotalInCredits?: number
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number
    isPromo?: boolean | null
    totalDiscountInCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operator?: OperatorCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutTransactionsInput = {
    id?: string
    title?: string
    description?: string
    url?: string
    type?: string
    bonusCode?: string | null
    bonusTotalInCredits?: number
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number
    isPromo?: boolean | null
    totalDiscountInCents?: number
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ProductCreateOrConnectWithoutTransactionsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput>
  }

  export type VipInfoCreateWithoutTransactionsInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    gamesession?: GamesessionCreateNestedManyWithoutVipInfoInput
    operator?: OperatorCreateNestedOneWithoutVipInfoInput
    user?: UserCreateNestedOneWithoutVipInfoInput
  }

  export type VipInfoUncheckedCreateWithoutTransactionsInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: string | null
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
    operatorId?: string | null
    gamesession?: GamesessionUncheckedCreateNestedManyWithoutVipInfoInput
  }

  export type VipInfoCreateOrConnectWithoutTransactionsInput = {
    where: VipInfoWhereUniqueInput
    create: XOR<VipInfoCreateWithoutTransactionsInput, VipInfoUncheckedCreateWithoutTransactionsInput>
  }

  export type GamesessionUpsertWithoutTransactionInput = {
    update: XOR<GamesessionUpdateWithoutTransactionInput, GamesessionUncheckedUpdateWithoutTransactionInput>
    create: XOR<GamesessionCreateWithoutTransactionInput, GamesessionUncheckedCreateWithoutTransactionInput>
    where?: GamesessionWhereInput
  }

  export type GamesessionUpdateToOneWithWhereWithoutTransactionInput = {
    where?: GamesessionWhereInput
    data: XOR<GamesessionUpdateWithoutTransactionInput, GamesessionUncheckedUpdateWithoutTransactionInput>
  }

  export type GamesessionUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: ChatroomUpdateManyWithoutGamesessionNestedInput
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: TournamentUpdateOneWithoutGamesessionNestedInput
    VipInfo?: VipInfoUpdateOneWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    chatroom?: ChatroomUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type ProfileUpsertWithoutTransactionsInput = {
    update: XOR<ProfileUpdateWithoutTransactionsInput, ProfileUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ProfileCreateWithoutTransactionsInput, ProfileUncheckedCreateWithoutTransactionsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutTransactionsInput, ProfileUncheckedUpdateWithoutTransactionsInput>
  }

  export type ProfileUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    operator?: OperatorUpdateOneRequiredWithoutProfilesNestedInput
    userProfileUseridtouser?: UserUpdateOneRequiredWithoutActiveProfileNestedInput
    gamesession?: GamesessionUpdateManyWithoutProfileNestedInput
    tournamententry?: TournamententryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: GamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProductUpsertWithoutTransactionsInput = {
    update: XOR<ProductUpdateWithoutTransactionsInput, ProductUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTransactionsInput, ProductUncheckedUpdateWithoutTransactionsInput>
  }

  export type ProductUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: IntFieldUpdateOperationsInput | number
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: IntFieldUpdateOperationsInput | number
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: IntFieldUpdateOperationsInput | number
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: IntFieldUpdateOperationsInput | number
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VipInfoUpsertWithoutTransactionsInput = {
    update: XOR<VipInfoUpdateWithoutTransactionsInput, VipInfoUncheckedUpdateWithoutTransactionsInput>
    create: XOR<VipInfoCreateWithoutTransactionsInput, VipInfoUncheckedCreateWithoutTransactionsInput>
    where?: VipInfoWhereInput
  }

  export type VipInfoUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: VipInfoWhereInput
    data: XOR<VipInfoUpdateWithoutTransactionsInput, VipInfoUncheckedUpdateWithoutTransactionsInput>
  }

  export type VipInfoUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: GamesessionUpdateManyWithoutVipInfoNestedInput
    operator?: OperatorUpdateOneWithoutVipInfoNestedInput
    user?: UserUpdateOneWithoutVipInfoNestedInput
  }

  export type VipInfoUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: GamesessionUncheckedUpdateManyWithoutVipInfoNestedInput
  }

  export type AchievementCreateWithoutUserachievementInput = {
    id?: string
    name: string
    description: string
    targetXp: number
    reward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AchievementUncheckedCreateWithoutUserachievementInput = {
    id?: string
    name: string
    description: string
    targetXp: number
    reward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AchievementCreateOrConnectWithoutUserachievementInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserachievementInput, AchievementUncheckedCreateWithoutUserachievementInput>
  }

  export type UserCreateWithoutUserachievementInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserachievementInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserachievementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserachievementInput, UserUncheckedCreateWithoutUserachievementInput>
  }

  export type AchievementUpsertWithoutUserachievementInput = {
    update: XOR<AchievementUpdateWithoutUserachievementInput, AchievementUncheckedUpdateWithoutUserachievementInput>
    create: XOR<AchievementCreateWithoutUserachievementInput, AchievementUncheckedCreateWithoutUserachievementInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUserachievementInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUserachievementInput, AchievementUncheckedUpdateWithoutUserachievementInput>
  }

  export type AchievementUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AchievementUncheckedUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutUserachievementInput = {
    update: XOR<UserUpdateWithoutUserachievementInput, UserUncheckedUpdateWithoutUserachievementInput>
    create: XOR<UserCreateWithoutUserachievementInput, UserUncheckedCreateWithoutUserachievementInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserachievementInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserachievementInput, UserUncheckedUpdateWithoutUserachievementInput>
  }

  export type UserUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RainHistoryCreateWithoutRainBetInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutRainBetInput = {
    id?: string
    userId: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutRainBetInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
  }

  export type UserCreateWithoutRainBetInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRainBetInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRainBetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRainBetInput, UserUncheckedCreateWithoutRainBetInput>
  }

  export type RainHistoryUpsertWithoutRainBetInput = {
    update: XOR<RainHistoryUpdateWithoutRainBetInput, RainHistoryUncheckedUpdateWithoutRainBetInput>
    create: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
    where?: RainHistoryWhereInput
  }

  export type RainHistoryUpdateToOneWithWhereWithoutRainBetInput = {
    where?: RainHistoryWhereInput
    data: XOR<RainHistoryUpdateWithoutRainBetInput, RainHistoryUncheckedUpdateWithoutRainBetInput>
  }

  export type RainHistoryUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type UserUpsertWithoutRainBetInput = {
    update: XOR<UserUpdateWithoutRainBetInput, UserUncheckedUpdateWithoutRainBetInput>
    create: XOR<UserCreateWithoutRainBetInput, UserUncheckedCreateWithoutRainBetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRainBetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRainBetInput, UserUncheckedUpdateWithoutRainBetInput>
  }

  export type UserUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RainBetCreateWithoutRainHistoryInput = {
    id?: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
    user: UserCreateNestedOneWithoutRainBetInput
  }

  export type RainBetUncheckedCreateWithoutRainHistoryInput = {
    id?: string
    userId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetCreateOrConnectWithoutRainHistoryInput = {
    where: RainBetWhereUniqueInput
    create: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainBetCreateManyRainHistoryInputEnvelope = {
    data: RainBetCreateManyRainHistoryInput | RainBetCreateManyRainHistoryInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRainHistoryInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRainHistoryInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRainHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRainHistoryInput, UserUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainTipCreateWithoutRainHistoryInput = {
    id?: string
    tipAmount: number
    tippedAt?: Date | string
    user: UserCreateNestedOneWithoutRainTipInput
  }

  export type RainTipUncheckedCreateWithoutRainHistoryInput = {
    id?: string
    userId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainTipCreateOrConnectWithoutRainHistoryInput = {
    where: RainTipWhereUniqueInput
    create: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainTipCreateManyRainHistoryInputEnvelope = {
    data: RainTipCreateManyRainHistoryInput | RainTipCreateManyRainHistoryInput[]
    skipDuplicates?: boolean
  }

  export type RainWinnerCreateWithoutRainHistoryInput = {
    id?: string
    wonAmount: number
    wonAt?: Date | string
    user: UserCreateNestedOneWithoutRainWinnerInput
  }

  export type RainWinnerUncheckedCreateWithoutRainHistoryInput = {
    id?: string
    userId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type RainWinnerCreateOrConnectWithoutRainHistoryInput = {
    where: RainWinnerWhereUniqueInput
    create: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainWinnerCreateManyRainHistoryInputEnvelope = {
    data: RainWinnerCreateManyRainHistoryInput | RainWinnerCreateManyRainHistoryInput[]
    skipDuplicates?: boolean
  }

  export type RainBetUpsertWithWhereUniqueWithoutRainHistoryInput = {
    where: RainBetWhereUniqueInput
    update: XOR<RainBetUpdateWithoutRainHistoryInput, RainBetUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainBetUpdateWithWhereUniqueWithoutRainHistoryInput = {
    where: RainBetWhereUniqueInput
    data: XOR<RainBetUpdateWithoutRainHistoryInput, RainBetUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainBetUpdateManyWithWhereWithoutRainHistoryInput = {
    where: RainBetScalarWhereInput
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyWithoutRainHistoryInput>
  }

  export type UserUpsertWithoutRainHistoryInput = {
    update: XOR<UserUpdateWithoutRainHistoryInput, UserUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<UserCreateWithoutRainHistoryInput, UserUncheckedCreateWithoutRainHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRainHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRainHistoryInput, UserUncheckedUpdateWithoutRainHistoryInput>
  }

  export type UserUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RainTipUpsertWithWhereUniqueWithoutRainHistoryInput = {
    where: RainTipWhereUniqueInput
    update: XOR<RainTipUpdateWithoutRainHistoryInput, RainTipUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainTipUpdateWithWhereUniqueWithoutRainHistoryInput = {
    where: RainTipWhereUniqueInput
    data: XOR<RainTipUpdateWithoutRainHistoryInput, RainTipUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainTipUpdateManyWithWhereWithoutRainHistoryInput = {
    where: RainTipScalarWhereInput
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyWithoutRainHistoryInput>
  }

  export type RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput = {
    where: RainWinnerWhereUniqueInput
    update: XOR<RainWinnerUpdateWithoutRainHistoryInput, RainWinnerUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput = {
    where: RainWinnerWhereUniqueInput
    data: XOR<RainWinnerUpdateWithoutRainHistoryInput, RainWinnerUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainWinnerUpdateManyWithWhereWithoutRainHistoryInput = {
    where: RainWinnerScalarWhereInput
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyWithoutRainHistoryInput>
  }

  export type RainHistoryCreateWithoutRainTipInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    user: UserCreateNestedOneWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutRainTipInput = {
    id?: string
    userId: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutRainTipInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
  }

  export type UserCreateWithoutRainTipInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRainTipInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRainTipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRainTipInput, UserUncheckedCreateWithoutRainTipInput>
  }

  export type RainHistoryUpsertWithoutRainTipInput = {
    update: XOR<RainHistoryUpdateWithoutRainTipInput, RainHistoryUncheckedUpdateWithoutRainTipInput>
    create: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
    where?: RainHistoryWhereInput
  }

  export type RainHistoryUpdateToOneWithWhereWithoutRainTipInput = {
    where?: RainHistoryWhereInput
    data: XOR<RainHistoryUpdateWithoutRainTipInput, RainHistoryUncheckedUpdateWithoutRainTipInput>
  }

  export type RainHistoryUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type UserUpsertWithoutRainTipInput = {
    update: XOR<UserUpdateWithoutRainTipInput, UserUncheckedUpdateWithoutRainTipInput>
    create: XOR<UserCreateWithoutRainTipInput, UserUncheckedCreateWithoutRainTipInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRainTipInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRainTipInput, UserUncheckedUpdateWithoutRainTipInput>
  }

  export type UserUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RainHistoryCreateWithoutRainWinnerInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    user: UserCreateNestedOneWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutRainWinnerInput = {
    id?: string
    userId: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutRainWinnerInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
  }

  export type UserCreateWithoutRainWinnerInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRainWinnerInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRainWinnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRainWinnerInput, UserUncheckedCreateWithoutRainWinnerInput>
  }

  export type RainHistoryUpsertWithoutRainWinnerInput = {
    update: XOR<RainHistoryUpdateWithoutRainWinnerInput, RainHistoryUncheckedUpdateWithoutRainWinnerInput>
    create: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
    where?: RainHistoryWhereInput
  }

  export type RainHistoryUpdateToOneWithWhereWithoutRainWinnerInput = {
    where?: RainHistoryWhereInput
    data: XOR<RainHistoryUpdateWithoutRainWinnerInput, RainHistoryUncheckedUpdateWithoutRainWinnerInput>
  }

  export type RainHistoryUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type UserUpsertWithoutRainWinnerInput = {
    update: XOR<UserUpdateWithoutRainWinnerInput, UserUncheckedUpdateWithoutRainWinnerInput>
    create: XOR<UserCreateWithoutRainWinnerInput, UserUncheckedCreateWithoutRainWinnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRainWinnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRainWinnerInput, UserUncheckedUpdateWithoutRainWinnerInput>
  }

  export type UserUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateOneWithoutUserNestedInput
  }

  export type GamesessionCreateWithoutVipInfoInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: ChatroomCreateNestedManyWithoutGamesessionInput
    game: GameCreateNestedOneWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    tournament?: TournamentCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
  }

  export type GamesessionUncheckedCreateWithoutVipInfoInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    chatroom?: ChatroomUncheckedCreateNestedManyWithoutGamesessionInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type GamesessionCreateOrConnectWithoutVipInfoInput = {
    where: GamesessionWhereUniqueInput
    create: XOR<GamesessionCreateWithoutVipInfoInput, GamesessionUncheckedCreateWithoutVipInfoInput>
  }

  export type GamesessionCreateManyVipInfoInputEnvelope = {
    data: GamesessionCreateManyVipInfoInput | GamesessionCreateManyVipInfoInput[]
    skipDuplicates?: boolean
  }

  export type OperatorCreateWithoutVipInfoInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    games?: GameCreateNestedManyWithoutOperatorInput
    products?: ProductCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutVipInfoInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    ownerId: string
    balance?: number
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    products?: ProductUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutVipInfoInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutVipInfoInput, OperatorUncheckedCreateWithoutVipInfoInput>
  }

  export type TransactionCreateWithoutVipInfoInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    cashtag?: string | null
    gamesession?: GamesessionCreateNestedOneWithoutTransactionInput
    profile?: ProfileCreateNestedOneWithoutTransactionsInput
    product?: ProductCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutVipInfoInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId?: string | null
    cashtag?: string | null
    productid?: string | null
  }

  export type TransactionCreateOrConnectWithoutVipInfoInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutVipInfoInput, TransactionUncheckedCreateWithoutVipInfoInput>
  }

  export type TransactionCreateManyVipInfoInputEnvelope = {
    data: TransactionCreateManyVipInfoInput | TransactionCreateManyVipInfoInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutVipInfoInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    userachievement?: UserachievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVipInfoInput = {
    id?: string
    sbId?: string | null
    name?: string | null
    email: string
    emailVerified?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    displayUsername?: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    vipInfoId?: string | null
    lastDailySpin?: Date | string | null
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUserProfileUseridtouserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    sessions?: PlatformSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: ChatmessageUncheckedCreateNestedManyWithoutUserInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipFriendidtouserInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedCreateNestedManyWithoutUserFriendshipUseridtouserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: TournamententryUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    userachievement?: UserachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVipInfoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVipInfoInput, UserUncheckedCreateWithoutVipInfoInput>
  }

  export type GamesessionUpsertWithWhereUniqueWithoutVipInfoInput = {
    where: GamesessionWhereUniqueInput
    update: XOR<GamesessionUpdateWithoutVipInfoInput, GamesessionUncheckedUpdateWithoutVipInfoInput>
    create: XOR<GamesessionCreateWithoutVipInfoInput, GamesessionUncheckedCreateWithoutVipInfoInput>
  }

  export type GamesessionUpdateWithWhereUniqueWithoutVipInfoInput = {
    where: GamesessionWhereUniqueInput
    data: XOR<GamesessionUpdateWithoutVipInfoInput, GamesessionUncheckedUpdateWithoutVipInfoInput>
  }

  export type GamesessionUpdateManyWithWhereWithoutVipInfoInput = {
    where: GamesessionScalarWhereInput
    data: XOR<GamesessionUpdateManyMutationInput, GamesessionUncheckedUpdateManyWithoutVipInfoInput>
  }

  export type OperatorUpsertWithoutVipInfoInput = {
    update: XOR<OperatorUpdateWithoutVipInfoInput, OperatorUncheckedUpdateWithoutVipInfoInput>
    create: XOR<OperatorCreateWithoutVipInfoInput, OperatorUncheckedCreateWithoutVipInfoInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutVipInfoInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutVipInfoInput, OperatorUncheckedUpdateWithoutVipInfoInput>
  }

  export type OperatorUpdateWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    games?: GameUpdateManyWithoutOperatorNestedInput
    products?: ProductUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutVipInfoInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutVipInfoInput, TransactionUncheckedUpdateWithoutVipInfoInput>
    create: XOR<TransactionCreateWithoutVipInfoInput, TransactionUncheckedCreateWithoutVipInfoInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutVipInfoInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutVipInfoInput, TransactionUncheckedUpdateWithoutVipInfoInput>
  }

  export type TransactionUpdateManyWithWhereWithoutVipInfoInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutVipInfoInput>
  }

  export type UserUpsertWithoutVipInfoInput = {
    update: XOR<UserUpdateWithoutVipInfoInput, UserUncheckedUpdateWithoutVipInfoInput>
    create: XOR<UserCreateWithoutVipInfoInput, UserUncheckedCreateWithoutVipInfoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVipInfoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVipInfoInput, UserUncheckedUpdateWithoutVipInfoInput>
  }

  export type UserUpdateWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    sbId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    displayUsername?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: PlatformSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendshipFriendshipFriendidtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserNestedInput
    friendshipFriendshipUseridtouser?: FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: UserachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserachievementCreateManyAchievementInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
  }

  export type UserachievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserachievementNestedInput
  }

  export type UserachievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserachievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OperatorCreateManyOwnerInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    acceptedPayments?: OperatorCreateacceptedPaymentsInput | string[]
    balance?: number
  }

  export type ProfileCreateManyUserProfileUseridtouserInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    shopId: string
  }

  export type RainBetCreateManyUserInput = {
    id?: string
    rainHistoryId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainHistoryCreateManyUserInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
  }

  export type RainTipCreateManyUserInput = {
    id?: string
    rainHistoryId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainWinnerCreateManyUserInput = {
    id?: string
    rainHistoryId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type PlatformSessionCreateManyUserInput = {
    id?: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ChatmessageCreateManyUserInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    roomId?: string | null
  }

  export type FriendshipCreateManyUserFriendshipFriendidtouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
  }

  export type FriendshipCreateManyUserFriendshipUseridtouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    friendId: string
  }

  export type InvitationCreateManyUserInput = {
    id?: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
  }

  export type MemberCreateManyUserInput = {
    id?: string
    organizationId: string
    role: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TournamententryCreateManyUserInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    tournamentId: string
    profileId: string
  }

  export type TwoFactorCreateManyUserInput = {
    id?: string
    secret: string
    backupCodes: string
  }

  export type UserachievementCreateManyUserInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    achievementId: string
  }

  export type OperatorUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    balance?: IntFieldUpdateOperationsInput | number
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    games?: GameUpdateManyWithoutOperatorNestedInput
    products?: ProductUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    balance?: IntFieldUpdateOperationsInput | number
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    products?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutOperatorNestedInput
    VipInfo?: VipInfoUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedPayments?: OperatorUpdateacceptedPaymentsInput | string[]
    balance?: IntFieldUpdateOperationsInput | number
  }

  export type ProfileUpdateWithoutUserProfileUseridtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    operator?: OperatorUpdateOneRequiredWithoutProfilesNestedInput
    gamesession?: GamesessionUpdateManyWithoutProfileNestedInput
    tournamententry?: TournamententryUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserProfileUseridtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: GamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateManyWithoutUserProfileUseridtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type RainBetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainBetNestedInput
  }

  export type RainBetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainTipNestedInput
  }

  export type RainTipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainWinnerNestedInput
  }

  export type RainWinnerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlatformSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlatformSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatmessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom?: ChatroomUpdateOneWithoutChatmessageNestedInput
  }

  export type ChatmessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatmessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FriendshipUpdateWithoutUserFriendshipFriendidtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userFriendshipUseridtouser?: UserUpdateOneRequiredWithoutFriendshipFriendshipUseridtouserNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutUserFriendshipFriendidtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FriendshipUncheckedUpdateManyWithoutUserFriendshipFriendidtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FriendshipUpdateWithoutUserFriendshipUseridtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userFriendshipFriendidtouser?: UserUpdateOneRequiredWithoutFriendshipFriendshipFriendidtouserNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutUserFriendshipUseridtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type FriendshipUncheckedUpdateManyWithoutUserFriendshipUseridtouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type InvitationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamententryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTournamententryNestedInput
    tournament?: TournamentUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type TournamententryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamententryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
  }

  export type UserachievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievement?: AchievementUpdateOneRequiredWithoutUserachievementNestedInput
  }

  export type UserachievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type UserachievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateManyOperatorInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
  }

  export type GameCreateManyOperatorInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    category?: $Enums.GameCategory
  }

  export type ProductCreateManyOperatorInput = {
    id?: string
    title?: string
    description?: string
    url?: string
    type?: string
    bonusCode?: string | null
    bonusTotalInCredits?: number
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number
    isPromo?: boolean | null
    totalDiscountInCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TournamentCreateManyOperatorInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VipInfoCreateManyOperatorInput = {
    id?: string
    level?: number
    deposit_exp?: number
    bet_exp?: number
    rank_bet_exp?: number
    rank_deposit_exp?: number
    rank_name?: string | null
    icon?: string | null
    exp_switch_type?: number | null
    now_deposit_exp?: string | null
    level_deposit_exp?: string | null
    now_bet_exp?: string | null
    level_bet_exp?: string | null
    telegram?: string | null
    is_protection?: boolean
    protection_deposit_exp?: string | null
    protection_deposit_amount?: string | null
    protection_bet_exp?: string | null
    protection_bet_amount?: string | null
    protection_days?: number | null
    protection_switch?: number | null
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: string | null
    unprotection_deposit_amount?: string | null
    unprotection_bet_exp?: string | null
    unprotection_bet_amount?: string | null
    unprotection_days?: number | null
    unprotection_switch?: number | null
    main_currency?: string | null
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: string | null
    free_spin_times?: number | null
    week_gift?: number | null
    month_gift?: number | null
    upgrade_gift?: number | null
    now_cash_back?: number | null
    yesterday_cash_back?: number | null
    history_cash_back?: number | null
  }

  export type ProfileUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    userProfileUseridtouser?: UserUpdateOneRequiredWithoutActiveProfileNestedInput
    gamesession?: GamesessionUpdateManyWithoutProfileNestedInput
    tournamententry?: TournamententryUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    gamesession?: GamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type GameUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    gamesession?: GamesessionUpdateManyWithoutGameNestedInput
    tournamentgame?: TournamentgameUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    gamesession?: GamesessionUncheckedUpdateManyWithoutGameNestedInput
    tournamentgame?: TournamentgameUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
  }

  export type ProductUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: IntFieldUpdateOperationsInput | number
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: IntFieldUpdateOperationsInput | number
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: IntFieldUpdateOperationsInput | number
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: IntFieldUpdateOperationsInput | number
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: IntFieldUpdateOperationsInput | number
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: IntFieldUpdateOperationsInput | number
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TournamentUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUpdateManyWithoutTournamentNestedInput
    tournamententry?: TournamententryUpdateManyWithoutTournamentNestedInput
    tournamentgame?: TournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: GamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamententry?: TournamententryUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: TournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VipInfoUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: GamesessionUpdateManyWithoutVipInfoNestedInput
    transactions?: TransactionUpdateManyWithoutVipInfoNestedInput
    user?: UserUpdateOneWithoutVipInfoNestedInput
  }

  export type VipInfoUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: GamesessionUncheckedUpdateManyWithoutVipInfoNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutVipInfoNestedInput
  }

  export type VipInfoUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    exp_switch_type?: NullableIntFieldUpdateOperationsInput | number | null
    now_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    now_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    level_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    protection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    protection_days?: NullableIntFieldUpdateOperationsInput | number | null
    protection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_deposit_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_exp?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_bet_amount?: NullableStringFieldUpdateOperationsInput | string | null
    unprotection_days?: NullableIntFieldUpdateOperationsInput | number | null
    unprotection_switch?: NullableIntFieldUpdateOperationsInput | number | null
    main_currency?: NullableStringFieldUpdateOperationsInput | string | null
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    userid?: NullableStringFieldUpdateOperationsInput | string | null
    free_spin_times?: NullableIntFieldUpdateOperationsInput | number | null
    week_gift?: NullableIntFieldUpdateOperationsInput | number | null
    month_gift?: NullableIntFieldUpdateOperationsInput | number | null
    upgrade_gift?: NullableIntFieldUpdateOperationsInput | number | null
    now_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    yesterday_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
    history_cash_back?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GamesessionCreateManyProfileInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    vipInfoId?: string | null
  }

  export type TournamententryCreateManyProfileInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    tournamentId: string
  }

  export type TransactionCreateManyProfileInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    cashtag?: string | null
    productid?: string | null
    vipInfoId?: string | null
  }

  export type GamesessionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: ChatroomUpdateManyWithoutGamesessionNestedInput
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: TournamentUpdateOneWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
    VipInfo?: VipInfoUpdateOneWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    chatroom?: ChatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TournamententryUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneRequiredWithoutTournamententryNestedInput
    user?: UserUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type TournamententryUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamententryUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: GamesessionUpdateOneWithoutTransactionNestedInput
    product?: ProductUpdateOneWithoutTransactionsNestedInput
    vipInfo?: VipInfoUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GamesessionCreateManyGameInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: string | null
    active?: boolean
    profileId: string
    vipInfoId?: string | null
  }

  export type TournamentgameCreateManyGameInput = {
    id?: string
    multiplier?: number
    tournamentId: string
  }

  export type GamesessionUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: ChatroomUpdateManyWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: TournamentUpdateOneWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
    VipInfo?: VipInfoUpdateOneWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    chatroom?: ChatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TournamentgameUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournament?: TournamentUpdateOneRequiredWithoutTournamentgameNestedInput
  }

  export type TournamentgameUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentgameUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type InvitationCreateManyOrganizationInput = {
    id?: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type MemberCreateManyOrganizationInput = {
    id?: string
    userId: string
    role: string
    createdAt?: Date | string
  }

  export type InvitationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type InvitationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type MemberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatmessageCreateManyChatroomInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type ChatmessageUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatmessageNestedInput
  }

  export type ChatmessageUncheckedUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatmessageUncheckedUpdateManyWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatroomCreateManyGamesessionInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
  }

  export type TransactionCreateManyGamesessionInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    profileId?: string | null
    cashtag?: string | null
    productid?: string | null
    vipInfoId?: string | null
  }

  export type ChatroomUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatmessage?: ChatmessageUpdateManyWithoutChatroomNestedInput
  }

  export type ChatroomUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatmessage?: ChatmessageUncheckedUpdateManyWithoutChatroomNestedInput
  }

  export type ChatroomUncheckedUpdateManyWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutTransactionsNestedInput
    product?: ProductUpdateOneWithoutTransactionsNestedInput
    vipInfo?: VipInfoUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateManyProductInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId?: string | null
    cashtag?: string | null
    vipInfoId?: string | null
  }

  export type TransactionUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: GamesessionUpdateOneWithoutTransactionNestedInput
    profile?: ProfileUpdateOneWithoutTransactionsNestedInput
    vipInfo?: VipInfoUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GamesessionCreateManyTournamentInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    active?: boolean
    profileId: string
    vipInfoId?: string | null
  }

  export type TournamententryCreateManyTournamentInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    profileId: string
  }

  export type TournamentgameCreateManyTournamentInput = {
    id?: string
    multiplier?: number
    gameId: string
  }

  export type GamesessionUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: ChatroomUpdateManyWithoutGamesessionNestedInput
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
    VipInfo?: VipInfoUpdateOneWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    chatroom?: ChatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TournamententryUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTournamententryNestedInput
    user?: UserUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type TournamententryUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamententryUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentgameUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutTournamentgameNestedInput
  }

  export type TournamentgameUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentgameUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type RainBetCreateManyRainHistoryInput = {
    id?: string
    userId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainTipCreateManyRainHistoryInput = {
    id?: string
    userId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainWinnerCreateManyRainHistoryInput = {
    id?: string
    userId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type RainBetUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRainBetNestedInput
  }

  export type RainBetUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetUncheckedUpdateManyWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainTipUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRainTipNestedInput
  }

  export type RainTipUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUncheckedUpdateManyWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRainWinnerNestedInput
  }

  export type RainWinnerUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUncheckedUpdateManyWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamesessionCreateManyVipInfoInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
  }

  export type TransactionCreateManyVipInfoInput = {
    id?: string
    type?: $Enums.TransactionType
    amount?: number
    amountCredits?: number
    buyerCashtag?: string | null
    buyerUserId?: string | null
    username?: string | null
    cashiername?: string | null
    cashierAvatar?: string | null
    cashierId?: string | null
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId?: string | null
    cashtag?: string | null
    productid?: string | null
  }

  export type GamesessionUpdateWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: ChatroomUpdateManyWithoutGamesessionNestedInput
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: TournamentUpdateOneWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    chatroom?: ChatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type GamesessionUncheckedUpdateManyWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUpdateWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: GamesessionUpdateOneWithoutTransactionNestedInput
    profile?: ProfileUpdateOneWithoutTransactionsNestedInput
    product?: ProductUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    amountCredits?: IntFieldUpdateOperationsInput | number
    buyerCashtag?: NullableStringFieldUpdateOperationsInput | string | null
    buyerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    cashiername?: NullableStringFieldUpdateOperationsInput | string | null
    cashierAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    cashierId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AchievementCountOutputTypeDefaultArgs instead
     */
    export type AchievementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperatorCountOutputTypeDefaultArgs instead
     */
    export type OperatorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperatorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileCountOutputTypeDefaultArgs instead
     */
    export type ProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameCountOutputTypeDefaultArgs instead
     */
    export type GameCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatroomCountOutputTypeDefaultArgs instead
     */
    export type ChatroomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatroomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GamesessionCountOutputTypeDefaultArgs instead
     */
    export type GamesessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GamesessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TournamentCountOutputTypeDefaultArgs instead
     */
    export type TournamentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TournamentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RainHistoryCountOutputTypeDefaultArgs instead
     */
    export type RainHistoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RainHistoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VipInfoCountOutputTypeDefaultArgs instead
     */
    export type VipInfoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VipInfoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementDefaultArgs instead
     */
    export type AchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlatformSessionDefaultArgs instead
     */
    export type PlatformSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlatformSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperatorDefaultArgs instead
     */
    export type OperatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameDefaultArgs instead
     */
    export type GameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperatorgameDefaultArgs instead
     */
    export type OperatorgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperatorgameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationDefaultArgs instead
     */
    export type VerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberDefaultArgs instead
     */
    export type MemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvitationDefaultArgs instead
     */
    export type InvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TwoFactorDefaultArgs instead
     */
    export type TwoFactorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TwoFactorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatmessageDefaultArgs instead
     */
    export type ChatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatmessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatroomDefaultArgs instead
     */
    export type ChatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatroomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FriendshipDefaultArgs instead
     */
    export type FriendshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FriendshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GamesessionDefaultArgs instead
     */
    export type GamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GamesessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TournamentDefaultArgs instead
     */
    export type TournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TournamentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TournamententryDefaultArgs instead
     */
    export type TournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TournamententryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TournamentgameDefaultArgs instead
     */
    export type TournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TournamentgameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserachievementDefaultArgs instead
     */
    export type UserachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserachievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RainBetDefaultArgs instead
     */
    export type RainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RainBetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RainHistoryDefaultArgs instead
     */
    export type RainHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RainHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RainTipDefaultArgs instead
     */
    export type RainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RainTipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RainWinnerDefaultArgs instead
     */
    export type RainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RainWinnerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VipInfoDefaultArgs instead
     */
    export type VipInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VipInfoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventLogDefaultArgs instead
     */
    export type EventLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}